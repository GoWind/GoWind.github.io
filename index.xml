<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Gowind&#39;s site</title>
    <link>https://gowind.github.io/</link>
    <description>Recent content on Gowind&#39;s site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>mailto:petrovgovind@gmail.com (Govind)</managingEditor>
    <webMaster>mailto:petrovgovind@gmail.com (Govind)</webMaster>
    <lastBuildDate>Fri, 15 Mar 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://gowind.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SIMD algos part III: Blending and Permutations</title>
      <link>https://gowind.github.io/post/simd_algos_part3/</link>
      <pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/simd_algos_part3/</guid>
      <description>I wanted to the end the last post in this series, explaining the encoding part of the SIMD base64 solution, but while trying to write it down, it looked like it might be too large forr one single article.</description>
      <content:encoded><![CDATA[<p>I wanted to the end the last post in this series, explaining the encoding part of the SIMD base64 solution, but while trying to write it down, it looked like it might be too large forr one single article. Also stuff going in my life has made time even dearer to me, thus cutting short the amount of time I could spend writing. We close out this article series on SIMD with 2 other interesting instructions : Blend and Permute</p>
<h2 id="blend">Blend</h2>
<p>Blend lets one blend the lanes of 2 registers, based on a control mask/control vector.
The algorithm goes something like this:</p>





<pre tabindex="0"><code>// blend byte lanes from a and b based on control
blend_epi8(__m256i a, __m256i b, __m256i control) {
  result = __mm256i();
  for(int i=0;i&lt;32;i++) {
    if(control.lane[i] &amp; 0x80) // highest bit of same lane in control is set
      result.lane[i] = b[i]
  } else {
    result.lane[i] = a[i]
  }
}</code></pre><p>In lane i of the result, If the MSB of the control lane is 1, then we will use the value from b for lane i, else we use the value from lane i of a.</p>
<p>This can be used for finding and replacing or removing a certain value from an array
For example, here is a fn that replaces all the dots (ASCII code 45) with underscores (ASCII CODE 46).</p>





<pre tabindex="0"><code>__m256i replaceDots(uint8_t* j) {|
  __m256i loadedValue = _mm256_loadu_si256( (__m256i*)j);|
  __m256i dots = _mm256_set1_epi8(46);|
  __m256i underscores = _mm256_set1_epi8(45);|
  __m256i mask = _mm256_cmpeq_epi8(loadedValue, dots);|
  __m256i result = _mm256_blendv_epi8(loadedValue, underscores, mask);
  return result;
  }</code></pre><p>We first load a buffer into our register and then compare each of the byte against a dot (Decimal 46). The <code>_mm256_cmpeq_epi8</code> makes 32 comparisons at ones, setting a <code>1</code> in lane i in mask , if loadedValue[i] == 46, else sets a <code>0</code> in.</p>
<p>Now that we know which lanes are 46 in our source ( <code>1</code> in the mask, we simply mark those lanes as to be replaced with an undescore, and we do so with the blend intrinsic: <code>mm256_blendv_epi8(loadedValue, underscores, mask)</code>. If lane [i] of mask is 1, then we replace it with a value from underscores (which is just a register with all lanes set to the value 45), else we use the original value from our source register.</p>
<p>This example works only for an ASCII encoded buffer (as for the comparison and replacement to work right, all values in our input must be 1-byte values)</p>
<h2 id="permute">Permute</h2>
<p>Permute intrinsics / instructions allow you to swap /permute the lanes of the registers. Through a control mask again, you can do stuff like register.lane[10] = register.lane[11], register.lane[4] = register.lane[0] etc.</p>
<p>While reading a paper, I <a href="https://users.cs.utah.edu/~regehr/minotaur-oopsla24.pdf">came across</a> an interesting technique to find and replace characters in the reverse direction (which I split it into the 2 examples above and below). I thought, why not use SIMD to reverse an array of 32 characters ?</p>
<p>Remember the <code>shuffle</code> intrinsics from the previous posts ? We can use shuffle to swap the order of elements in an input array in a different order.</p>





<pre tabindex="0"><code>__m256i reverse(__m256i input) {
    __m256i reversed_indexes = _mm256_setr_epi8(
        15, 14, 13, 12, 
        11, 10, 9,8, 
        7, 6, 5, 4,
        3, 2, 1, 0,
        15, 14, 13, 12,
        11, 10, 9, 8,
        7, 6, 5, 4,
        3, 2, 1, 0);
    return _mm256_shuffle_epi8(input, reversed_indexes);
}

__m256i linear = _mm256_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,|
 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);
__m256i reversed = reverse(linear);
reversed = _mm256_permute2x128_si256(reversed, reversed, 0x01);
print_mm256i(reversed);</code></pre><p>recall that shuffle does something like <code>value[i] = a[b[i]]</code> where <code>a</code> is <code>input</code> and <code>b</code> is our <code>reversed_indexes</code>.  I mapped index <code>0</code> -&gt; <code>15</code>, <code>1</code> -&gt; <code>14</code>&hellip; so that the shuffle efffectively reverses the elements order. But here is a catch: the above code only reverses the elements within one half of the 2 128-bit lanes of the 256-bit register. Why ? because shuffle on avx2 cannot shuffle across all the 32-lanes of the 256b. register. We can only shuffle values amongst the first 128b lane or the second 128b lane, but not across.</p>
<p>So the solution is to reverse each lane by itself and then swap the order of the lanes in the register, something like this :</p>





<pre tabindex="0"><code>0 1 2 3 4 5 ......... 16 17 18 ... 30 31
Shuffle within lanes
15 14 13 12 11 10 ... 0 , 
Switch lanes using perumute
31 30 29 28 .... 17 16, 15 14 13 12 11 10 ... 0 </code></pre><p>You can see the output of my code for reversing , the lines are before and after reversing the array.</p>





<pre tabindex="0"><code>__m256i: [0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C, 0x13121110, 0x17161514, 0x1B1A1918, 0x1F1E1D1C, ]
__m256i: [0x1C1D1E1F, 0x18191A1B, 0x14151617, 0x10111213, 0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203, ]</code></pre><h3 id="where-to-go-from-here">Where to go from here</h3>
<p>All of the above instructions are just a small fraction of the features and capabilities of SIMD instruction sets. Be it NEON/SVE on ARM or AVX2/AVX-512 on x86_64, there are instructions that cater to trigonometric fns, complex number manipulation and other kinds of arithmetic/ logic instructions.  While one might try to read through the entire instruction set, I feel like that might be a big waste of time. Instead, it might be better to find out solved applications of SIMD where there is a concrete problem to solve and then learn how and which instructions were used. what I am trying to do is read through libraries like <a href="https://github.com/simdutf/simdutf">simdutf</a>, <a href="https://github.com/ashvardanian/SimSIMD">simSIMD</a> , <a href="https://github.com/simdjson/simdjson">simdjson</a> (simdjson for example, is well documented). These libraries solve problems in a specific context and have good documentation around them, making the process of learning how to use SIMD instructions less random and more structured.</p>
]]></content:encoded>
    </item>
    <item>
      <title>SIMD algos part II: popcount</title>
      <link>https://gowind.github.io/post/simd_algos_part2/</link>
      <pubDate>Thu, 24 Oct 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/simd_algos_part2/</guid>
      <description>Hamming Weight or Popcount A very popular task in Computing is counting the number of ones in a byte or a set of bites.</description>
      <content:encoded><![CDATA[<h1 id="hamming-weight-or-popcount">Hamming Weight or Popcount</h1>
<p>A very popular task in Computing is counting the number of ones in a byte or a set of bites.
This task is called <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a> or population count or more simply, popcount. Popcount is a popular enough instruction that most CPUs provide hardware instructions instead of relying on software routines. x86-64 provides a <code>popcnt</code> instruction that calculate the number of set bits in the source operand 64-bit register. ARM has a <code>CNT</code> instruction that calculates the number of set bits in the source 128-bit SIMD register.</p>
<p>You can access the popcount instruction using the <code>__builtin_popcount</code> fn in GCC (or Clang). GCC supports <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">builtin functions</a> , functions that extend features in C or provide optimized implementations of fns in the C standard library. The builtin might or might not use a hardware provided instruction to implement <code>popcount</code></p>
<p>The <a href="https://github.com/CountOnes/hamming_weight">Hamming Weight Repository</a> has a number of different implementations of popcount for both 32/64-bit values and SIMD accelerated versions to calculate the number of set bits in an array of 64-bit unsigned integers, each integer holding 64 counts (1/0).
I ran the benchmarks on a Core i5-10210U processor and , While the fastest implementation is  <code>avx2_harley_seal_bitset64_weight_unrolled_twice</code>, I modified the <code>avx2_bitset64_weight</code>implementation so that is easier to understand while still faster than the scalar popcount version that calculates popcount for an array of values in a loop, something like</p>





<pre tabindex="0"><code>for(int i=0;i&lt;N;i++) {
  totalCount += popcount(a[i]);
}</code></pre><p>My implementation is a bit interesting. I assumed that eliminating the inner loop from the <code>avx2_bitset64_weight</code> would make my implementation faster, but surprise ! It actually ended up running ~20% slower THAN the one with an inner loop ! How come ? Did the inner loop get unrolled ? Or is the additional instruction that I used so much slower that the overhead of a second loop was lower than it ? I don&rsquo;t know yet, perhaps someday I will get good enough with perf observations and microarchitectures to make a hypothesis and prove it. But for now, we can continue using my implementation to understand SIMD instructions while still not being slow.</p>





<pre tabindex="0"><code>size = 12288 words or 98304 bytes 
lauradoux_bitset64_weight(prec, size)                       	:  1.89 cycles per operation (best) 	1.95 cycles per operation (avg) 
scalar_bitset64_weight(prec, size)                          	:  2.67 cycles per operation (best) 	2.77 cycles per operation (avg) 
scalar_harley_seal8_bitset64_weight(prec, size)             	:  1.43 cycles per operation (best) 	1.47 cycles per operation (avg) 
scalar_harley_seal_bitset64_weight(prec, size)              	:  1.31 cycles per operation (best) 	1.32 cycles per operation (avg) 
table_bitset8_weight((uint8_t *)prec, size * 8)             	:  4.75 cycles per operation (best) 	4.76 cycles per operation (avg) 
table_bitset16_weight((uint16_t *)prec, size * 4)           	:  3.14 cycles per operation (best) 	3.21 cycles per operation (avg) 
....
sse_harley_seal_bitset64_weight(prec, size)                 	:  0.64 cycles per operation (best) 	0.64 cycles per operation (avg) 
avx2_bitset64_weight(prec, size)                            	:  0.38 cycles per operation (best) 	0.39 cycles per operation (avg) 
gov_avx2_bitset64_weight(prec, size)                        	:  0.48 cycles per operation (best) 	0.48 cycles per operation (avg) 
avx2_lookup_bitset64_weight(prec, size)                     	:  0.38 cycles per operation (best) 	0.39 cycles per operation (avg) 
avx2_lookup2_bitset64_weight(prec, size)                    	:  0.39 cycles per operation (best) 	0.40 cycles per operation (avg) 
avx2_lauradoux_bitset64_weight(prec, size)                  	:  0.48 cycles per operation (best) 	0.50 cycles per operation (avg) 
.....
avx2_harley_seal_nate_bitset64_weight(prec, size)           	:  0.32 cycles per operation (best) 	0.33 cycles per operation (avg) 
avx2_harley_seal_walisch_bitset64_weight(prec, size)        	:  0.34 cycles per operation (best) 	0.35 cycles per operation (avg) 
avx2_harley_seal_bitset64_weight_unrolled_twice(prec, size) 	:  0.30 cycles per operation (best) 	0.31 cycles per operation (avg) 
no AVX512 instructions
no XOP instructions

Output of running the benchmarks with my implementation. While having no nested loop like avx2_bitset64_weight, it still ended up being roughly 20-25% slower per cycle than the avx2_bitset64_weight fn</code></pre><p>The <a href="https://github.com/CountOnes/hamming_weight/blob/master/src/avx_hamming_weight.c">implementation</a> is the following snippet (<strong>NOTE</strong>: the snippet below is a modified version of the one in the repository)</p>





<pre tabindex="0"><code>// compute the Hamming weight of an array of 64-bit words using AVX2 instructions
int gov_avx2_bitset64_weight(const uint64_t * array, size_t length) {
    if(length &lt; 4) {
      int leftover = 0;
      for(size_t k = 0; k &lt; length; ++k) {
        leftover += _mm_popcnt_u64(array[k]);
      }
      return leftover;
    }
    uint64_t* next = array;
    int outer = length / 4;
    // these are precomputed hamming weights (weight(0), weight(1)...)
    const __m256i shuf =
        _mm256_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 0, 1,
                         1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);
    const __m256i mask = _mm256_set1_epi8(0x0f);  // low 4 bits of each byte
    __m256i zero = _mm256_setzero_si256();
    __m256i total = _mm256_setzero_si256();
    for (int k = 0; k &lt; outer; k++) {
        next = array + (k * 4);
        __m256i innertotal = _mm256_setzero_si256();
        __m256i ymm1 =
          _mm256_lddqu_si256((const __m256i *)next);
        __m256i ymm2 =
          _mm256_srli_epi32(ymm1, 4);  // shift right, shiftingin zeroes
        ymm1 = _mm256_and_si256(ymm1, mask);  // contains even 4 bits
        ymm2 = _mm256_and_si256(ymm2, mask);  // contains odd 4 bits
        ymm1 = _mm256_shuffle_epi8(
            shuf, ymm1);  // use table look-up to sum the 4 bits
        ymm2 = _mm256_shuffle_epi8(shuf, ymm2);
        innertotal = _mm256_add_epi8(innertotal, ymm1);  // inner total
        innertotal = _mm256_add_epi8(innertotal, ymm2);  // inner total
        innertotal = _mm256_sad_epu8(zero, innertotal);  // produces 4 64-bit
        total = _mm256_add_epi64(total, innertotal);

    }
    const int leftoverwords =  length % 4;
    int leftover = 0;
    for(size_t k = length - leftoverwords; k &lt; length; ++k) {
      leftover += _mm_popcnt_u64(array[k]);
    }
    return leftover + _mm256_extract_epi64(total, 0) +    _mm256_extract_epi64(total, 1) +
           _mm256_extract_epi64(total, 2) + _mm256_extract_epi64(total, 3);
}</code></pre><p>The leftover portion deals with 2 cases:</p>
<ol>
<li>When the total number of bits in the array is &lt; 256. In that case, just use the scalary version</li>
<li>When the array size is not a multiple of 8 64-bit ints. In this case, the last  N % 8 bits are processed serially.</li>
</ol>
<p>The remaining N / 8 bytes are handled in a SIMD accelerated loop. I shall try to illustrate the algorithm using a real example for an array of inputs</p>
<p>as input, lets use</p>





<pre tabindex="0"><code>  uint64_t a[61] = {[0 ... 60] = 0xFEAA0088};</code></pre><p>There are 13 set bits in <code>0xFEAA0088</code>. An array of 61 values must therefore yield us 13 * 61 = 793.</p>
<p>I do not want to focus on the entire body of the fn, but only on the loop <code>for (int k = 0; k &lt; outer; k++) {</code>. The rest as mentioned is just dealing with the leftovers array_size % 32 bytes serially.</p>
<p>The value <code>shuf</code> is quite clever. It stores a pre-computed array of values, where the index is a number between 0-15 (that is 0x0 - 0xF) and the value is the number of bits in the index (shuf[16 / 0xF] = 3). Thus, in each iteration, we can split our input 256 bits into 64, 4-bit values and simply loop over the count of <code>1</code>s in each of the 4-bit values to get the final tally of <code>1</code>s ! Quite clever eh ?
There is one more very clever optimization: Normally arrays are stored in the memory as a continuous set of bytes : <code>a[0], a[1], a[2]</code>. When fetching a memory location <code>a[n]</code>, if the value is not in the CPU&rsquo;s cache, it must be fetched from the main memory, thus stalling the instruction and slowing performance. However, shuf is <strong>NOT</strong> an array, but a single 256-bit register value. This means that to do a lookup of <code>1s</code> in a 4 bit value, no Cache/Memory lookup is needed as the entire array fits into a single register and we can lookup the hamming weight of a 4-bit value using just a shuffle SIMD instruction !</p>
<p>To calculate the number of <code>1</code>s , we split our input 256 bits into 4-bits each  first and this is how we do it:</p>





<pre tabindex="0"><code>   __m256i ymm1 =
          _mm256_lddqu_si256((const __m256i *)next);
        __m256i ymm2 =
          _mm256_srli_epi32(ymm1, 4);  // shift right, shiftingin zeroes
        ymm1 = _mm256_and_si256(ymm1, mask);  // contains even 4 bits
        ymm2 = _mm256_and_si256(ymm2, mask);  // contains odd 4 bits
     </code></pre><p><code>ymm1</code> has the 256 bits under consideration. We then load <code>ymm2</code>  with <code>ymm1</code>, butwhere each 32-bit lane is right shifted by 0 4 times.
Given our example array above, <code>ymmm1</code> would look something like</p>





<pre tabindex="0"><code>[0xFEAA0088 00000000 0xFEAA0088 00000000 0xFEAA0088 00000000 0xFEAA0088 00000000]</code></pre><p>(Intel is little-endian so a 64-bit integer representing <code>0xFEAA0088</code> is <code>0x00000000FEAA0088</code> and the Least Significant Bytes are stored in the first memory address followed by the second and so on)
Shifted right by 4 bits in each 32-bit lane, we get ymm2</p>





<pre tabindex="0"><code>[0x0FEAA008 00000000 0x0FEAA008 00000000 0x0FEAA008 00000000 0x0FEAA008 00000000]</code></pre><p>If I <code>and</code> both <code>ymm1</code> and <code>ymm2</code> with a mask register of repeated <code>0x0F</code> values</p>





<pre tabindex="0"><code>[0x0FEAA008 00000000 0x0FEAA008 00000000 0x0FEAA008 00000000 0x0FEAA008 00000000]
&amp;&amp;
[0x0F0F0F0F 0x0F0F0F0F 0x0F0F0F0F 0x0F0F0F0F 0x0F0F0F0F 0x0F0F0F0F 0x0F0F0F0F 0x0F0F0F0F]</code></pre><p>essentially I endup with 2 all the even 4-bits in ymm1 and the odd 4-bits in ymm2.</p>





<pre tabindex="0"><code class="language-ymm2" data-lang="ymm2">[0x0F0A0008 00000000 0x0F0A0008 0x00000000 0x0F0A0008 0x00000000 0x0F0A0008 0x00000000]</code></pre><p>In both <code>ymm1</code> and <code>ymm2</code> we only select 4-bits out of each 8-bit lane from the input. This means that the higher 4-bits of each 8-bit lane is 0, thus each 8-bit lane has a value [0..15]. Using the <code>shuffle</code> intrinsic, we can lookup number of <code>1</code>s in each 8-bit lane from <code>shuf</code> register</p>





<pre tabindex="0"><code>ymm2 = _mm256_shuffle_epi8(shuf, ymm2)
// this is akin to doing
for(int i = 0; i &lt; 32;i++) {
 ymm2[i] = shuf[ymm2[i]];
}</code></pre><p>We do not have to worry about overflowing because all the values in shuf are &lt; 16
After the <code>shuffle</code> intrinsice, <code>ymm1</code> will contain the number of <code>1</code>s in the even 4-bits and <code>ymm2</code> will contain the number of <code>1</code>s in the odd 4-bits. We then add them lane-wise to a running counter <code>innertotal</code></p>





<pre tabindex="0"><code>innertotal = _mm256_add_epi8(innertotal, ymm1);  // inner total
innertotal = _mm256_add_epi8(innertotal, ymm2);  // inner total</code></pre><p>We do not have to worry about overflows here as well, as the max value in each 8-bit lane is 32 (16 + 16).</p>
<p>Our final count will be the sum of all of the 8-bit lanes in <code>innertotal</code>.</p>





<pre tabindex="0"><code>total = 0;
for(int i=0;i&lt;32;i++) { total += register[lane_i];}</code></pre><p>Unfortunately, there is no intrinsic in avx2 to do this operation, so we employ a little trick using the <code>_mm256_sad_epu8</code> or the Sum Absolute Differences intrinsic</p>





<pre tabindex="0"><code>innertotal = _mm256_sad_epu8(zero, innertotal);  // produces 4 64-bit
total = _mm256_add_epi64(total, innertotal);</code></pre><p>the <code>sad_epu8</code> intrinsic, subtracts each 8-bit lane from register b (innertotal) from register a (zero), takes the absolute of the value and adds them with the value from the other lanes.</p>
<p>it emits 4 64-bit values containing the sum of 8, 8-bit lanes. To make this easier to understand here is the output of the previous 2 intrinsics</p>





<pre tabindex="0"><code>innertotal: [0x07040002, 0x00000000, 0x07040002, 0x00000000, 0x07040002, 0x00000000, 0x07040002, 0x00000000, ]
total: [0x0000000D, 0x00000000, 0x0000000D, 0x00000000, 0x0000000D, 0x00000000, 0x0000000D, 0x00000000, ]</code></pre><p>The first 64-bit lane in <code>total</code> contains the value 0xD (or decimal 13), which is the sum of the first 8 8 bit lanes in <code>innertotal</code>. This incidentally is also number of <code>1</code>s in each of the elements in the input array !</p>
<p>Once the loops are processed, we process any leftover values</p>





<pre tabindex="0"><code>const int leftoverwords =  length % 4;
int leftover = 0;
for(size_t k = length - leftoverwords; k &lt; length; ++k) {
      leftover += _mm_popcnt_u64(array[k]);
}</code></pre><p>Since our total is a vector register and we are returning a single 64-bit value, we must extract each 64-bit value from our <code>total</code> register. We can do that using <code>__mm256_extract_epi64(register, lane)</code> to extract the 64-bit value in <code>lane</code>.</p>





<pre tabindex="0"><code>return leftover + _mm256_extract_epi64(total, 0) + _mm256_extract_epi64(total, 1) 
+ _mm256_extract_epi64(total, 2) + _mm256_extract_epi64(total, 3);</code></pre><p>Using SIMD , we thus process 256-bits in a go instead of 64-bits in each iteration using <code>      _mm_popcnt_u64(array[k])</code>, with potentially upto 4x the speed up (in reality, due to loop overhead and multiple instructions per loop iteration, the speed is 2x or less)</p>
<h3 id="conclusion">Conclusion</h3>
<p>We used SIMD to solve a problem with real world applications and not just as a contrived example. I was very surprised by the fact that my fn with no inner loop ended up being slower than one with 2 loops. Clearly O(n^2) must be slower than O(n) right ?
I still have no idea how this happened , but I speculate that with all the optimization flags turned on, the compiler decided to unroll the innerloop thus avoiding the overhead of the loop, or am I getting slowed down due to microarchitecture issues ? I will continue investigating this and hopefully in the future have an answer.</p>
]]></content:encoded>
    </item>
    <item>
      <title>SIMD algos: Part 1</title>
      <link>https://gowind.github.io/post/simd_algos_part1/</link>
      <pubDate>Mon, 21 Oct 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/simd_algos_part1/</guid>
      <description>I have been on a study of SIMD algorithms for the past few weeks, to understand how developers adapt and tweak serial algorithms to take advantage of SIMD hardware.</description>
      <content:encoded><![CDATA[<p>I have been on a study of SIMD algorithms for the past few weeks, to understand how developers adapt and tweak serial algorithms to take advantage of SIMD hardware. In this post, In this series, I will explore a small piece of a library that exploits SIMD hardware in commodity processors on laptops and desktops to accelerate base64 encoding and decoding, <a href="https://github.com/lemire/fastbase64">fastbase64</a> courtesy <a href="https://lemire.me/blog/">Prof Lemire</a>, who has worked on many libraries to accelerate common text processing tasks , such as parsing <a href="https://github.com/simdjson/simdjson">JSON</a> and <a href="https://github.com/simdutf/simdutf">UTF</a> parsing</p>
<h1 id="a-brief-introduction-to-simd">A Brief introduction to SIMD</h1>
<p>SIMD stands for : Single Instruction Multiple Data.</p>
<p>Essentially it is a special set of hardware execution units and registers on processors that can perform the same operation on multiple units of data at the same time.</p>
<h4 id="without-simd">Without SIMD</h4>
<p>Take for example a simple loop to element-wise sum 2 arrays</p>





<pre tabindex="0"><code>
for(int i=0; i &lt; n; i++) {
   dest[i] = a[i] + b[i]
}</code></pre><p>The processor would execute addition element by element , something like the loop below</p>





<pre tabindex="0"><code>`; Assuming: 
; rdi = pointer to dest array 
; rsi = pointer to a array 
; rdx = pointer to b array 
; rcx = n (number of elements)     
xor r8, r8          ; Initialize loop counter (i) to 0 
.loop:     
	cmp r8, rcx         ; Compare i with n    
	jge .done           ; If i &gt;= n, exit loop     
	mov eax, [rsi + r8*4] ; Load a[i] into eax    
	add eax, [rdx + r8*4] ; Add b[i] to eax    
	mov [rdi + r8*4], eax ; Store result in dest[i]     
	inc r8              ; Increment loop counter    
	jmp .loop           ; Continue loop .done:     
; Loop finished`</code></pre><p>The compiler is smart enough to unroll the loop at times, so that it runs faster but we are still adding only one index (a[i] + b[i]) at a time.</p>
<h4 id="with-simd">With SIMD</h4>
<p>The processor provides special SIMD registers. The registers are (atleast today) 128, 256, 512 bits or more wide. The registers are split into <strong>lanes</strong> that can be 8, 16, 32 or 64 bits wide. We provide one instruction that operates on all of the lanes at once.</p>
<p>In the following example, we are splitting 128 bit register into 4 lanes, 32-bits each and then element wise adding them.</p>
<p><img src="simd_image.png" alt="SIMD image"></p>
<p>Elementwise addition is not the only operation supported, other ops like multiplication , sub, trig fns are also supported depending on the processor.</p>
<p>In this series, I will restrict myself to x86-64 processors (both Intel and AMD) supporting the AVX2 instruction set.</p>
<p>x86 has multiple versions of SIMD instructions and registers. The oldest is MMX, followed by SSE, then AVX/AVX2 and AVX-512 and family of instructions.
MMX had 64-bit wide registers and supported only integer operations, while SSE added 128-bit registers and supported floating point arithmetic. AVX increased the register sizes to 256 bits and AVX-512 expanded the register size to 512 bits. Each generation added newer instructions to manipulate the registers. The <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">Wikipedia</a> article is a good summary of the various instruction sets and capabilities.</p>
<h3 id="how-to-use-simd-">How to use SIMD ?</h3>
<p>SIMD instructions make use of SIMD registers that are 128,256 or 512 bits. The instruction set provides various instructions to manipulate the registers. AVX2 for example provides 16 256 bit registers, named ymm0-ymm15.
Each instruction works on one or more register and produces a result.
To use these instructions, we could use inline asm in our code to emit the assembly instructions directly, or we could enable optimisation flags in our compiler (-O2, -O3 etc) and pray that the compiler is smart enough to generate the optimisations to use these instructions.</p>
<p>There is also a 3rd option: using <a href="https://www.intel.com/content/www/us/en/docs/cpp-compiler/developer-guide-reference/2021-8/intrinsics-for-avx2.html">intrinsics</a>. These are architecture specific datatypes and header files that provide functions and datatypes to manipulate the SIMD registers by using using SIMD instructions.</p>
<p>On x86-64 Linux, the header file <code>#include &lt;immintrin.h&gt;</code> (or <code>&lt;x86intrin.h&gt;</code>) provides the <code>_mm256i</code> datatype that represents a 256-bit register. The header file also provides a <code>_m256i_add_epi32</code> fn  that (among many others) takes 2 <code>_mm256i</code> arguments, each having 8 lanes of 32-bit signed integers and adds them lane wise. You can visualise this as the diagram above having 8 instead of 4 lanes in each register and then pairwise adding them.</p>
<p>A second arithmetic function provided by the intrinsics library is <code>__m256i _mm256_mulhi_epi16(__m256i s1, __m256i s2);</code> This fn splits each register as 16 16-bit values and then element-wise multiplies them. Since multiplying 2 16-bit values can produce upto a 32-bit value, the <code>mulhi</code> part of the instruction instructs the CPU to only store the high 16 bits of each result, while discarding the lower 16-bits.</p>





<pre tabindex="0"><code>ymm0 = {0x00 0x48 0x40 0x0f 0x00 0x64 0x40 0x06 0x00 0x70 0x00 0x0c 0x00 0x74 0x00 0x05 0x00 0x60 0x40 0x0c 0x00 0x6c 0x40 0x00 0x00 0x64 0x40 0x04 0x00 0x6c 0x40 0x00}
    

ymm7 = {0x40 0x00 0x00 0x04 0x40 0x00 0x00 0x04 0x40 0x00 0x00 0x04 0x40 0x00 0x00 0x04 0x40 0x00 0x00 0x04 0x40 0x00 0x00 0x04 0x40 0x00 0x00 0x04 0x40 0x00 0x00 0x04}
    

The register values are stored in little endian, so 0x00 0x48 is 0x4800. 0x40 0x00 is 0x0040. The 2 multiplied, first 2 bytes are 0x12 00, which are set
    
7. output = ymm2 = {0x12 0x00 0x3d 0x00 0x19 0x00 0x19 0x00 0x1c 0x00 0x30 0x00 0x1d 0x00 0x14 0x00 0x18 0x00 0x31 0x00 0x1b 0x00 0x01 0x00 0x19 0x00 0x11 0x00 0x1b 0x00 0x01 0x00} = t1</code></pre><p>Arithmetic is not the only type of instruction. There are other bit manipulation instructions that will come to use later, that are supported. One of the instructions is the <code>shuffle</code> instruction (vpshub). This instruction is represented by the <code>__m256i _mm256_shuffle_epi8(__m256i a, __m256i b)</code> intrinsic.</p>
<p>Shuffle instruction shuffles or reorders the elements in a source register (a) based on a <code>mask</code> register (b).if the results are written to register r and assuming b[i] =j, then r[i] = a[j] (value at index j of a is written to index i of output, hence the name <strong>shuffle</strong>)</p>





<pre tabindex="0"><code>Lookup Table: {0x00 0x00 0x00 0x00 0x48 0x6f 0x77 0x65 0x76 0x65 0x72 0x2c 0x20 0x77 0x65 0x20 0x61 0x6c 0x73 0x6f 0x20 0x6f 0x66 0x74 0x65 0x6e 0x20 0x75 0x73 0x65 0x20 0x74}
    
mask = {0x05 0x04 0x06 0x05 0x08 0x07 0x09 0x08 0x0b 0x0a 0x0c 0x0b 0x0e 0x0d 0x0f 0x0e 0x01 0x00 0x02 0x01 0x04 0x03 0x05 0x04 0x07 0x06 0x08 0x07 0x0a 0x09 0x0b 0x0a}

output = {0x6f 0x48 0x77 0x6f 0x76 0x65 0x65 0x76 0x2c 0x72 0x20 0x2c 0x65 0x77 0x20 0x65 0x6c 0x61 0x73 0x6c 0x20 0x6f 0x6f 0x20 0x74 0x66 0x65 0x74 0x20 0x6e 0x75 0x20}

Note that mask[0] = 0x5, hence output[0] = Lookup Table[0x5]</code></pre><p>The Shuffle instruction is very useful as a lookup table. You can fill the <code>mask</code> registers with indexes that you want to lookup and <code>a</code> be the lookup table. Assuming 256-bits or 512-bit registers and 1 byte indexes, you can have a 32 / 64 entry table WITHOUT HAVING TO TOUCH THE MEMORY OR THE CACHE AT ALL !</p>
<p>The last instruction I want to talk about is the Masked Load instruction. Lets deconstruct the words a bit:</p>
<ol>
<li>load - load data from memory</li>
<li>masked - provide a <code>mask</code> to control the loading. But how ?</li>
</ol>





<pre tabindex="0"><code>int main() {
  char* s = &#34;Mr batman, Mr batman, jungle man, spiderman&#34;;
  printf(&#34;%s\n&#34;, s - 12);
}</code></pre><p>The access to address <code>s-12</code> is might be invalid (as we didn&rsquo;t allocate the memory to any variable). The program might raise a segfault and get terminated due to illegal memory access.</p>
<p>Another case that comes up is loading the last few bytes of an array whose size is not a multiple of 8, 16, or 32.</p>
<p>Eg, lets try to sum up 2 arrays of  38 integers each.</p>





<pre tabindex="0"><code>#include &lt;x86intrin.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
void print_mm256i(__m256i var) {
  uint32_t val[8];
  _mm256_storeu_si256((__m256i*)val, var);
  printf(&#34;__m256i: [&#34;);
  for(int i = 0 ; i &lt; 8; i++) {
    printf(&#34;0x%08X&#34;, val[i]);
    if(i &lt; 8) printf(&#34;, &#34;);
  }
  printf(&#34;]\n&#34;);
}

int main() {
  int a[38] = {[0 ... 37] = 17};
  int b[38] = {[0 ... 37] = 19};
 for(int i =0; i &lt; 38;i += 8) {
    __m256i inputa = _mm256_loadu_si256(a + i);
    __m256i inputb = _mm256_loadu_si256(b + i );
    __m256i result = _mm256_add_epi32(inputa, inputb);
   print_mm256i(result);
  }
  return 0;
}</code></pre><p>There is one small problem in the code: In the last run of the loop, We are accessing indexes beyond <code>a + N</code>  (idx 38 and 39) which might result in a segfault. Even if we don&rsquo;t get segfaults, the result of adding the values of a[39] and b[39] might be total garbage</p>





<pre tabindex="0"><code> __m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, ]
    
 __m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, ]
    
__m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, ]
    
__m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, ]
    
__m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x79758C30, 0xBE4B62BA, ]

Array values in hexadecimal. Notice that the last 2 values are garbage whereas all the other values are the result of adding 17 + 19 = 36 (0x24)</code></pre><p>There are 2 options:</p>
<ol>
<li>Have a separate loop for loading the last few elements of the array that are not divisible by 8 (that is, set <code>i&lt; 32</code> and load elements 32&hellip;37 in a separate loop)</li>
<li>Use a <code>masked load</code></li>
</ol>
<p>A Masked load takes a <code>mask</code> vector alongside the pointer to load data from. The mask is a vector/array of 1/0 values that control if element at that index from the source pointer must be loaded
For example,
if mask = [1, 1, 1, 0, 0, 0, 0, 0]
then <code>res = masked_load(a, mask)</code> will only load <code>a[0], a[1] and a[2]</code>. <code>res[3..7]</code> will be set to 0 and any segfault that occur due to accessing <code>a[3..7]</code> will be suppressed</p>





<pre tabindex="0"><code>void add_with_masking(int* a, int* b, int N) {
 for(int i =0; i &lt; N;i += 8) {
     int elements_to_load = ((i + 8) &lt; N) ? 8: N % 8;
     __m256i mask_for_loading = generate_load_mask(elements_to_load);
    __m256i inputa = _mm256_maskload_epi32(a + i, mask_for_loading);
     __m256i inputb = _mm256_maskload_epi32(b + i, mask_for_loading);
    __m256i result = _mm256_add_epi32(inputa, inputb);
    printf(&#34;\nresult&#34;);
    print_mm256i(result);
  }
}

Output:
result__m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, ]

result__m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, ]

result__m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, ]

result__m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, ]

result__m256i: [0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000024, 0x00000000, 0x00000000, ]

Notice that the last 2 indexes have 0 as the resultant value since we do not load their corresponding source operands from a and b</code></pre><p>When loading elements from a and b, we generate a mask vector where for all indexes &lt; N  mask[index] = 0x8000 or 0 otherwise. This way, we can ignore index &gt; N without raising any segfaults. The fn <code>generate_load_mask(n)</code> generates a <code>mask</code> vector of 8 32-bit elements, again using SIMD instructions</p>





<pre tabindex="0"><code> __m256i generate_load_mask(int n) {
    __m256i index = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);
    __m256i n_vector = _mm256_set1_epi32(n);
    __m256i mask = _mm256_cmpgt_epi32(n_vector, index);
    __m256i result = _mm256_and_si256(mask, _mm256_set1_epi32(0x80000000));
    return result;
}</code></pre><p>On an input of <code>n=6</code>, we first set <code>index</code> = [0, 1, 2, 3, 4, 5, 6, 7].
<code>n_vector</code> repeats n 8 times: [n, n, n, n, n, n, n, n];
<code>_mm256_cmpgt_epi32</code> compares each element in <code>n_vector</code> with <code>index</code> and set each lane to 1 if n &gt; index  or 0 otherwise
The mask is thus <code>[1, 1, 1, 1, 1, 1, 0, 0]</code>. <code>_mm256_and_si256</code> does a logical <code>AND</code> of 2 vectors: the <code>mask</code> vector and a vector of constant <code>0x80000000</code>, thus resulting in a vector
<code>[0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0x80000000, 0, 0]</code></p>
<p>Thus in the last loop, loading from <code>i=32..40</code> we can thus mask out the loads to <code>a[38, 39</code> and <code>b[38, 39]</code> by using masked loads !</p>
<p>I hope I didn&rsquo;t complicate this too much! SIMD might look hard, but the fundamentals of it are relatively simple. This article covered the basic instructions and features of SIMD architectures/instruction sets. In the upcoming series of articles, we can see how we can use SIMD to accelerate a lot of commonly done computing tasks: Such as encoding/decoding and counting elements in a set !</p>
]]></content:encoded>
    </item>
    <item>
      <title>Mom, where is my library ?</title>
      <link>https://gowind.github.io/post/mom_where_is_my_library/</link>
      <pubDate>Fri, 02 Aug 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/mom_where_is_my_library/</guid>
      <description>So I wanted to use the ggml library to build some neural networks in C. The recipe was simple</description>
      <content:encoded><![CDATA[<p>So I wanted to use the <a href="https://github.com/ggerganov/ggml">ggml</a> library to build some neural networks in C. The recipe was simple</p>
<ol>
<li>Clone the ggml repo into <code>~/personal/ggml</code></li>
<li>Build the shared libraries needed to use ggml from my code</li>
<li>Use the shared libraries</li>
</ol>
<p>To build the shared library, I created a <code>ggml_lib</code> folder adjacent to the <code>ggml</code> library:</p>





<pre tabindex="0"><code>.
├── ggml
├── ggml_lib</code></pre><p>Then, <code>cd ggml_lib</code>
Followed by:</p>





<pre tabindex="0"><code>cmake ../ggml
cmake --build .
cmake --install . --prefix $(PWD)</code></pre><p>This installs the generated shared library under <code>ggml_lib/lib</code> and the headers under <code>ggml_lib/include</code></p>
<p>So these are all we need to start using ggml, here is a simple main that attempts. to create a couple of tensors and then frees them</p>





<pre tabindex="0"><code>#include &#34;ggml.h&#34;

int main() {
   struct ggml_init_params params  = {
            .mem_size   = 2048,
            .mem_buffer = NULL,
            .no_alloc   = false, 
    };

    // create context
    struct ggml_context* ctx = ggml_init(params);

    struct ggml_tensor* a = ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 5, 5);
    struct ggml_tensor* b = ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 10);

    ggml_free(ctx);
}</code></pre>




<pre tabindex="0"><code>$ gcc use_ggml.c -o use_ggml
use_ggml.c:1:10: fatal error: &#39;ggml.h&#39; file not found
#include &#34;ggml.h&#34;
         ^~~~~~~~</code></pre><p>Of course, your compiler cannot find the <code>ggml.h</code> Header file, so you have to specify a path to the compiler to search for this Header. We do this by passing the location to the Header file using the <code>-I</code> flag</p>





<pre tabindex="0"><code>$ gcc use_ggml.c -Iggml_lib/include -o use_ggml
ld: Undefined symbols:
  _ggml_free, referenced from:
      _main in use_ggml-0e7b1c.o
  _ggml_init, referenced from:
      _main in use_ggml-0e7b1c.o
  _ggml_new_tensor_2d, referenced from:
      _main in use_ggml-0e7b1c.o
      _main in use_ggml-0e7b1c.o
clang: error: linker command failed with exit code 1 (use -v to see invocation)</code></pre><p>Now, your compiler can find the header file, but when attempt to create a final executable , it cannot find the code to the actual functions <code>ggml_init, ggml_free</code> (the <code>_</code> prefix is a macOS platform detail where the names of your functions are prefixed with an <code>_</code> ). So now we have to tell the compiler to link against our dynamic library : <code>ggml</code>, we do this by passing the <code>-lggml</code> flag (the convention is <code>-lname_of_the_library_providing_your_code</code>)</p>
<p>So how can my compiler find where a library is located ? The compiler (and the linker) maintain a bunch of &ldquo;SEARCH PATHS&rdquo; where dynamic libraries are located and when attempting to link to a shared library, will attempt to find the library in the SEARCH PATHs before giving</p>
<p>Here is what I found reported as SEARCH PATHS on my mac laptop</p>





<pre tabindex="0"><code>$ gcc --print-search-dirs
programs: =/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
libraries: =/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/15.0.0


$ ld -v
@(#)PROGRAM:ld  PROJECT:dyld-1015.7
BUILD 18:48:48 Aug 22 2023
....
Library search paths:
Framework search paths:</code></pre><p>In addition, there are standard paths like <code>/usr/lib</code> or <code>/usr/local/lib</code> that your linker and compiler will search for to find shared libraries</p>
<p>Coming back to our example, our installed shared library is not in any of these location, so I must specify the path to <code>ggml_lib/lib</code> to the compiler so that it can find the generated ggml dynamic lib (dylib)</p>





<pre tabindex="0"><code>gcc use_ggml.c -Iinclude/ -Lggml_lib/lib -o use_ggml  -lggml

-lggml , link against the dynamic library ggml
-Lggml_lib/lb, you will find the file libggml.dylib under ggml_lib/lib</code></pre><h2 id="problem">Problem</h2>
<p>Okay, it works. Now I just have to run my binary <code>use_ggml</code> right ? Right ?</p>





<pre tabindex="0"><code>$ ./use_ggml
dyld[35649]: Library not loaded: @rpath/libggml.dylib
  Referenced from: &lt;8B6DF1BE-A897-383F-AB20-DBDB61039351&gt; /Users/govind/personal/use_ggml
  Reason: no LC_RPATH&#39;s found
[1]    35649 abort      ./use_ggml</code></pre><p>What happened ? Didn&rsquo;t we find our <code>ggml</code> dynamic library and set its location correctly when compiling the program ? Why is that when we run this code now, we run into some errors about the Library not being loaded ?</p>
<h2 id="answer-the-dynamic-linker">Answer: The dynamic linker</h2>
<p>Recall that a <a href="https://en.wikipedia.org/wiki/Shared_library">shared library</a> is a piece of executable code, that is shared across multiple binaries. This means that this piece of code can be loaded into other binaries. For example, if you want to use graphics, rather than create big binaries with all the graphics related operations, the OS will provide a shared library for graphics. As an executable, you need not bring your own Graphics related libraries, but just declare a dependency on the shared graphics library and it is the OS&rsquo;s responsibility now to provide you the shared library when your binary is executed.</p>
<p>Who is responsible for loading this shared library into your binary when it is run ? It is the <strong><a href="https://en.wikipedia.org/wiki/Dynamic_linker">DYNAMIC LINKER</a></strong> which loads and links the needed shared libraries at runtime.</p>
<p>When you run a binary , example : <code>./use_ggml</code>, the dynamic linker <code>dyld</code> is executed by the operation system, which then reads &ldquo;LOAD COMMANDS&rdquo; from the executable to figure out how to setup the executable in memory, before the executable is actually executed (<code>main</code> of your program)</p>
<p>On macOS binaries,  you can inspect your binary&rsquo;s dependencies using the <code>otool</code> command</p>





<pre tabindex="0"><code>otool -l use_ggml
Load command 13
          cmd LC_LOAD_DYLIB
      cmdsize 48
         name @rpath/libggml.dylib (offset 24)
   time stamp 2 Thu Jan  1 01:00:02 1970
      current version 0.0.0
compatibility version 0.0.0
Load command 14
          cmd LC_LOAD_DYLIB
      cmdsize 56
         name /usr/lib/libSystem.B.dylib (offset 24)
   time stamp 2 Thu Jan  1 01:00:02 1970</code></pre><p>the <code>LC_LOAD_DYLIB</code> is a command to the <code>dyld</code> to load a dynamic library. Note the <code>@rpath</code> macro.
The <code>@rpath</code> is a macro that expands to <code>RUNTIME_PATH</code> , a path of locations at runtime (when the executable starts executing) where <code>dyld</code> will search for shared libraries.
The <code>@rpath</code> isn&rsquo;t a location in itself, but is set when the executable&rsquo;s image is being created in the memory.</p>
<p>The value of <code>@rpath</code> is set by an <code>LC_RPATH</code> command that sets the rpath to a particular location (thus providing the location to our dynlib as <code>/path/to/libggml.dylib</code>) , which in our case, is missing and thus causing <code>dyld</code> to throw an error when attempting to run our executable.</p>
<h3 id="so-how-do-we-fix-this-">So how do we fix this ?</h3>
<p>There are a few solutions, each of which will helps us understand a bit further on how loading dynamic libraries work</p>
<ol>
<li>Using <code>DYLD_LIBRARY_PATH</code> (command: <code>DYLD_LIBRARY_PATH=. ./use_ggml</code>)</li>
</ol>
<p>The <code>DYLD_LIBRARY_PATH</code> is an environment variable that the dynamic linker parses before loading an executable. You can use DYLD_LIBRARY_PATH to provide a colon separated list of directories to search for shared libraries.</p>
<p>Here is an example of using DYLD_LIBRARY_PATH to let dyld know where to look for libggml.dylib</p>





<pre tabindex="0"><code>~/personal/ggml-node
$ DYLD_LIBRARY_PATH=./ggml_lib/lib ./use_ggml

~/personal/ggml-node</code></pre><p>Success !!</p>
<ol start="2">
<li>Setting the <code>rpath</code> when creating the executable</li>
</ol>
<p>We pass flags to the linker when compiling our executable (as an aside, read Sanglard&rsquo;s <a href="https://fabiensanglard.net/dc/index.php">brilliant</a> articles on how compiler drivers  function). We can expand the <code>rpath</code> macro to a location that is dependent on where the executable is located</p>





<pre tabindex="0"><code>gcc use_ggml.c -Iinclude/ -Lggml_lib/lib -o use_ggml  -lggml -Wl,-rpath,@executable_path/ggml_lib/lib</code></pre><p><code>-Wl,option1,option2</code>  is how we pass flags to the linker via <code>gcc</code> compiler driver. The <code>@executable_path</code> is a placeholder to the location of the executable. What this says is: when looking for <code>libggml.dylib</code>, look it in the directory : <code>LOCATION_OF_EXECUTABLE/ggml_lib</code>. So if your executable is located at <code>/Users/personal</code> then look up <code>libggml.dylib</code> in <code>/Users/personal/ggml_lib</code>
There are other placeholders such as <code>@loader_path</code> , but lets not look into them now to avoid confusion.</p>
<p>Once we set the <code>rpath</code>, lets look at the LOAD_COMMANDS in the executable to see if anything has changed</p>





<pre tabindex="0"><code>otool -l use_ggml
Load command 13
          cmd LC_LOAD_DYLIB
      cmdsize 48
         name @rpath/libggml.dylib (offset 24)
   time stamp 2 Thu Jan  1 01:00:02 1970
      current version 0.0.0
compatibility version 0.0.0
Load command 14
          cmd LC_LOAD_DYLIB
      cmdsize 56
         name /usr/lib/libSystem.B.dylib (offset 24)
   time stamp 2 Thu Jan  1 01:00:02 1970
      current version 1336.0.0
compatibility version 1.0.0
Load command 15
          cmd LC_RPATH
      cmdsize 48
         path @executable_path/ggml_lib/lib (offset 12)</code></pre><p>BINGO ! Remember the missing <code>LC_RPATH</code> command that was the cause of the dyld error ? We now have an LC_RPATH command that points to the directory <code>ggml_lib/lib</code> relative to the location of the executable.</p>
<p>So, does this solve the problem ?</p>





<pre tabindex="0"><code>$ ./use_ggml

~/personal </code></pre><p>YES ! A resounding YES !</p>
<h2 id="summary">Summary</h2>
<p>Turns out finding and loading shared libraries is a actually a tricky problem when shipping native applications. A lot of this complexity is thankfully handled by the OS and package managers, but it is good to understand the problems faced by native applications to truly appreciate all the QoL improvements that package managers make for us.</p>
<h3 id="appendix">Appendix</h3>
<p>The difference between @executable_path and @loader_path in RPATH (Run-time search PATH) variables is illustrated as follows</p>
<ol>
<li>@executable_path:
<ul>
<li>Definition: This variable refers to the directory containing the main executable of the process.</li>
<li>Usage: It&rsquo;s primarily used when you want to specify paths relative to the main application executable.</li>
<li>Behavior: It always points to the same location, regardless of which library or plugin is currently being loaded.</li>
</ul>
</li>
<li>@loader_path:
<ul>
<li>Definition: This variable refers to the directory containing the binary (executable or library) that is currently being loaded.</li>
<li>Usage: It&rsquo;s used when you want to specify paths relative to the current library or executable being loaded.</li>
<li>Behavior: Its value can change depending on which binary is currently being processed by the dynamic loader.</li>
</ul>
</li>
</ol>
<p>@executable_path always refers to the main application executable&rsquo;s directory.
@loader_path refers to the directory of the binary currently being loaded, which could be the main executable, a library, or a plugin.</p>
<p>Example Scenario:</p>
<p>Imagine an application structure like this:</p>





<pre tabindex="0"><code>/Applications/MyApp.app/
    Contents/
        MacOS/
            MyApp (main executable)
        Frameworks/
            LibA.dylib
            LibB.dylib
        PlugIns/
            PluginC.dylib</code></pre><ul>
<li>Using @executable_path:
<ul>
<li>In MyApp: @executable_path/../Frameworks/LibA.dylib</li>
<li>This always refers to /Applications/MyApp.app/Contents/MacOS/</li>
</ul>
</li>
<li>Using @loader_path:
<ul>
<li>In MyApp: @loader_path/../Frameworks/LibA.dylib (Same as @executable_path in this case)</li>
<li>In LibA.dylib: @loader_path/LibB.dylib (Refers to /Applications/MyApp.app/Contents/Frameworks/)</li>
<li>In PluginC.dylib: @loader_path/../../Frameworks/LibA.dylib (Refers to /Applications/MyApp.app/Contents/PlugIns/)</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>A template for Self Evaluation</title>
      <link>https://gowind.github.io/post/self_evaluation/</link>
      <pubDate>Thu, 27 Jun 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/self_evaluation/</guid>
      <description>If a famous person walks up to you with a question: &amp;ldquo;Why should I hire you ?</description>
      <content:encoded><![CDATA[<p>If a famous person walks up to you with a question: <strong>&ldquo;Why should I hire you ?&rdquo;</strong></p>
<p>And you have to respond to them by filling in the following template with your
achievements</p>
<h3 id="in-the-last-3-months-i-have">In the last 3 months I have</h3>
<p>&hellip;..</p>
<p>&hellip;..</p>
<p>&hellip;..</p>
<h3 id="in-the-last-6-months-i-have">In the last 6 months I have</h3>
<p>&hellip;..</p>
<p>&hellip;..</p>
<p>&hellip;..</p>
<h3 id="in-the-last-1-year-i-have">In the last 1 year, I have</h3>
<p>&hellip;..</p>
<p>&hellip;..</p>
<p>&hellip;..</p>
<h3 id="in-the-last-5-years-i-have">In the last 5 years, I have</h3>
<p>&hellip;..</p>
<p>&hellip;..</p>
<p>&hellip;..</p>
<h3 id="what-will-your-answer-be-">What will your answer be ?</h3>
]]></content:encoded>
    </item>
    <item>
      <title>Solving Tensor Puzzles</title>
      <link>https://gowind.github.io/post/solving_tensor_puzzles/</link>
      <pubDate>Thu, 27 Jun 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/solving_tensor_puzzles/</guid>
      <description>When attempting to learn about Neural Networks, I ran into constant stumbling blocks with Pytorch, especially around Tensor broadcasting and dimension extensions.</description>
      <content:encoded><![CDATA[<p>When attempting to learn about Neural Networks, I ran into constant stumbling blocks with Pytorch, especially around
Tensor broadcasting and dimension extensions.</p>
<p>I found out about <a href="https://github.com/srush/Tensor-Puzzles">Tensor Puzzles</a>, a set of exercises to get good at manipulating tensors.
I admit, I cheated, incapable of making any progress, but reading through the solutions offered by <a href="https://www.ishan.coffee/">Ishan</a> on his blog.</p>
<p>But is it really cheating if you try to learn how it works ? ** I would say no**</p>
<p>This is my attempt to really learn the ins and outs of Tensor broadcasting and dimensions.</p>
<p>The puzzle, provides 2 functions: <code>arange</code> and <code>where</code>, and you have to build each of the fn required based on top of these 2 fns
and the fns previously implemented.</p>
<h4 id="arangei">arange(i)</h4>
<p><code>arange(i)</code> -&gt; <code>tensor([0, 1, 2, 3, 4])</code></p>
<h4 id="wherearr-v-w">where(arr, v, w)</h4>
<p><code>where([True, True, False], 1, 0)</code> -&gt; <code>tensor([1, 1, 0])</code> (when arr[i] is True, out[i] = v else out out[i] = w)</p>
<p>Lets Begin !</p>
<h4 id="ones">ones</h4>
<p>Solution: <code>where(arange(i) &gt; = 0, 1, 0)</code></p>





<pre tabindex="0"><code>pytorch
&gt;&gt;&gt; arange(5) &gt;= 0
tensor([True, True, True, True, True])</code></pre><p>The tensor operation <code>&gt;=</code> is implemented element-wise on each element in arange(5).
This ends up being true for all elements thus <code>[True,....]</code>
When we use <code>where([True,...], 1, 0)</code>, this results in a <code>tensor([1, 1,...])</code></p>
<h4 id="sum">sum</h4>
<p>Solution: <code>ones(a.shape[0]) @ a[:, None]</code></p>
<p>I am not 100% how the <code>@</code> (<strong>matmul</strong> dunder method) work.
when <code>a = tensor([1, 2, 3, 4, 5])</code>, a has a shape of (5,). <code>a[:, None]</code> adds a trailing dimension to a,
such that a now has a shape of `(5, 1)
thus a now becomes</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>tensor([[<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">2</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">3</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">4</span>]])</span></span></code></pre></div><p>multiply tensor([1, 1, 1, 1, 1]) with a now seems to result in a standard vector dot product, thus resulting in <code>tensor([10])</code></p>
<h4 id="outer">outer</h4>
<p>Solution: a[:, None] @ b[None, :]</p>
<p>given</p>





<pre tabindex="0"><code>&gt;&gt;&gt; a
tensor([0, 1, 2, 3])
&gt;&gt;&gt; b = arange(5, 9)
&gt;&gt;&gt; b
tensor([5, 6, 7, 8])</code></pre>




<pre tabindex="0"><code>&gt;&gt;&gt; a[:, None]
tensor([[0],
        [1],
        [2],
        [3]])</code></pre><p>and <code>b[None, :]</code>
extends b into</p>





<pre tabindex="0"><code>tensor([[5, 6, 7, 8]])</code></pre><p>the <code>@</code> operator multiple the row [5, 6, 7, 8] with each row of 1 element on the left
thus generating a 4x4 array:</p>





<pre tabindex="0"><code>tensor([[ 0,  0,  0,  0],
        [ 5,  6,  7,  8],
        [10, 12, 14, 16],
        [15, 18, 21, 24]])</code></pre><h4 id="diag">diag</h4>
<p>Solution: a[arange(a.shape[0]), arange(a.shape[0])]</p>
<p>The tensor subscript operator can take a list of indexes as input (not just a[i], but a[(i,j,k)])</p>





<pre tabindex="0"><code>tensor([[ 0,  0,  0,  0],
        [ 5,  6,  7,  8],
        [10, 12, 14, 16],
        [15, 18, 21, 24]])
&gt;&gt;&gt; g[(0, 1), (0, 0)]
tensor([0, 5])</code></pre><p>We use that to index in a single expression, all the elements in the diagonal. arange(i), will generate 0, 1, 2..i. By subscripting arange(i) for both row and column indices, we can fetch all the elements in the diagonal a[(0, 1, 2, 3), (0, 1, 2, 3)]</p>
<h4 id="eye">eye</h4>
<p>The Identity matrix</p>
<p>Solution: <code>where(arange(j)[:, None] == arange(j), 1, 0)</code></p>





<pre tabindex="0"><code>&gt;&gt;&gt; tensor([0]) == tensor([1, 2, 3])
tensor([False, False, False])</code></pre><p>The comparison is done for each element in the tensor
<code>arange(5)[:, None]</code> turns our vector into a column vector <code>tensor([[0], [1], [2], [3]])</code>. By comparing the <code>tensor([0, 1, 2, 3])</code> with each row in the column vector, only the indexes where the elements are equal will be set to True. We then pass this matrix of Booleans to <code>where</code> where the element is set to 1 if True, thus turning it into anidentity matrix</p>
<h4 id="triu">triu</h4>
<p>Solution: <code>where(arange(j)[:, None] &lt;= arange(j), 1, 0)</code></p>
<p>We use the same trick as in <code>eye</code> except we change the comparison from <code>==</code> <code>&lt;=</code> , so that all elements in row &lt;= row index will be True (thus 1)
The results will be</p>





<pre tabindex="0"><code>[0] &lt; = tensor([0, 1, 2, 3])`  =&gt; [True, False, False, False]
[1] &lt; = tensor([0, 1, 2, 3])`  =&gt; [True, True, False, False]
[2] &lt; = tensor([0, 1, 2, 3])`  =&gt; [True, True, True, False]</code></pre><h4 id="cumsum">cumsum</h4>
<p>a[i] = sum(a[0..i])</p>
]]></content:encoded>
    </item>
    <item>
      <title>Insights on Career in SWE</title>
      <link>https://gowind.github.io/post/insights/</link>
      <pubDate>Tue, 02 Apr 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/insights/</guid>
      <description>Come this summer, and I would have spent 9years as a professional Software Engineer. For some that is an eternity.</description>
      <content:encoded><![CDATA[<p>Come this summer, and I would have spent 9years as a professional Software Engineer. For some that is an eternity.
For many, it is still early in their career finding their feet. What do I think ? I think I have just begun.</p>
<p>My career wasn&rsquo;t the stellar, star-studded high profile work that I dream of doing as a 20 year old. Yet by the
standards of people I grew up with, I probably have had a great career so far (touchwood). I sure have had my share of blunders, wins and experience. This post is an attempt to distill some important insights I want to share</p>
<h3 id="satisfaction">Satisfaction</h3>
<p>Happiness is fleeting. Satisfaction is enduring. Vacations make you happy. A day job that you love and wake up excited about daily is satisfying. Prioritize what matters to you (and yes, you can have both, so do not try to make every decision an either or</p>
<h3 id="rat-race">Rat Race</h3>
<p>At any point in time, almost everyone around you is stuck in some sort of a race: Maxxing out careers, getting into their university of choice, buying that car you dream of, the home that feels like a dream come true, or just the satisfaction of a large bank balance. I see Rat races as checkpoints along the journey of life. Not the destination in itself, but as an indication of where you are headed to.</p>
<h3 id="luck-or-lack-thereof">Luck (or lack thereof)</h3>
<p>Success needs multiple ingredients: Talent, dedication, hardwork and luck. Extraordinary success required extroordinary amounts of luck. You control 2 ingredients on a daily basis: Dedication and Hardwork. Talent can be improved, but some are born with a gift. The rest ? All luck (fate if you want to call it that)</p>
<h3 id="ownership">Ownership</h3>
<p>The most successful I have encountered are also ones that took <a href="https://signalvnoise.com/posts/1430-hire-managers-of-one">ownership</a> of their career. The owned their effort, dedication and as a result: their careers. No one knows you well as much as you. Take ownership of yourself and your actions and most importantly: <strong>be patient</strong>.</p>
<h3 id="the-boring-bits">The boring bits</h3>
<p>Ownership isn&rsquo;t big bang responsibilities of shipping high impact software or managing a team of 100. It can be as mundane and small as keeping the docs updated, updating unit tests, keeping your team informed and leaving the code just a bit cleaner than how you found it. 1% better every day/week X 10 years and you find yourself way ahead of your peers.</p>
<h3 id="results-matter">Results matter</h3>
<p>As a junior, you are judged on effort. As a senior, on impact. Once you cross a certain effort threshold, you have to be smart and identify leverage you can apply to increase your impact. Leverage: Contacts, Coding skills, wisdom from experience, communication skills, money (the list is endless). Build leverage as you go along in your career</p>
<h3 id="find-your-tribe">Find your tribe</h3>
<p>The best way to level up is to find a team of engineers and people better than you. As the saying goes: &ldquo;Apes together strong&rdquo;. Humanity became the apex predator because we hunted as packs, not as lone wolves.</p>
<h3 id="learn-to-have-fun-on-the-way">Learn to have fun on the way</h3>
<p>A happy person is a lot easier to be around than a terminally depressed one. Everything beyond your basic needs is optional in life</p>
]]></content:encoded>
    </item>
    <item>
      <title>Array vs Normal HashMaps in Zig</title>
      <link>https://gowind.github.io/post/which_hash_map_is_faster/</link>
      <pubDate>Tue, 19 Mar 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/which_hash_map_is_faster/</guid>
      <description>So you want to use a HashMap in Zig. Its simple as new std.HashMap&amp;lt;K,V&amp;gt;() right ?</description>
      <content:encoded><![CDATA[<p>So you want to use a HashMap in Zig. Its simple as <code>new std.HashMap&lt;K,V&gt;()</code> right ?</p>
<p>Nope !</p>
<p>Turns out, since Zig gives you control over memory, it also expects you to manage memory. Which
makes HashMaps a bit tricky. Who owns the values (the Map does, duh !) , but more importantly, who owns
the keys ? And what about String keys ?</p>
<p>There is <a href="https://devlog.hexops.com/2022/zig-hashmaps-explained/">an excellent blog post</a> from hexops about the different types of hashmaps in Zig and the tradeoffs between each type.</p>
<p><strong>TL;DR</strong>: You probably want to use maps starting with <code>Auto</code>, for they also manage the memory of the keys.</p>
<p>There are 2 types of Hashmap implementation in Zig std. library
Quoted from the blog mentioned above</p>





<pre tabindex="0"><code>1. Normal HashMap 
  a. Optimized for lookup times primarily
  b. Optimized for insertion/removal times secondarily

2. ArrayHashMap  
  a. Iterating over the hashmap is an order of magnitude faster (a contiguous array)
  b. Insertion order is preserved.
  c. You can index into the underlying data like an array if you like</code></pre><p>Why would I need to use an ArrayHashMap ?</p>
<p>I have a piece of code that iteraters through the entries in a map to find a pair with the highest frequency</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#75715e">/// Return the pair with the highest frequency
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> maxFrequency(p<span style="color:#f92672">:</span> PairCounts) Pair {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> count<span style="color:#f92672">:</span> <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> std.math.minInt(<span style="color:#66d9ef">usize</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> pairPtr<span style="color:#f92672">:</span> <span style="color:#f92672">*</span>Pair <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> iterator <span style="color:#f92672">=</span> p.iterator();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (iterator.next()) <span style="color:#f92672">|</span>entry<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (entry.value_ptr.<span style="color:#f92672">*</span> <span style="color:#f92672">&gt;</span> count) {
</span></span><span style="display:flex;"><span>            count <span style="color:#f92672">=</span> entry.value_ptr.<span style="color:#f92672">*</span>;
</span></span><span style="display:flex;"><span>            pairPtr <span style="color:#f92672">=</span> entry.key_ptr;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Pair{ .p0 <span style="color:#f92672">=</span> pairPtr.p0, .p1 <span style="color:#f92672">=</span> pairPtr.p1 };
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>This frequency counting is done atleast 256 times (usually way more), so I want this to be as fast as possible.
Given that the claim is ArrayHashMaps are upto an order of magnitute faster than a normal hash map when it comes to iterating through them, do we really see such a difference ? Lets test it out !</p>
<p>I wrote a small program to insert a million entries into a map, iterate through them and sum the values</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> ArrayHashMap <span style="color:#f92672">=</span> std.AutoArrayHashMap(<span style="color:#66d9ef">u32</span>, <span style="color:#66d9ef">u32</span>); <span style="color:#75715e">// replace with AutoHashMap(u32, u32) for the non-array version
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> main() <span style="color:#f92672">!</span><span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> rndGen <span style="color:#f92672">=</span> std.rand.DefaultPrng.init(@as(<span style="color:#66d9ef">u64</span>, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> arena <span style="color:#f92672">=</span> std.heap.ArenaAllocator.init(std.heap.page_allocator);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> arena.deinit();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> allocator <span style="color:#f92672">=</span> arena.allocator();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> arrayMap <span style="color:#f92672">=</span> ArrayHashMap.init(allocator);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> i<span style="color:#f92672">:</span> <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000000</span>) { <span style="color:#75715e">// insert a million entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">try</span> arrayMap.put(@as(<span style="color:#66d9ef">u32</span>, @truncate(i)), @as(<span style="color:#66d9ef">u32</span>, @truncate(rndGen.next())));
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> iter <span style="color:#f92672">=</span> arrayMap.iterator();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> sum<span style="color:#f92672">:</span> <span style="color:#66d9ef">u128</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> start <span style="color:#f92672">=</span> std.time.nanoTimestamp();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (iter.next()) <span style="color:#f92672">|</span>entry<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> entry.value_ptr.<span style="color:#f92672">*</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> end <span style="color:#f92672">=</span> std.time.nanoTimestamp();
</span></span><span style="display:flex;"><span>    std.debug.print(<span style="color:#e6db74">&#34;ArrayHashmap Sum: {} took {} ns</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, .{ sum, end <span style="color:#f92672">-</span> start });
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>I ran the program 10 times each for Array and Normal Hash Maps on an M2Pro Macbook 16&quot;</p>





<pre tabindex="0"><code>zig build-exe -Doptimize=ReleaseFast program.zig
// ReleaseFast optimizes for producing a fast running binary </code></pre><p>The results:</p>





<pre tabindex="0"><code>Normal hashMap: 29610100 ns // 29.6 ms (average of 10 runs)
Array  hashMap: 10426500 ns // 10.4 ms (average of 10 runs)</code></pre><p><strong>CONCLUSION</strong>: The ArrayHashMap implementation is roughly 66% faster than the normal map implementation (or put in another way, the array map iteration takes 1/3rd the time it takes to iterate through the normal map). Not quite the order of magnitude I expected (maybe as the size of the map increases this might be true), but nevertheless it is significantly faster the normal hashmap for you to consider it when you need to iterate through all the keys in a HashMap</p>
]]></content:encoded>
    </item>
    <item>
      <title>Book: Systems Performance, a rather incomplete review</title>
      <link>https://gowind.github.io/post/systems_performance_review/</link>
      <pubDate>Sun, 25 Feb 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/systems_performance_review/</guid>
      <description>Brendan Gregg&amp;rsquo;s System Performance is a book that I have been meaning to read for a long time, but didn&amp;rsquo;t get around to.</description>
      <content:encoded><![CDATA[<p>Brendan Gregg&rsquo;s <a href="https://www.brendangregg.com/blog/2020-07-15/systems-performance-2nd-edition.html">System Performance</a> is a book that I have been meaning to read for a long time, but didn&rsquo;t get around to.
Thanks to my workplace&rsquo;s education policy, I get to buy and reimburse technical books, so I grabbed myself a copy</p>
<p>Its a Hyuuuuge book (some 793 pages excluding the Introduction and the Appendix) and I don&rsquo;t think I will ever write a review if I wait until I completed the entire book.</p>
<p>That said, even read a couple of chapters gave me enough intuition on what to pursue further and my two biggest takeaways
have been:</p>
<ol>
<li>USE and RED Methodologies</li>
<li>BPF (or eBPF) based tools</li>
</ol>
<h2 id="use-and-red-methodologies">USE and RED methodologies</h2>
<p>USE stands for Utilization, Saturation and Errors.
It is a methodology for investigating systematic bottlenecks in System Resources</p>
<p><strong>RESOURCE</strong> - components like CPU, RAM, Network bandwidth etc.
<strong>UTILIZATION</strong> - what % of a resource is used, over time (5-minute avg utilization of a CPU) and space (number of CPUs utilized by a program in a multi-threaded/multi-CPU system)</p>
<p>When utilization reaches 100% and more requests to utilize a resource (such as new processes or incoming packets) come in, they are queued for processing. This is a measure of extra <strong>pressure</strong> on the system and is termed <strong>SATURATION</strong></p>
<p><strong>ERRORS</strong> - The number of error events (seg faults, page faults) etc.</p>
<p>USE is a methodology for measuring how well system resources are used.</p>
<p>As a user of a system (or service ) you don&rsquo;t know (or care) about system resources, rather about how well your requests to use the system are doing. Example, if you are using AWS s3 to store data/files, then you don&rsquo;t care about how efficient s3 is in using system resources, rather you want to know how quickly your request to store and fetch data</p>
<p>In such cases, the <strong>RED methodology</strong>*  is a better way to track systematic bottlenecks
RED stands for Requests Rate, Errors and Duration.</p>
<p><strong>Request Rate</strong> - The rate at which user requests arrive
<strong>Errors</strong> - The number (or % ) of requests that result in a (non-user induced) error
<strong>Duration</strong> - The duration it takes for requests to be served (measured by 50th, 90th, 99th percentiles etc)</p>
<h2 id="bpf-ebpf-based-tools">BPF (eBPF) based tools</h2>
<p>BPF is a way for users on Linux to load programs that run within the kernel, without having to modify the kernel source codeOR load kernel modules.
While it start off with packet filter (as the name stands for Berkely Packet Filter), it soon extended to other usecases as well.
using BPF, users can attach programs to various hooks in the kernel (for example, you can run a program to track every time a read() system call was executed, or a write()). BPF programs are written in a dialect of C.
Using BPF directly can be cumbersome, so Brendan Gregg&rsquo;s <a href="https://github.com/iovisor/bcc">BCC</a> project provides some useful tools and utilities to make it easier to write, load and register BPF programs.
There is also a high-level scripting like language, <a href="https://github.com/bpftrace/bpftrace">BPFtrace</a> that can be programmed like a bash/awk script to do pretty much most of what you need as a user to track application performance without having to write programs in BPF&rsquo;s C dialect</p>
]]></content:encoded>
    </item>
    <item>
      <title>Transforming async await - I</title>
      <link>https://gowind.github.io/post/async_await_transforms_part1/</link>
      <pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/async_await_transforms_part1/</guid>
      <description>This is the first of the three part series: Part II, Part III&#xA;When compiling some Typescript code in JS for a backend service at work, I had set the target to es5 and I saw that the emitted code did not have any async/await statements.</description>
      <content:encoded><![CDATA[<p>This is the first of the three part series: <a href="/post/async_await_transforms_part2">Part II</a>, <a href="/post/async_await_transforms_part3">Part III</a></p>
<p>When compiling some Typescript code in JS for a backend service at work, I had set the <code>target</code> to <code>es5</code> and I saw that the emitted code did not have any <code>async/await</code> statements.
<code>async/await</code> was not introduced in JS until ES2017, but clearly we are able to transpile code with <code>async/await</code> into <code>es5</code> or <code>es2015</code> JS.</p>
<p>So how does <code>async/await</code> work ? Lets transpile this to <code>ES2015</code> JS and see for ourselves.</p>
<p>(I could have also chosen <code>ES5</code>, but <code>ES5</code> does not have native support for Promises and implementing Promises on ES5 would have become even more complicated, so I am sticking to ES2015 (or ES6) which has native Promises, so we only have to figure out how to implement async/await )</p>
<p>This is our code with <code>async/await</code></p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getTextOrBust</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resp</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;https://google.com&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">body</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">text</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">body</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">throw</span> Error(<span style="color:#e6db74">&#34;Cannot fetch goog&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">async</span> () =&gt; {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">getTextOrBust</span>(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">k</span>);
</span></span><span style="display:flex;"><span>})();</span></span></code></pre></div><p><code>getTextOrBust</code> makes a https call to &ldquo;google.com&rdquo; and if the response is HTTP 200, returns the body (as text) of the response. Both <code>fetch</code> and <code>.text()</code> methods return a Promise, so to use them as norma values, we need to prefix them with an <code>await</code> expression.</p>
<p><code>await</code> expressions are not allowed, unless they are inside functions marked <code>async</code>, so our <code>getTextOrBust</code> becomes an <code>async</code> function.</p>
<p>Since top-level <code>await</code>s weren&rsquo;t added until ES2022, I am simulating a top-level await by creating an IIFE (immediately invoked function expression, to run the async function in the module till completion)</p>
<p>The <a href="https://www.typescriptlang.org/play?target=2&amp;ssl=20&amp;ssc=6&amp;pln=1&amp;pc=1#code/IYZwngdgxgBAZgV2gFwJYHsIwOYFNkCCAcggLYBGuATgBQCUMA3gFAwxX4JVYAsA3MwC+zEaEixEKDFjzIAKrgAeyAPJUAQghDJ6TVjCiZt7XCAAOMALwxgAd2Cpk8fFAAWNAESvkyMyABcAPSB2Ojo2AA2uAB0hqQedAJsqHA0HObR6ADWDCxsbIYQxuToACZgbNZ2Dk7pZtHISjqJ+mwcyFxYJeVJMIIwuBEguHr5MMiuVOi2MACiVFO0HgDCwBAQ6E5wLq44YdgJvcLCIjRi0DC6lgB8ozBRTllWNvaOOPgKymqa2jQ8LQUjOgotEIuEaDkBII6PQ+EA">Typescript Playground</a> gave me output code like this</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#e6db74">&#34;use strict&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">__awaiter</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">__awaiter</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">thisArg</span>, <span style="color:#a6e22e">_arguments</span>, <span style="color:#a6e22e">P</span>, <span style="color:#a6e22e">generator</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">adopt</span>(<span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">P</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">P</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">resolve</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span>(<span style="color:#a6e22e">P</span> <span style="color:#f92672">||</span> (<span style="color:#a6e22e">P</span> <span style="color:#f92672">=</span> Promise))(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fulfilled</span>(<span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">value</span>));
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">e</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">rejected</span>(<span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">generator</span>[<span style="color:#e6db74">&#34;throw&#34;</span>](<span style="color:#a6e22e">value</span>));
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">e</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">result</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">done</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>) <span style="color:#f92672">:</span> <span style="color:#a6e22e">adopt</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">fulfilled</span>, <span style="color:#a6e22e">rejected</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">step</span>((<span style="color:#a6e22e">generator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#a6e22e">thisArg</span>, <span style="color:#a6e22e">_arguments</span> <span style="color:#f92672">||</span> [])).<span style="color:#a6e22e">next</span>());
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getANumber</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__awaiter</span>(<span style="color:#66d9ef">this</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getTextOrBust</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__awaiter</span>(<span style="color:#66d9ef">this</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resp</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;https://google.com&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">body</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">text</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">body</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> Error(<span style="color:#e6db74">&#34;Cannot fetch goog&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}(() =&gt; <span style="color:#a6e22e">__awaiter</span>(<span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">getTextOrBust</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">k</span>);
</span></span><span style="display:flex;"><span>}))();</span></span></code></pre></div><p>I re-wrote this snippet a little bit to make it easier to understand</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#e6db74">&#34;use strict&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">__awaiter</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">__awaiter</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">thisArg</span>, <span style="color:#a6e22e">_arguments</span>, <span style="color:#a6e22e">P</span>, <span style="color:#a6e22e">generator</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">adopt</span>(<span style="color:#a6e22e">value</span>) { 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">P</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">P</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>) { <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>); }); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> (<span style="color:#a6e22e">P</span> <span style="color:#f92672">||</span> (<span style="color:#a6e22e">P</span> <span style="color:#f92672">=</span> Promise))(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">genInstance</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#a6e22e">thisArg</span>, <span style="color:#a6e22e">_arguments</span> <span style="color:#f92672">||</span> []);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fulfilled</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">value</span>) =&gt; { <span style="color:#66d9ef">try</span> { 
</span></span><span style="display:flex;"><span>                      <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">genInstance</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">value</span>)); 
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) { <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">e</span>); }
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rejected</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">value</span>) =&gt; { <span style="color:#66d9ef">try</span> { <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">genInstance</span>[<span style="color:#e6db74">&#34;throw&#34;</span>](<span style="color:#a6e22e">value</span>)); } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) { <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">e</span>); } }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">result</span>) { 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">done</span>) { 
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>) 
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">adopt</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">fulfilled</span>, <span style="color:#a6e22e">rejected</span>); 
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">genInstance</span>.<span style="color:#a6e22e">next</span>());
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getTextOrBust</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__awaiter</span>(<span style="color:#66d9ef">this</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resp</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;https://google.com&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">body</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">text</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">body</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> Error(<span style="color:#e6db74">&#34;Cannot fetch goog&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>(() =&gt; <span style="color:#a6e22e">__awaiter</span>(<span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">getTextOrBust</span>(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">k</span>);
</span></span><span style="display:flex;"><span>}))();</span></span></code></pre></div><h4 id="async-function-x--becomes-__awaiterthisarg--function">async function x  becomes __awaiter(thisArg, &hellip;, function*())</h4>
<p>The first thing is to notice how our</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getTextOrBust</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resp</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;https://google.com&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">body</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">text</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">body</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">throw</span> Error(<span style="color:#e6db74">&#34;Cannot fetch goog&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>became</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getTextOrBust</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__awaiter</span>(<span style="color:#66d9ef">this</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resp</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;https://google.com&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">body</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">text</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">body</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> Error(<span style="color:#e6db74">&#34;Cannot fetch goog&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>we removed the <code>async</code> keyword and wrapped the body of our function in an <code>return __awaiter(this, void 0, void 0, function* ()</code> and replaced <code>await</code> with <code>yield</code></p>
<p>What is <code>yield</code> ? and what is this <code>function*</code>, <code>void 0</code>, ?</p>
<p>In JS, <code>void expr</code> evaluates <code>expr</code> and returns <code>undefined</code> as the value of the expression, so <code>let x = void 10</code>, evaluates <code>10</code> and returns <code>undefined</code> as the value of <code>x</code></p>
<p>What is <code>function*</code> and <code>yield</code> ? For that we must detour into a relatively obscure feature of Javascript : <strong>Generators</strong></p>
<p>Lets take a look about Generators in <a href="/post/async_await_transforms_part2/">Part II</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Transforming async await - II, Generators</title>
      <link>https://gowind.github.io/post/async_await_transforms_part2/</link>
      <pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/async_await_transforms_part2/</guid>
      <description>This is a continuation of a three part series: Part I, Part III&#xA;Generators are objects created by a Generator Function (using the syntax function*) I thought JS added them into the language spec as a case of Python envy cause Python had generators whereas JS didn&amp;rsquo;t.</description>
      <content:encoded><![CDATA[<p>This is a continuation of a three part series: <a href="/post/async_await_transforms_part1/">Part I</a>, <a href="/post/async_await_transforms_part3/">Part III</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">Generators</a> are objects created by a Generator Function (using the syntax <code>function*</code>)
I thought JS added them into the language spec as a case of Python envy cause Python had generators whereas JS didn&rsquo;t. Turns out that isn&rsquo;t quite the case and Generators have a very valid usecase in JS</p>
<p>Lets take an example of Generators</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">$</span> <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Welcome</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">Node</span>.<span style="color:#a6e22e">js</span> <span style="color:#a6e22e">v20</span>.<span style="color:#ae81ff">6.1</span>.
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Type</span> <span style="color:#e6db74">&#34;.help&#34;</span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">more</span> <span style="color:#a6e22e">information</span>.
</span></span><span style="display:flex;"><span><span style="color:#75715e">// rangeYielder is a Generator Function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">rangeYielder</span>(<span style="color:#a6e22e">n</span>) {
</span></span><span style="display:flex;"><span>... <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">n</span> ; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>...     <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">i</span>;
</span></span><span style="display:flex;"><span>...  }
</span></span><span style="display:flex;"><span>... }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">tillFive</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">rangeYielder</span>(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>Object [<span style="color:#a6e22e">Generator</span>] {} <span style="color:#75715e">// This is really a Generator Instance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">tillFive</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">done</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span> }
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">tillFive</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">done</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span> }
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">tillFive</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">done</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span> }
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">tillFive</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">done</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span> }
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">tillFive</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">done</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span> }
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">tillFive</span>.<span style="color:#a6e22e">next</span>()
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>, <span style="color:#a6e22e">done</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span> }
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span></span></span></code></pre></div><p>The Generator Function (GenFn from here on) looks like a normal function, but behaves in a different way. When we call GeneratorFunction() , it returns a generator instance, but doesn&rsquo;t run the body of the GenFn right away.</p>
<p>To do so, you must call the <code>.next()</code> method on the instance, whereupon, the body of the GenFn is run until it hits the first <code>yield</code> statement (or if there isn&rsquo;t any, it runs till completion)</p>
<p>Calling <code>next()</code> will return a value of type <code>{value: someValue, done: true/false}</code>.
<code>someValue</code> is the value returned by the <code>yield someValue</code> expression.
<code>done</code> is <code>true</code> when the body of the GenFn is run till its end. In the above example, once our loop ends, we reach the end of the fn, so in the 6th call to <code>.next()</code>, we get <code>done: true</code></p>
<p>What happens when we call <code>.next()</code> on a generator and it hits a <code>yield</code> statement. The generator pauses, and  <code>yields</code> to the caller with the value of the <code>yield</code> expression. When we call <code>.next()</code> on the generator object, the generator will resume from the statement / expression after the yield statement. In the case of</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">n</span> ; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>...     <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">i</span>;
</span></span><span style="display:flex;"><span>...  }</span></span></code></pre></div><p>when we call <code>.next()</code> , we resume the next loop iteration. Note that Generator instances store the state of their local variables (<code>i</code> in this case), so when they are resumed, they will continue as if their execution was not interrupted. When <code>i</code> equals <code>n</code>, we exit the loop and also return from the fn, thus ending the generation of values. In this case the value returned will be <code>{value: undefined, done: true}</code>. Call <code>.next()</code> on the same Generator will continue return <code>{value: undefined, done: true}</code> after the generator is done.</p>
<h2 id="generators-can-also-take-values-as-input">Generators can also take values as input</h2>
<p>Another nifty feature of generators is that they can also takes values as input when resuming a paused generator</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">valuePrinter</span>(<span style="color:#a6e22e">n</span>) {
</span></span><span style="display:flex;"><span>...   <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">input</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>...   <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`I got </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">input</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>... }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">vp</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">valuePrinter</span>(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">vp</span>.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">m</span>
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">done</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">false</span> }
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">vp</span>.<span style="color:#a6e22e">next</span>(<span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">I</span> <span style="color:#a6e22e">got</span> <span style="color:#ae81ff">17</span>
</span></span><span style="display:flex;"><span>{ <span style="color:#a6e22e">value</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">undefined</span>, <span style="color:#a6e22e">done</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span> }</span></span></code></pre></div><p>Notice the expression <code>const input = yield 5;</code>. What does this mean ?</p>
<ol>
<li>When the generator is run for the first time by calling <code>.next()</code>, return with <code>{value: 5, done: false}</code></li>
<li>When the generator is resumed using <code>.next()</code> again, we can pass <code>.next</code> a value <code>A</code>. <code>input</code> is now assigned/bound this value <code>A</code> (or it stays undefined, if we do not pass any value in <code>.next()</code>). The execution now proceeds as normal.</li>
</ol>
<p><strong>NOTE</strong>: Please run the example above and write your examples to really understand this way of yielding / resuming generators. This feature is the core aspect of making async/await work without needing <code>async/await</code> expressions.</p>
<p>This feature of generators, to be able to suspend and resume with a input is a way to do <code>co-operative threading</code>, where if a <code>thread of execution</code> knows it can potentially block on an operation (say, <code>op1</code>), it can  <code>yield</code> to a controlling thread of execution. The controlling thread of execution, once <code>op1</code> is done , can take the value of <code>op1</code> and resume the generator by calling it with <code>generator.next(valueFromOp1)</code>.</p>
<h3 id="yielding-and-resuming-with-promises">Yielding and Resuming with Promises</h3>
<p>We sometimes have operations that can potentially take an arbitrary amount of time to finish (such as <code>fetch</code> a HTTP request, reading a file , writing to a file / socket etc). How can we represent the result of such an operation without blocking on it ?</p>
<p>Javascript already answers this question using <code>Promise</code>s. A Promise is an object, that is resolved once its operation is completed. We can chain operations to be done after a Promise is <code>resolved</code> using a Promise&rsquo;s <code>.then()</code> method.</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;https://google.com&#34;</span>).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">response</span>) =&gt; {<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">ok</span>) {..}}})</span></span></code></pre></div><p>So we have a</p>
<ol>
<li>Promise: a  primitive for representing operations that might take an arbitrary amount of time</li>
<li>Generators: A primitive that can <code>yield/suspend</code> when executing an operation that takes arbitrary amounts of time.</li>
</ol>
<p>Can we put these two together to simulate async/await ?</p>
<p>Turns out, we can !</p>
<p><a href="/post/async_await_transforms_part3/">Part III</a> will explain the snippet in Part I based on our current understanding of Generators and Promises.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Transforming async await - III, Stepping the Generator</title>
      <link>https://gowind.github.io/post/async_await_transforms_part3/</link>
      <pubDate>Sun, 18 Feb 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/async_await_transforms_part3/</guid>
      <description>This is a continuation of a three part series: Part I, Part II&#xA;Let us go back to the original example:</description>
      <content:encoded><![CDATA[<p>This is a continuation of a three part series: <a href="async_await_transforms_part1.html">Part I</a>, <a href="async_await_transforms_part2.html">Part II</a></p>
<p>Let us go back to the original example:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getTextOrBust</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resp</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;https://google.com&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">body</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">text</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">body</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">throw</span> Error(<span style="color:#e6db74">&#34;Cannot fetch goog&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>This was re-written as</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getTextOrBust</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__awaiter</span>(<span style="color:#66d9ef">this</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resp</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;https://google.com&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">body</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">text</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">body</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> Error(<span style="color:#e6db74">&#34;Cannot fetch goog&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Notice how when we <code>await</code> a Promise in our original code, we now <code>yield</code> the same Promise in our transpiled code ? And that <code>async function</code>s return a <code>Promise&lt;ReturnType&gt;</code> and similarly, our Transformed function returns a Promise ?</p>
<ol>
<li>The body of our original function is transformed from a normal fn&rsquo;s body to that of a Generator Function.</li>
<li>We wrap the Generator Fn inside an <code>__awaiter</code> that knows how to resume our body after an operation it is waiting for, is complete.</li>
</ol>
<p>The first iteration of our <code>__awaiter</code> might have looked something like this:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">__awaiter</span>(..., <span style="color:#a6e22e">generatorFn</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">generator</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generatorFn</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">next</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">done</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> Promise((<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">rej</span>) =&gt; { <span style="color:#a6e22e">res</span>(<span style="color:#a6e22e">val</span>.<span style="color:#a6e22e">value</span>)})
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span> <span style="color:#a6e22e">val</span>.<span style="color:#a6e22e">value</span> <span style="color:#66d9ef">instanceof</span> Promise) {
</span></span><span style="display:flex;"><span>				Promise((<span style="color:#a6e22e">resolve</span>) =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">val</span>.<span style="color:#a6e22e">value</span>)).<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>				=&gt; <span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">v</span>))
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">val</span>.<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">v</span>) =&gt; <span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">v</span>))
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>So what are we doing here ?</p>
<ol>
<li>Run our function (Generator instance)</li>
<li>If the Generator instance runs till completion, return a Promise that resolves with the value of our generator instance.</li>
<li>Else, The Generator instance is waiting for a Promise to resolve. Chain the <code>generator.next()</code> to the Promise using <code>.then</code> so that we can resume our generator with the resolved value.</li>
</ol>
<p>Running the example:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__awaiter</span>(<span style="color:#66d9ef">this</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">void</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> () {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">resp</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;https://google.com&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">body</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">text</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">body</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> Error(<span style="color:#e6db74">&#34;Cannot fetch goog&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });</span></span></code></pre></div><ol>
<li>We run <code>function*</code> inside <code>__awaiter</code> by calling <code>.next()</code> first.</li>
<li>we reach <code>const resp = yield fetch(...)</code> . We suspend the generator instance with the return value of <code>fetch</code>: A promise.</li>
<li>We check if <code>generator.done</code> is true. It is false, as we haven&rsquo;t finished running the body of the generator instance.</li>
<li>We therefore chain our generator to resume once the <code>fetch</code> Promise resolves , with the value resolved by the fetch Promise.</li>
<li>Execution resumes at <code>const resp ...</code> . By now fetch Promise has resolved and the generator is resume with the value of this Promise, so resp will contain the actual response object.</li>
<li>We then proceed till we hit the next <code>yield</code> or return statement.</li>
</ol>
<h3 id="what-happens-when-we-await-multiple-times-in-our-async-fn-">What happens when we await multiple times in our async fn ?</h3>
<p>Note that in the <code>__awaiter</code> implementation above , we resume  <code>Promise.then((v) =&gt; { generator.next(v)}))</code> only once, but our Generator Function can have any number of yield expressions in the body. How do we ensure that we handle an arbitrarily large body with multiple <code>yield</code> statements ? (Notice that both fetch and response.text() return Promises, so we need to suspend and resume our generators twice)</p>
<p>We do that by being a bit clever</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">__awaiter</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">__awaiter</span>) <span style="color:#f92672">||</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">thisArg</span>, <span style="color:#a6e22e">_arguments</span>, <span style="color:#a6e22e">P</span>, <span style="color:#a6e22e">generator</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if value is not a Promise, then return a Promise that resolves with value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// else return value as it is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">adopt</span>(<span style="color:#a6e22e">value</span>) { 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">P</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">P</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>) { <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">value</span>); }); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// turns the return value of any fn passed into a Promise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> (<span style="color:#a6e22e">P</span> <span style="color:#f92672">||</span> (<span style="color:#a6e22e">P</span> <span style="color:#f92672">=</span> Promise))(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// create a Generator Instance out of our given fn body 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">genInstance</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#a6e22e">thisArg</span>, <span style="color:#a6e22e">_arguments</span> <span style="color:#f92672">||</span> []);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fulfilled</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">value</span>) =&gt; { <span style="color:#66d9ef">try</span> { 
</span></span><span style="display:flex;"><span>                      <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">genInstance</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">value</span>)); 
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) { <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">e</span>); }
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rejected</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">value</span>) =&gt; { <span style="color:#66d9ef">try</span> { <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">genInstance</span>[<span style="color:#e6db74">&#34;throw&#34;</span>](<span style="color:#a6e22e">value</span>)); } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) { <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">e</span>); } }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">result</span>) { 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">done</span>) { 
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>) 
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">adopt</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">fulfilled</span>, <span style="color:#a6e22e">rejected</span>); 
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">genInstance</span>.<span style="color:#a6e22e">next</span>());
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div><p>Lets start with top level statements that will be executed :</p>
<ol>
<li><code>return new ((P || (P = Promise))(function (resolve, reject)..</code> runs first</li>
<li>It first creates a <code>const genInstance</code> Generator Instance</li>
<li>Then <code>step(genInstance.next())</code> is executed</li>
<li><code>step(result)</code> checks if our generator instance is <code>done</code>. If there are no <code>await</code> statements in the original code (which are replaced with <code>yield</code> in the transpiled code), it runs to completion , thus setting <code>done</code> to true. <code>step</code> then resolves the Promise from 1. with the value of our generator instance</li>
<li>if <code>result.done</code> is false, it means we probably hit a <code>yield/await</code> statement that needs a Promise to resolve. since <code>yield fetch(..)</code> will return a Promise, <code>result.value</code> is a Promise. <code>adopt(result.value).then(fulfilled, rejected);</code> chains our generator to resume after the Promise is resolved.</li>
</ol>
<p>The lines we have to pay attention to most is <code>const fulfilled = (value) {...}</code> and in the <code>else</code> clause in the function <code>step</code></p>
<p>When a promise returned by <code>yield fetch</code> or <code>yield resp.text()</code> is <code>adopt</code>ed , we need to <code>step</code> the generator, not just do <code>generator.next()</code>. The function <code>step</code> is rightly named so, as it steps an execution of the generator and if the generator isn&rsquo;t done, sets itself up recursively to be called again and again till the generator is completed.</p>
<p>This recursive stepping is captured in the function <code>fulfilled</code>:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fulfilled</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">value</span>) =&gt; {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">genInstance</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">value</span>)); <span style="color:#75715e">// recursive step
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">e</span>);  <span style="color:#75715e">// reject our top level Promise if we encounter errors during
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			        <span style="color:#75715e">// execution
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">result</span>) { 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">done</span>) { 
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>) 
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">// fulfiled will call step again, thus stepping until at some point
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#75715e">// result.done is true, thus breaking the recursion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#a6e22e">adopt</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">fulfilled</span>, <span style="color:#a6e22e">rejected</span>); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>If we remove all the noise in our <code>__awaiter</code>, keeping the above recursion in mind, we can see essentially the gist of how an <code>async function</code> with <code>await</code> statements can be transformed into a generator that we step through until it is done, <code>yield</code> at every Promise (await) and resuming once the Promise is resolved :</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">__awaiter</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">thisArg</span>, <span style="color:#a6e22e">_arguments</span>, <span style="color:#a6e22e">P</span>, <span style="color:#a6e22e">generator</span>) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// turns the return value of any fn passed into a Promise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> (<span style="color:#a6e22e">P</span> <span style="color:#f92672">||</span> (<span style="color:#a6e22e">P</span> <span style="color:#f92672">=</span> Promise))(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// create a Generator Instance out of our given fn body 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">genInstance</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">generator</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#a6e22e">thisArg</span>, <span style="color:#a6e22e">_arguments</span> <span style="color:#f92672">||</span> []);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// function step(result){ if(result.done) { resolve(result.value)} else {...}}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">step</span>(<span style="color:#a6e22e">genInstance</span>.<span style="color:#a6e22e">next</span>());
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div><h3 id="conclusion">Conclusion</h3>
<p>async/await in Javascript can be implemented using Generators. For a long time I wondered how it was done, but turns out the transpiled code is surprisingly understandable. The only tricky part is to grok how the recursive stepping is setup, using <code>step</code> and <code>fulfilled</code> (which in return calls step).
The best way to grok this is by running the <a href="https://github.com/GoWind/algorithms/blob/master/fetch_transformer.js">snippet</a> under a Debugger and setting a breakpoint in the <code>fulfilled</code> and <code>step</code> fns. The best way to understand a piece of code is to simulate it step by step and inspect the results, just like the await transformer does !</p>
]]></content:encoded>
    </item>
    <item>
      <title>From 500 secs to 3.5 - The 1brc Challenge</title>
      <link>https://gowind.github.io/post/1brc/</link>
      <pubDate>Sat, 20 Jan 2024 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/1brc/</guid>
      <description>All measurements run on an M2Pro Macbook 16&amp;quot; with 32GB RAM.&#xA;For those of you that aren&amp;rsquo;t aware of the 1brc challenge, the goal is to parse 1 billion rows in a plain text file, each row mapping a city to the temperature observed on a particular day and computing the min,max,average and total temperatures of each city.</description>
      <content:encoded><![CDATA[<p>All measurements run on an M2Pro Macbook 16&quot; with 32GB RAM.</p>
<p>For those of you that aren&rsquo;t aware of the <a href="">1brc</a> challenge, the goal is to parse 1 billion rows in a plain text file, each row mapping a city to the temperature observed on a particular day and computing the min,max,average and total temperatures of each city.
The output has to be alphabetically sorted based on the name of the city.</p>
<p>The title is a little clickbait-y, because I knew that my initial solution was going to be slow, but yet I still ran it for the sake of it.</p>
<h2 id="if-it-works-it-aint-stupid">If it works, it ain&rsquo;t stupid</h2>
<p>My first solution was to write a dumb shell script. Too lazy, I asked chatGPT to generate an <code>awk</code> script for me to do it and then I ran it on my local machine.</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat average.sh
</span></span><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Input file path</span>
</span></span><span style="display:flex;"><span>input_file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;measurements.txt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Check if the file exists</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -f <span style="color:#e6db74">&#34;</span>$input_file<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Error: File not found: </span>$input_file<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use awk to calculate average temperature per city</span>
</span></span><span style="display:flex;"><span>awk -F<span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#e6db74">&#39;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    city = $1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    temperature = $2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sum[city] += temperature
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    count[city]++
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">END {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    for (city in sum) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        average = sum[city] / count[city]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf &#34;City: %s, Average Temperature: %.2f\n&#34;, city, average
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}&#39;</span> <span style="color:#e6db74">&#34;</span>$input_file<span style="color:#e6db74">&#34;</span></span></span></code></pre></div><p>The result ? 487 secs for a single run.</p>
<p>That shell scripts are slow is a known thing. What next ? I didn&rsquo;t want to spend too much time on it, so I wrote a similar script in Javascript with a single thread (I lost the code for it, but it isn&rsquo;t too hard to write). The script didn&rsquo;t do much faster, running at about 460ish seconds (even V8 can only do so much I guess).</p>
<h2 id="going-brrr">Going brrr</h2>
<p>How do I make this faster ? This problem is trivially parallelizable. Since each line is a separate entry, we can split the giant file to be worked on by different <code>worker</code> threads and then merge the results of all the <code>worker</code> threads together in the main thread. The tricky bit is how do we split the file ?</p>
<p>We can use the <a href="https://linux.die.net/man/2/stat">stat</a> api to find the size of a file without having to read the entire file.
Once we know the size of the file, we can split it into chunks , where chunk size = <code>sizeof(file)/num_threads</code>. Each thread will read the lines present between bytes : [ <code>thread_index * chunk_size</code> &hellip; <code>(thread_index + 1) * chunk_size</code>] and in a thread local HashMap, map each city =&gt; number of times we saw an entry for the city , the min , max temperatures and the total sum of all the temperatures we have seen.
Once the threads sum up their chunk of the file, we then merge the results of these local HashMap into a global HashMap to calculate each city&rsquo;s min, max and avg. temperatures.</p>
<p>The file is made of lines like <code>Vienna;19.1\nPhoenix;16.1\n</code>. The <code>\n</code> at the end and the <code>V</code> at the beginning might not align exactly for all the chunks of our threads. What do we do in that case ?</p>
<p>Before a thread begins to process a chunk, we need to adjust its start and end offsets such that the start offset starts at a character right after a <code>\n</code> (thus a new entry) and adjust the end character so that it aligns with a <code>\n</code> .</p>
<p>Here is how I did it in my code</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">startOffset</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">buf</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">readHundred</span>(<span style="color:#a6e22e">handle</span>, <span style="color:#a6e22e">startOffset</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">buf</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>) {
</span></span><span style="display:flex;"><span> } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nextPos</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nextNewLine</span>(<span style="color:#a6e22e">buf</span>, <span style="color:#e6db74">&#34;start&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">startOffset</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nextPos</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">startOffset</span>;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">readHundred</span>(<span style="color:#a6e22e">handle</span>, <span style="color:#a6e22e">pos</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Buffer</span>.<span style="color:#a6e22e">alloc</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">results</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">b</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>, <span style="color:#a6e22e">pos</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">results</span>.<span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">results</span>.<span style="color:#a6e22e">bytesRead</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>I took the liberty that each line is less than a 100 chars long, so that we can always find the <code>\n</code> by just reading 100 chars past the start offset.</p>
<p>Similarly for the end offset</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">endOffset</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">totalSize</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">buf</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">readHundred</span>(<span style="color:#a6e22e">handle</span>, <span style="color:#a6e22e">endOffset</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">buf</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">buf</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;\x00&#34;</span>) {
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nn</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nextNewLine</span>(<span style="color:#a6e22e">buf</span>, <span style="color:#e6db74">&#34;end&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">endOffset</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nn</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">endOffset</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">nextNewLine</span>(<span style="color:#a6e22e">buffer</span>, <span style="color:#a6e22e">ev</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">j</span>.<span style="color:#a6e22e">length</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">j</span>[<span style="color:#a6e22e">x</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Once the thread finds the start and the end offsets for each chunk,it creates a stream between the 2 offsets and iterates through them line by line :</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">readStream</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">createReadStream</span>({<span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">startOffset</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">endOffset</span>});
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rl</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">readline</span>.<span style="color:#a6e22e">createInterface</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">input</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">readStream</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">crlfDelay</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">Infinity</span> <span style="color:#75715e">// To handle Windows line endings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rl</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;line&#39;</span>, (<span style="color:#a6e22e">row</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">processRow</span>(<span style="color:#a6e22e">row</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rl</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;close&#39;</span>, () =&gt; {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">wrapUp</span>();
</span></span><span style="display:flex;"><span>});</span></span></code></pre></div><p>You can find this version of code in <a href="https://github.com/GoWind/1brc/commit/7a64018720365608c5ba8fcb080c63f61cb54f2e">this</a> commit. Running this code with 12 threads (8 E cores and 4 P cores on my M2 Pro machine), I got it run at about 48 secs on avg.</p>
<p>Readline is a rather slow way to iterate over a chunk of data because it reads a chunk of text line by line. When looping over a ReadStream, we can loop over Text Chunks rather than lines and this might be faster (you can find this version of my solution in <a href="https://github.com/GoWind/1brc/commit/3d3be7fd1c51d9304b3cce34bde4d29818db565b">this</a>commit)</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">-const rl = readline.createInterface({
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    input: readStream,
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    crlfDelay: Infinity // To handle Windows line endings
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  });
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-rl.on(&#39;line&#39;, (row) =&gt; {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  processRow(row);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+for await (const chunk of readStream) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    let res = await handler(chunk);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    if(res == false) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      break;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+}
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-rl.on(&#39;close&#39;, () =&gt; {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">- wrapUp();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+async function handler(chunk) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  let updatedChunk = globalBuffer.concat(chunk);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  let rows = updatedChunk.split(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  if(rows.length) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+     if(rows[rows.length-1] == &#34;&#34;) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+        globalBuffer = &#34;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+        processRows(rows.slice(0, -1));
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+     } else {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+       globalBuffer = rows[rows.length-1];
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+       processRows(rows.slice(0, -1));
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+     }
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+}
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+wrapUp();
</span></span></span></code></pre></div><p>Using chunking as opposed to ReadLine improved the solution by roughly 20%. I was able to get the solution to run on an avg. of 40secs.</p>
<h3 id="faster-">Faster ?</h3>
<p>I was running out of ideas to improve the speed in JS, so time to bring out the BFG 9000: Zig.
As a statically-typed, compiled language, we should be able to (hopefully) run much faster in Zig.
I used the same approach to build a multi-threaded Zig program, using the same offset calculation with threads swapping the JS for Zig.</p>
<h4 id="timing-">Timing ?</h4>
<p>6.7 secs !</p>
<p>I initially got a shock, because I was doing a Debug build and the Debug build ran with an average of 56secs. For a few moments, I was questioning my life decisions and existence in a world where JS was faster than Zig. Running <code>zig build</code> with the <code>Doptimize=ReleaseFast</code> flag turned on optimizations that literally 8xed the speed of my <a href="https://github.com/GoWind/1brc/commit/7760c6dda6930ff4464cc2cc049bf35988960441">solution</a></p>
<p>I was happy, but by this point, the Java peeps had made the Java solution complete in under 6 secs. Can I beat that ?</p>
<h3 id="moaaar-power">Moaaar power</h3>
<p>I wanted to do a couple of tweaks before calling it quits. These tweaks were stuff I found in Danny Van Kooten&rsquo;s <a href="https://github.com/dannyvankooten/1brc/blob/main/analyze.c">solution</a> in C.</p>
<ol>
<li>Use <code>mmap</code> to map the file into the virtual memory, instead of trying to read chunks of the file in each thread to find the start and the end offsets</li>
<li>A faster hashMap implementation</li>
<li>not trying to parse the temperatures as floats</li>
</ol>
<p><a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a> takes the contents of a file and maps it into the virtual memory of a process. This makes reading the file as simple as updating a pointer , while the Filesystem + OS takes care of swapping in and out the parts of the files currently being read. We are not updating the mapping/file, only reading it , so <code>mmap</code>ing the file turned out to be a simple choice</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">-    const file = try std.fs.openFileAbsoluteZ(filepath, .{});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    defer file.close();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const stat = try file.stat();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    std.debug.print(&#34;file size is {}\n&#34;, .{stat.size});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+    const fd = try std.os.open(filepath, std.os.O.RDONLY, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    defer std.os.close(fd);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    const stat = try std.os.fstat(fd);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    const mapping = try std.os.mmap(null, @as(u64, @intCast(stat.size)), std.os.PROT.READ, std.os.MAP.PRIVATE, fd, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    defer std.os.munmap(mapping);
</span></span></span></code></pre></div>




<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#75715e">@@ -43,146 +44,60 @@ fn calculate(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     idx: usize,
</span></span><span style="display:flex;"><span>     workerSize: u64,
</span></span><span style="display:flex;"><span>     allocator: std.mem.Allocator,
</span></span><span style="display:flex;"><span><span style="color:#f92672">-    filepath: [*:0]u8,
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+    file: []u8,
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span> ) !void {
</span></span><span style="display:flex;"><span><span style="color:#f92672">-    var buffer = [_]u8{&#39;a&#39;} ** 80000;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const waterMarkSize: usize = 80000;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const slice = buffer[0..100];
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const View = struct { slice: []u8, len: usize };
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const file = try std.fs.openFileAbsoluteZ(filepath, .{});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const stat = try file.stat();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    defer file.close();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+    const finalEndOffset = file.len - 1;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>     var startOffset = idx * workerSize;
</span></span><span style="display:flex;"><span>     var endOffset = (idx + 1) * workerSize - 1;
</span></span><span style="display:flex;"><span>     if (startOffset &gt; 0) {
</span></span><span style="display:flex;"><span>         const prev = startOffset - 1;
</span></span><span style="display:flex;"><span><span style="color:#f92672">-        try file.seekTo(prev);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-        const read = try file.readAll(slice);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-        if (read == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            @panic(&#34;failed to read from starting offset&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-        }
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-        if (buffer[0] != &#39;\n&#39;) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            var i: usize = 1;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            while (i &lt; read) : (i += 1) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                if (buffer[i] == &#39;\n&#39;) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                    startOffset += i;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                    break;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                }
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+        if (file[prev] != &#39;\n&#39;) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            while (file[startOffset] != &#39;\n&#39;) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                startOffset += 1;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>             }
</span></span><span style="display:flex;"><span><span style="color:#f92672">-        }
</span></span></span></code></pre></div><p>I didn&rsquo;t record the timings for [this] change alone, but my measurements varied anywhere from ~5.5-9secs (probably depending on filesystem caches in memory being cold/warm)</p>
<p>The next trick I attempted to use was to parse each temperature as an <code>i32</code> and not as a <code>f32</code>. Float parsing is tricky, and slower than parsing integers. Since each temperature entry in the challenge has only one digit after the decimal point, we can parse <code>16.1</code> as <code>161</code> and divide the final result only by <code>10</code>, thus saving a lot of time spent parsing</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">-pub const Record = struct { min: f32 = 0, max: f32 = 0, total: f32 = 0, count: u32 = 0 };
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+const SliceList = std.ArrayList([]const u8);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+const writer = std.io.getStdOut().writer();
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+pub const Record = struct { min: i32 = 0, max: i32 = 0, total: i32 = 0, count: u32 = 0 };
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>...
</span></span><span style="display:flex;"><span><span style="color:#f92672">-            const temp = try std.fmt.parseFloat(f32, num);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+            const temp = parsei32(num);
</span></span></span></code></pre></div><p>(Again, I did not record the timings for this change <a href="https://github.com/GoWind/1brc/commit/23fafbfebbb82bafcd9433e1230f89a6c6cdf52a">this</a> change alone)</p>
<p>The last trick I wanted to try was using a custom Hash function / HashMap for tracking city -&gt; temperature stats. From profiling my application with flamegraphs, it was clear that most of the time was spent in looking up a city&rsquo;s existing entry in the threadlocal HashMap. Since our keys are strings, we can use a simple hash function to hash the city names. A simple function that is easy to compute is <a href="https://t.co/C2ZfSSiYSW">djb2</a>. I decided to use this as my hash fn</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">hashSlice</span>(<span style="color:#a6e22e">data</span><span style="color:#f92672">:</span> []<span style="color:#a6e22e">u8</span>, <span style="color:#a6e22e">totalSize</span>: <span style="color:#66d9ef">usize</span>) <span style="color:#a6e22e">usize</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">k</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">hash</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">k</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">len</span>) <span style="color:#f92672">:</span> (<span style="color:#a6e22e">k</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">hash</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">hash</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">31</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">k</span>]) <span style="color:#f92672">&amp;</span> (<span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hash</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>As for a HashMap, is there a faster way ? We know that there aren&rsquo;t a lot of cities in the entry, so we probably can get away with replacing the thread local HashMap with an array instead (actually 2 arrays)</p>
<ol>
<li>We create a threadlocal array with 2^16 entries and fill each of them with a <code>0</code>.</li>
<li>We create another array: <code>entries</code>, with index <code>i</code> starting at 0. Each new string is provided a new index in this array. The values of entries are all set to a sentinel value.</li>
<li>We hash each string and then perform a module of that hash with (2^16-1) thus getting a number N between [0, 2^16-1].</li>
<li>We then start at array[N] and proceed with N = (N+ 1) % 2^16-1 , till array[N] == Sentinel Value or array[N] == N.</li>
<li>if entries[N] is a Sentinel Value, it means we have not encountered string S yet. We create a Record for this city at <code>entries[N]</code> and set Array[N] = N</li>
<li>Else, it means we already have a valid entry for the city S. We then simply update the count and the min,max and average of the City at entries[N]</li>
</ol>
<p>It is probably much simpler to understand the code:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#a6e22e">+    var hashList = try NumList.initCapacity(allocator, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    var indexList = try NumList.initCapacity(allocator, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    hashList.appendNTimesAssumeCapacity(0, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    indexList.appendNTimesAssumeCapacity(1 &lt;&lt; 16, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>// 1 &lt;&lt; 16 is the sentinel value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            const maybeEntry = threadMap[idx].getEntry(city);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            if (maybeEntry) |entry| {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                entry.value_ptr.*.count += 1;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                entry.value_ptr.*.total += temp;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                entry.value_ptr.*.max = @max(entry.value_ptr.*.max, temp);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                entry.value_ptr.*.min = @min(entry.value_ptr.*.min, temp);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+            var hashVal = hashSlice(city, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            while (hashList.items[hashVal] != hashVal and hashList.items[hashVal] != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                hashVal = (hashVal + 1) &amp; (maxSize - 1);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            }
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            const entryIdx = indexList.items[hashVal];
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            if (entryIdx == 1 &lt;&lt; 16) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                const cityNameForRec = try allocator.alloc(u8, city.len);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                @memcpy(cityNameForRec, city);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                const rec = Record{ .city = cityNameForRec, .count = 1, .min = temp, .max = tem
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>p, .total = temp };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                try threadMap[idx].append(rec);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                indexList.items[hashVal] = threadMap[idx].items.len - 1;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                hashList.items[hashVal] = hashVal;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>             } else {
</span></span><span style="display:flex;"><span><span style="color:#f92672">-                const rec = Record{ .count = 1, .min = temp, .max = temp, .total = temp };
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                const k = try allocator.alloc(u8, city.len);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                @memcpy(k, city);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                try threadMap[idx].put(k, rec);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+                threadMap[idx].items[entryIdx].count += 1;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                threadMap[idx].items[entryIdx].total += temp;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                threadMap[idx].items[entryIdx].max = @max(threadMap[idx].items[entryIdx].max, t
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>emp);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                threadMap[idx].items[entryIdx].min = @min(threadMap[idx].items[entryIdx].min, t
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>emp);
</span></span><span style="display:flex;"><span>             }
</span></span></code></pre></div><p>We replaced the zig HashMap with our custom one. So how did the end result go ?</p>
<h4 id="answer-faaast-">Answer: Faaast !</h4>
<p>The <a href="https://github.com/GoWind/1brc/commit/dfc37a92b5fcb835dc994e48ef54eab060fd03bb?diff=unified&amp;w=1">updated</a>solution hit ~3.5 secs on the average. This was almost 2x faster than our previous solution ! I was elated that such simple optimizations could make such a big difference.</p>
<p>I wanted to proceed with more optimizations to make the solution go even faster, but unfortunately I no longer had the time to pursue the project , and having hit the deadline I set for myself, was happy to have come so far. Also given that my daily driver is a Mac, it was very hard to generate flamegraphs for Zig programs and trying to optimize programs without them is like trying to navigate a race course blind. In the end, I decided to wrap up the experiments and call it a day</p>
<h2 id="takeaways">Takeaways</h2>
<p>Zig is faaaast ! More than that, it makes doing things that could be done by C (mmap, allocations) etc so much simpler. The only language wart that I still hate is that I never know when it copies a data structure vs when it doesn&rsquo;t , so I ended up spending a lot of time debugging subtle bugs.</p>
<p>For example, take this update in a fn that runs in a worker thread</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">TempMap</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">std</span>.<span style="color:#a6e22e">StringHashMap</span>(<span style="color:#a6e22e">Record</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">threadMap</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">numWorkers</span>]<span style="color:#a6e22e">RecordList</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">threads</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">numWorkers</span>]<span style="color:#a6e22e">std</span>.<span style="color:#a6e22e">Thread</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">NumList</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">std</span>.<span style="color:#a6e22e">ArrayList</span>(<span style="color:#a6e22e">usize</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">maxSize</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">14</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pub</span> <span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">main</span>() <span style="color:#f92672">!</span><span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">calculate</span>(...) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">total</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">temp</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">max</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">@max</span>(<span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">max</span>, <span style="color:#a6e22e">temp</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">min</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">@min</span>(<span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">min</span>, <span style="color:#a6e22e">temp</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>In fn <code>calculate</code>, I had done</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">total</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">temp</span>;</span></span></code></pre></div><p>What happened was, this created a new copy of <code>threadMap[idx]</code> for each thread  in the fn calculate and the updates were going into this copy <code>t</code> , rather than at <code>threadMap[idx]</code>. As a result, after my threads finished running, when attempting to merge all the entries from each thread&rsquo;s threadMap, I was running into empty maps, because none of the entries added to <code>t</code> were actually added to <code>threadMap[idx]</code>. The fix was simple, but the lack of docs or syntax about move semantics or copy constructors makes it sometimes a frustrating experience.</p>
<p>In the end though, the ability of Zig to provide the speed of C with a far better syntax and APIs make these frustrations vanish. Happy Hacking !</p>
]]></content:encoded>
    </item>
    <item>
      <title>Module, ModuleResolution and Target in NodeJS</title>
      <link>https://gowind.github.io/post/typescript_module_resolution_and_target/</link>
      <pubDate>Tue, 12 Dec 2023 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/typescript_module_resolution_and_target/</guid>
      <description>I did (A LOT) of reading and testing out various config options in my local machine to understand how module,moduleResolution and target configurations in tsconfig.</description>
      <content:encoded><![CDATA[<p>I did (<strong>A LOT</strong>) of reading and testing out various config options in my local machine to understand how <code>module</code>,<code>moduleResolution</code> and <code>target</code> configurations in <code>tsconfig.json</code> work.</p>
<p>First let us setup some terminology and explanations to understand the terms involved:</p>
<p><a href="https://www.typescriptlang.org/docs/handbook/modules/theory.html#who-is-the-host">A host</a></p>
<p>Simplest point to understand: Typescript is <strong>NOT</strong> a host</p>
<p>A host is the runtime where JS executes (NodeJS, browser) or a bundler that transforms the output of typescript</p>
<p><a href="https://www.typescriptlang.org/docs/handbook/modules/theory.html#the-module-output-format">Module output format</a>:</p>
<p>In any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match.</p>
<p>The <code>module</code> compiler option provides this information to the compiler. Its primary purpose is to control the module format of any JavaScript that gets emitted during compilation</p>
<p><a href="https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution">Module Resolution</a></p>
<p>ECMAScript specification defines how to parse and interpret <code>import</code> and <code>export</code> statements.</p>
<p>But it doesn&rsquo;t specify the actual algorithm of how an import specifier (&quot;./path/to/module&quot; or &ldquo;node-fetch&rdquo;, &ldquo;semver&rdquo;) is resolved into a module</p>
<p>This also clarifies why TypeScript doesn’t modify import specifiers during emit: the relationship between an import specifier and a file on disk (if one even exists) is host-defined, and TypeScript is not a host.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#module-name">Module Specifier</a></p>
<p>The module to import from (example: &ldquo;node-fetch&rdquo; or something relative like &ldquo;./../shared&rdquo; or &ldquo;./../shared/logger.js&rdquo;)</p>
<p>I tested a project with both local and non-local import specifiers. The most important config option was the <code>type</code> option <code>package.json</code>, which changes how NodeJS interprets the module type (ESM vs Common JS ) of <code>.js</code> files. I have written a summary of how my <code>tsc</code> step works with the given config values for <code>module</code>, <code>moduleResolution</code> and <code>target</code></p>
<p>Node Version used : <code>20.6.1</code> (on macOS)</p>
<h4 id="no-type-module-in-packagejson">No <code>type</code>: <code>module</code> in <code>package.json</code></h4>
<p><code>.cjs</code> files are considered CommonJS modules.
<code>.mjs</code> files are considered ESM modules.
<code>.js</code> files are considered CommonJS modules.</p>
<table>
<thead>
<tr>
<th>target</th>
<th>module</th>
<th>moduleResolution</th>
<th>result of <code>tsc</code></th>
<th>output format</th>
</tr>
</thead>
<tbody>
<tr>
<td>es2022</td>
<td>None</td>
<td>None</td>
<td>Error: cant resolve modules</td>
<td></td>
</tr>
<tr>
<td>es2022</td>
<td>nodenext</td>
<td>nodenext</td>
<td>works[1]</td>
<td>commonjs modules</td>
</tr>
<tr>
<td>es2022</td>
<td>commonjs</td>
<td>None</td>
<td>works[2]</td>
<td>common js modules</td>
</tr>
<tr>
<td>es2022</td>
<td>es2022</td>
<td>Nonde</td>
<td>doesn&rsquo;t work (can&rsquo;t resolve modules in node_modules)</td>
<td></td>
</tr>
<tr>
<td>es2022</td>
<td>es2022</td>
<td>node16</td>
<td>doesn&rsquo;t work (moduleResultion must match module)</td>
<td></td>
</tr>
</tbody>
</table>
<p>[2] works only if <code>esModuleInterop</code> is also set to <code>True</code>, otherwise runs into problems</p>
<p>both [1] and [2]  can use <code>await</code> syntax
both [1] and [2] have CommonJs module syntax in the emitted code:</p>





<pre tabindex="0"><code>var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { &#34;default&#34;: mod };
};
....
....
....
exports.default = fetchInformation</code></pre><h4 id="with-type-module-in-packagejson">With <code>type</code>: <code>module</code> in package.json</h4>
<p>all relative import specifiers (example: <code>import { logger } from &quot;./../shared/lib/logger-wrapper.js&quot;;</code>) MUST always  have the suffix (<code>.js</code> <code>.mjs</code>) present in the import specifier, else Node will refuse to import the module.</p>
<table>
<thead>
<tr>
<th>target</th>
<th>module</th>
<th>moduleResolution</th>
<th>result of <code>tsc</code></th>
<th>output format</th>
</tr>
</thead>
<tbody>
<tr>
<td>es2022</td>
<td>None</td>
<td>None</td>
<td>Error: can&rsquo;t resolve modules</td>
<td></td>
</tr>
<tr>
<td>es2022</td>
<td>nodenext</td>
<td>nodenext</td>
<td>doesn&rsquo;t work</td>
<td></td>
</tr>
<tr>
<td>es2022</td>
<td>commonjs</td>
<td>None</td>
<td>compiles but fails at runtime[2]</td>
<td>common js modules</td>
</tr>
<tr>
<td>es2022</td>
<td>es2022</td>
<td>None</td>
<td>doesn&rsquo;t work (can&rsquo;t resolve modules in node_modules)</td>
<td></td>
</tr>
<tr>
<td>es2022</td>
<td>es2022</td>
<td>node16</td>
<td>doesn&rsquo;t work (moduleResultion must match module)</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>.cjs</code> files are considered common js modules.
<code>.mjs</code> files are considered esm modules
<code>.js</code> files are considered esm modules.</p>
<p>[2] tsc compiles successfully but code fails at runtime when running use <code>node /path/file.js</code>
with the following error message:</p>





<pre tabindex="0"><code>ReferenceError: exports is not defined in ES module scope
This file is being treated as an ES module because it has a &#39;.js&#39; file extension and &#39;/path/to/package.json&#39; contains &#34;type&#34;: &#34;module&#34;. To treat it as a CommonJS script, rename it to use the &#39;.cjs&#39; file extension.</code></pre><p>To use Typescript code with <code>type: module</code>, you can specify the import specifier for a relative module, say, <code>./../shared/lib/logger-wrapper.ts</code>  as <code>./../shared/lib/logger-wrapper.js</code>. <code>tsc</code> seems to pick it up compile successfully</p>
<p>Also, In Typescript, module specifiers such as the <code>./myfile.js</code> in <code>import {a} from &quot;./myfile.js&quot;</code> are <a href="https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-specifiers-are-not-transformed">never</a> transformed ! This means that your transpiled code with the <code>.js</code> suffix in the import specifier should work on a NodeJS runtime correctly.</p>
<p>The Reason why this is so, is simple: The resolution of module specifier is <code>host</code> specific (host: browser, Node runtimer, bundler etc). Since TS is not a host, it leaves the import statement untouched (IMO, so much pain could have been avoided if TS could do this)</p>
]]></content:encoded>
    </item>
    <item>
      <title>Node JS internals - How async file system calls work</title>
      <link>https://gowind.github.io/post/node_js_async_internals/</link>
      <pubDate>Sun, 29 Oct 2023 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/node_js_async_internals/</guid>
      <description>Note: The internal details of NodeJs (parts that are not exposed as an API) will always be subject to change.</description>
      <content:encoded><![CDATA[<h3 id="note-the-internal-details-of-nodejs-parts-that-are-not-exposed-as-an-api-will-always-be-subject-to-change">Note: The internal details of NodeJs (parts that are not exposed as an API) will always be subject to change.</h3>
<p>This post was written based on the Node JS source code at commit <a href="https://github.com/nodejs/node/blob/f0995d14768b36c3cbb2d75d57b0ff92b254b334/src/node_file-inl.h#L307">f09a50c39d92efd5ed65a87fb07f64675baa8774</a>. The info in this post might become
obsolete if and when Node JS internals change (althought that might be rare, but nevertheless still possible)</p>
<p>As discussed in our <a href="https://github.com/GoWind/GoWind.github.io/blob/master/libuv_primer.md">lib_uv primer</a> , we know how we can execute a fn (<code>work</code>) to be run in a worker on libuv&rsquo;s threadpool and then have a callback fn execute on the main thread, once <code>work</code> is executed on a worker thread)</p>
<p>The fn <code>uv_fs_open</code> is used to open a file without blocking the main/event thread (as <code>open</code> in most UNIXes is a blocking call). It does so by submitting a <code>work</code> fn that is the <code>open</code> call with a <code>uv__fs_done</code> callback fn.</p>
<p>In the <code>uv_fs_open</code> implementation , we are expanding the <code>INIT, PATH and POST</code> macros, to show what happens under the hood.</p>
<p>Node JS <code>open</code> wraps <code>uv_fs_open</code> in a way that we can open the file in a worker thread and have the user provided JS callback fn execute on the event thread. We are basically looking at how this flow works.</p>





<pre tabindex="0"><code>int uv_fs_open(uv_loop_t* loop,
               uv_fs_t* req,
               const char* path,
               int flags,
               int mode,
               uv_fs_cb cb) {
  INIT(OPEN);
  PATH;
  req-&gt;flags = flags;
  req-&gt;mode = mode;
  POST;
}</code></pre><p>INIT, PATH and POST are macros that expand to code like</p>





<pre tabindex="0"><code>do {                                                                        \
    if (req == NULL)                                                          \
      return UV_EINVAL;                                                       \
    UV_REQ_INIT(req, UV_FS);                                                  \
    req-&gt;fs_type = UV_FS_OPEN                                        \
    req-&gt;result = 0;                                                          \
    req-&gt;ptr = NULL;                                                          \
    req-&gt;loop = loop;                                                         \
    req-&gt;path = NULL;                                                         \
    req-&gt;new_path = NULL;                                                     \
    req-&gt;bufs = NULL;                                                         \
    req-&gt;cb = cb;                                                             \
  }                                                                           \
  while (0)


  do {                                                                        \
    assert(path != NULL);                                                     \
    if (cb == NULL) {                                                         \
      req-&gt;path = path;                                                       \
    } else {                                                                  \
      req-&gt;path = uv__strdup(path);                                           \
      if (req-&gt;path == NULL)                                                  \
        return UV_ENOMEM;                                                     \
    }                                                                         \
  }                                                                           \
  while (0)
 .req-&gt;flags = flags;
  req-&gt;mode = mode;

  do {                                                                        \
    if (cb != NULL) {                                                         \
      uv__req_register(loop, req);                                            \
      uv__work_submit(loop,                                                   \
                      &amp;req-&gt;work_req,                                         \
                      UV__WORK_FAST_IO,                                       \
                      uv__fs_work,                                            \
                      uv__fs_done);                                           \
      return 0;                                                               \
    }                                                                         \
    else {                                                                    \
      uv__fs_work(&amp;req-&gt;work_req);                                            \
      return req-&gt;result;                                                     \
    }                                                                         \
  }                                                                           \
  while (0)</code></pre><p>If we pass a callback function (which is almost always), <code>uv_fs_open</code> submits a req of type <code>FAST_IO</code> using <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/threadpool.c">uv__work_submit</a>:</p>





<pre tabindex="0"><code>void uv__work_submit(uv_loop_t* loop,
                     struct uv__work* w,
                     enum uv__work_kind kind,
                     void (*work)(struct uv__work* w),
                     void (*done)(struct uv__work* w, int status)) {
  uv_once(&amp;once, init_once);
  w-&gt;loop = loop;
  w-&gt;work = work;
  w-&gt;done = done;
  post(&amp;w-&gt;wq, kind);
}</code></pre><p><code>w-&gt;work</code> is the function that is executed by the worker thread. <code>post</code> adds this work item to the work queue.
The worker fn <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/threadpool.c#L122">picks</a> up the work and executes the work function</p>
<p>The flow of code from JS -&gt; C++ -&gt; C is as follows</p>
<p><a href="https://github.com/nodejs/node/blob/main/lib/fs.js#L563">JS <code>open</code></a> : <code>fs.open(path, options, callback)</code>
1. create a <code>req: FSReqCallback</code> = <code>Req(context(callback))</code>
<code>req</code> has an <code>oncomplete</code> member, that will be called after req is done
the oncomplete simply calls <code>callback()</code>, which is the User provided callback
2. call into Node C++ : <code>binding.open(path, flags, mode:666, req)</code></p>
<p><a href="https://github.com/nodejs/node/blob/main/src/node_file.cc#L1958">binding.Open</a>:
1.If a <code>req</code> argument is provided, the file is opened asynchronously
2. make <code>req_wrap_async: FSReqBase = FSReqBase(req)</code>
3. why do we wrap req ? req is a <code>FSReqCallback</code> which is an object that lives in JS land. We need to wrap it in a <code>BaseObject</code>,which is the abstraction used to tie JS objects to the C++ world.
(I am not sure why we can&rsquo;t just pass around a v8::object without wrapping it in a BaseObject, probably because we need to increment the ReferenceCount to this object so that it isn&rsquo;t GC&rsquo;ed while waiting for something to happen in CPP/C land)
Some understanding of Class Hierarchy is needed here:<br>
The order of sub-classes (super -&gt; sub) : BaseObject -&gt; ReqWrap -&gt; FSReqBase (ReqWrap&lt;uv_fs_t&gt;)
FSReqBase is a parametrized sub-class of ReqWrap&lt;uv_fs_t&gt; which =&gt; that it deals with fs <code>requests</code> (A <code>request</code> in lib_uv is a short action (such as opening a file, reading a file etc))
From Open, we call <code>uv_fs_open</code>, the <code>libuv</code> file that is used to open a file, asynchronously, via <code>AsyncCall</code></p>
<p><a href="https://github.com/nodejs/node/blob/main/src/node_file.cc#L1981">AsyncCall</a>
This is a wrapper over <code>AsyncDestCall</code> with a extra <code>nullptr</code> argument</p>
<p><a href="https://github.com/nodejs/node/blob/main/src/node_file-inl.h#L295">AsyncDestCall</a>
<code>AsyncDestCall(env, req_wrap_async, args, &quot;open&quot;,UTF8,nullptr,0,AfterInteger, </code>uv_fs_open, *path, flags, mode)
<code>req_wrap_async</code>: A C++ land wrapper over our user passed JS Callback (which is FSReqCallback(user_provided_callback))
Before calling <code>uv_fs_open</code>, we have to do a few things
Init req_wrap_async with a name of the syscall we want to do (<code>open</code> in this case)
call <code>req_wrap_async-&gt;Dispatch(uv_fs_open, ..args, AfterInteger)</code></p>
<p><a href="https://github.com/nodejs/node/blob/f0995d14768b36c3cbb2d75d57b0ff92b254b334/src/req_wrap-inl.h#L139">Dispatch</a>:
<code>int ReqWrap&lt;T&gt;::Dispatch(LibuvFunction fn, Args... args) {</code>
Dispatch is where <code>uv_fs_open</code> is actually called
The signature of <code>uv_fs_open</code> looks like: <code>int uv_fs_open(uv_loop_t *loop, uv_fs_t *req, const char *path, int flags, int mode, uv_fs_cb  cb)</code>
What is the responsibility of each arg to <code>uv_fs_open</code> ?
1. <code>loop</code> -&gt; The event loop to which we submit our <code>work</code> that is opening a file.
2. <code>req</code> -&gt; denotes that we are operating on a file (<code>uv_fs_t</code>). <code>req</code> can contain a pointer to some arbitrary data that will be of use later
3. <code>char* path</code> : The path to the file that we want to open
4. <code>flags</code> and <code>mode</code>: The flags and mode with we want to open the file (lookup <code>man 2 open</code>  on macOS)
5. <code>cb</code>: A callback function to be called once our file is opened. This callback function will be passed the <code>req</code> that we passed in the <code>uv_fs_open</code>. We have a C++ function: <code>AfterInteger</code> that is passed as the callback function.
There is a lot of funkiness about how <code>AfterInteger</code> is called. It is first  <a href="https://github.com/nodejs/node/blob/main/src/req_wrap-inl.h#L129">Wrapped</a> in some sort of C++ template magic.This is done so that our <code>JS</code> function can be called by the C <code>uv__fs_done</code> function (that is run after our <code>open</code> call)</p>
<p><a href="https://github.com/nodejs/node/blob/main/src/node_file.cc#L828">AfterInteger</a>
If you do not understand this section , feel free to ignore it. Basically, our original JS callback, provided by the user to <code>fs.open(...)</code> is called in AfterInteger, thus finishing our code cycle.</p>
<p>When AfterInteger  is called, our <code>open</code> call is done and we have the result of the call. Assuming, we opened the file successfully, we need to fetch the callback passed by the user, so that we can execute it. Recall that our <code>uv_fs_open</code> calls the callback with a <code>uv_fs_t</code> data structure. So how do we get back the original FSReqCallback structure, from a <code>uv_fs_t</code> data structure ? We use the <a href="https://github.com/nodejs/node/blob/main/src/node_file.cc#L820">container_of</a> magic to get the wrapping data structure of our <code>uv_fs_t</code>  (which is FSReqCallback). AfterInteger calls <a href="https://github.com/nodejs/node/blob/main/src/node_file.cc#L717">Resolve</a> on <code>FSReqCallback</code>, which finally executes our user provided callback fn</p>
]]></content:encoded>
    </item>
    <item>
      <title>A libuv Primer</title>
      <link>https://gowind.github.io/post/libuv_primer/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/libuv_primer/</guid>
      <description>This is the first part of my post on how async file calls in Node JS works.</description>
      <content:encoded><![CDATA[<p>This is the first part of my post on how async file calls in Node JS works. Before we dive into the Node JS parts, I wanted to write a small primer on how <code>libuv</code> handles
<code>work</code> requests using a <code>threadpool</code>. The work consists of 2 fns : a <code>work fn</code> and an optional <code>callback</code> fn. With Node, the <code>work fn</code> will do the block file calls (<code>open</code>, <code>read</code>, <code>write</code>) etc
and the <code>callback</code> triggers the chain of calls that will end with the user provided callback being called in the end.</p>
<p>The primer article&rsquo;s code does the following:</p>
<ol>
<li>Launch event loop on main thread</li>
<li>submit a <code>work</code> to the event loop (from the main thread) that is run in a different thread. The work fn calls <code>sleep()</code> to simulate a block operation</li>
<li>The <code>done</code> fn, which is a callback , is called in the main thread that is running the event loop</li>
<li><code>uv_run</code> returns after all work is completed (and the callbacks called). <code>main</code> then returns and the program is terminated</li>
</ol>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sleeper_fn</span>(<span style="color:#66d9ef">uv_work_t</span><span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">after_sleeping_is_done_fn</span>(<span style="color:#66d9ef">uv_work_t</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uv_loop_t</span> <span style="color:#f92672">*</span>loop <span style="color:#f92672">=</span> <span style="color:#a6e22e">uv_default_loop</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pthread_t</span> <span style="color:#66d9ef">thread</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_self</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;loop running in thread id %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">thread</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uv_work_t</span> req;
</span></span><span style="display:flex;"><span>    req.data <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">uv_queue_work</span>(loop, <span style="color:#f92672">&amp;</span>req, sleeper_fn, after_sleeping_is_done_fn);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">uv_run</span>(loop, UV_RUN_DEFAULT);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sleeper_fn</span>(<span style="color:#66d9ef">uv_work_t</span><span style="color:#f92672">*</span> req) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">pthread_t</span> <span style="color:#66d9ef">thread</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_self</span>();
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;work function calling sleep done from thread id %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">thread</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sleep</span>(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>) req<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;sleeping done from sleeper</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">after_sleeping_is_done_fn</span>(<span style="color:#66d9ef">uv_work_t</span><span style="color:#f92672">*</span> req, <span style="color:#66d9ef">int</span> status) {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">pthread_t</span> <span style="color:#66d9ef">thread</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_self</span>();
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;call back being done from thread id %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74"> with work output %d&#34;</span>, <span style="color:#66d9ef">thread</span>, <span style="color:#f92672">*</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) req<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Compiled with
<code>gcc  -g -I./libuvlibs/include hellouvexample.c -L./libuvlibs/lib -o hoev -luv</code></p>
<p><strong>Before compiling the program</strong></p>
<p>Downloaded <a href="https://github.com/libuv/libuv/tree/v1.42.0">libuv</a> at tag <code>1.42.0</code> (wanted to use a version that doesn&rsquo;t use io_uring, even though it is irrelevant to macOS, to make it easier for me to understand the internal. If you are trying to re-create this blog post on Linux, using 1.42.0 will ensure that you don&rsquo;t use IO_URING thus ensure that my blog post on nodejs -&gt; libuv working will make sense to you)</p>
<p>Follow the instructions for building <code>libuv</code> on <code>macOS</code></p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./config --prefix<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>pwd<span style="color:#66d9ef">)</span>/libuvlibs<span style="color:#e6db74">`</span> 
</span></span><span style="display:flex;"><span>make
</span></span><span style="display:flex;"><span>make install</span></span></code></pre></div><p>I am installing the dynamic lib to the local folder instead of the default <code>/usr/local/</code> paths.</p>
<h3 id="output">OUTPUT</h3>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>loop running in thread id 0x1dd706080
</span></span><span style="display:flex;"><span>work <span style="color:#66d9ef">function</span> calling sleep <span style="color:#66d9ef">done</span> from thread id 0x16fcaf000
</span></span><span style="display:flex;"><span>sleeping <span style="color:#66d9ef">done</span> from sleeper
</span></span><span style="display:flex;"><span>call back being <span style="color:#66d9ef">done</span> from thread id 0x1dd706080
</span></span><span style="display:flex;"><span> with work output 6%</span></span></code></pre></div><h3 id="appendix">Appendix</h3>
<h4 id="how-does-the-event-loop-thread-know-that-the-worker-is-done-therefore-the-callback-must-be-called-">How does the event loop thread know that the worker is done, therefore the <code>callback</code> must be called ?</h4>
<p>It is also crucial that the even loop running in the <code>main</code> thread not block in any way for a signal from the worker thread, otherwise we will be preventing other runnables from proceeding on the event thread</p>
<p>Enter UNIX pipes. A pipe is a communication devices across processes / threads with one for writing and another end for reading.</p>
<p>When the event loop function is  <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/unix/async.c#L202">run() uv_run</a> , a pipe is created and a reference to the <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/unix/async.c#L222">read</a> and the <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/unix/async.c#L224">write</a> ends are stored in the loop&rsquo;s data structures. The read and write ends are UNIX file descriptors.</p>
<p>In the <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/threadpool.c#L57">implementation</a> of the worker threads, when a work is available,  the <code>work fn</code> of the <code>work</code> structure is called using <code>w-&gt;work()</code>. Once the work fn is executed, the worker thread signals the event loop running thread using <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/threadpool.c#L122">uv_async_send</a>.</p>
<p><code>uv_async_send(loop)</code> then <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/unix/async.c#L188">writes</a>to the write end of the pipe a single integer. It doesn&rsquo;t matter what is written, so long as the event loop can know that some work was done. The event loop can scan through the work queue for completed tasks during each loop iteration and run the associate callbacks</p>
<p>The most interesting trick is, because a pipe read-end in UNIX is a file descriptor, it can be <code>polled</code> for events (such as READ) in a non-blocking way. The main event loop function <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/unix/core.c#L369">uv_run</a> constantly  <a href="https://github.com/libuv/libuv/blob/v1.42.0/src/unix/kqueue.c#L112">polls</a>  descriptors it is interested in (for example, files we have opened, read or written to, client socket for making HTTP requests etc). When our work is done and the client writes to the PIPE, the event loop poller can READ the work done event and then executes all the associated callbacks of <code>done</code> events in the queue</p>
]]></content:encoded>
    </item>
    <item>
      <title>Jest Guide</title>
      <link>https://gowind.github.io/post/jest_guide/</link>
      <pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/jest_guide/</guid>
      <description>some notes I took when trying to understand the jest library for unit testing in js/ts</description>
      <content:encoded><![CDATA[<p>some notes I took when trying to understand the <code>jest</code> library for unit testing in js/ts</p>
<p><code>Expectation</code> objects - <code>expect(X)</code>
<code>Matchers</code> - <code>.toBe(Y)</code>, <code>.toEqual(Z)</code> etc</p>
<p>ExpectationObject.Matchers - pattern for testing.</p>
<p><code>test(&quot;Test description&quot;, func() {}</code> - how to write tests</p>





<pre tabindex="0"><code>test(&#34;Testing async functions&#34;, async () =&gt; {
   y = await some_async_func();
   expect(y).toBe(z);
}</code></pre><p>Look up the Jest documentation on the list of available <code>matchers</code></p>
<h3 id="setup-and-teardown">Setup and Teardown.</h3>





<pre tabindex="0"><code>beforeEach(() =&gt; {
   initializer_fn(); // setup before each test
});

afterEach(() =&gt; {
	teardown_fn(); // teardown after each test
});</code></pre>




<pre tabindex="0"><code>beforeAll( () =&gt; {
	// one time setup before running tests in this file
});

afterAll( () =&gt; {
	// one time teardown after running tests in the file
});</code></pre>




<pre tabindex="0"><code>
describe(&#34;a block to scope tests&#34;, () =&gt; {
	beforeEach(() =&gt; {
		// runs only before tests in this scope
	});
	test(&#39;description&#39;, () =&gt; {})
})`</code></pre><p><code>describe</code>s can be nested.</p>
<h3 id="order-of-execution">Order of Execution.</h3>
<ol>
<li>
<p>Tests inside <code>describes</code> are collected first, before they are run.</p>
</li>
<li>
<p>The tests inside <code>describe</code>s are run in the order they were collected (top-down).</p>
</li>
<li>
<p>Top level test (outside of any describe-scope) are run in the order they are seen (tests inside <code>describes</code> <em>before</em> the top-level tests are run <em>after</em> the top-level test)</p>
</li>
</ol>





<pre tabindex="0"><code> //action.test.ts 

beforeEach(() =&gt; console.log(&#39;connection setup&#39;));
beforeEach(() =&gt; console.log(&#39;database setup&#39;));

  

afterEach(() =&gt; console.log(&#39;database teardown&#39;));
afterEach(() =&gt; console.log(&#39;connection teardown&#39;));

  

describe(&#34;first scoped block&#34;, () =&gt; {
	test(&#39;test inside first describe&#39;, () =&gt; {
		console.log(&#39;hai i am test inside first describe&#39;);
		expect(1).toBe(1);
	});

});

test(&#39;test 1&#39;, () =&gt; {
	console.log(&#34;hi, i am top level test&#34;);
	expect(2).toBe(2);
});

  

describe(&#39;extra&#39;, () =&gt; {

beforeEach(() =&gt; console.log(&#39;extra database setup&#39;));

afterEach(() =&gt; console.log(&#39;extra database teardown&#39;));

  

test(&#39;test 2&#39;, () =&gt; console.log(&#39;test 2&#39;));

});</code></pre>




<pre tabindex="0"><code>PASS  action.test.ts
 ✓ test 1 (3 ms)
 first scoped block
   ✓ test inside first describe (5 ms)
 extra
   ✓ test 2 (6 ms)</code></pre><p>You can see that top-level test is run <em>before</em> tests in the scope <code>first scoped block</code>, even though the scope comes before the top-level test in the file.</p>
<h2 id="mocking">Mocking</h2>
<p><code>jest.fn()</code>  -&gt; Mock Function, that creates an object that can be called as a constructor, or as an object with attached methods</p>





<pre tabindex="0"><code>
let k = jest.fn({create: jest.fn()});
k.create(44);
k.create(66);</code></pre><p><code>.mock</code> property of a <code>jest.fn</code>  is where data about how the function has been called and what the function returned is kept. The <code>.mock</code> property also tracks the value of <code>this</code> for each call, so it is possible to inspect this as well.</p>





<pre tabindex="0"><code>const myMock1 = jest.fn();
const a = new myMock1();
console.log(myMock1.mock.instances);
// &gt; [ &lt;a&gt; ]const myMock2 = jest.fn();
const b = {};
const bound = myMock2.bind(b);
bound();
console.log(myMock2.mock.contexts);
// &gt; [ &lt;b&gt; ]</code></pre><h3 id="mocking-a-return-value-for-a-fn">Mocking a return value for a fn</h3>





<pre tabindex="0"><code>const myMock = jest.fn();
myMock.mockReturnValue(66);
console.log(myMock(400, 88, &#34;hai&#34;));
// &gt; 66
console.log(myMock());
// &gt; 66</code></pre><h3 id="mocking-modules">Mocking Modules</h3>
<ol>
<li>Import module (for references to the classes, objects or functions within the module)</li>
<li>use <code>jest.mock('module-name')</code> , to mock all the classes, objects or functions within the module.</li>
</ol>





<pre tabindex="0"><code>
import axios from &#39;axios&#39;;
import Users from &#39;./users&#39;;
jest.mock(&#39;axios&#39;);
test(&#39;should fetch users&#39;, () =&gt; {  
	const users = [{name: &#39;Bob&#39;}];  
	const resp = {data: users};  axios.get.mockResolvedValue(resp);  
	return Users.all().then(data =&gt; expect(data).toEqual(users));});</code></pre><h4 id="mocking-a-module-partially">Mocking a Module partially</h4>
<ol>
<li>import the exports of a module that you need.</li>
<li>Use <code>jest.mock('module-to-be-partially-mocked', () =&gt; {}</code></li>
<li>In the <code>() =&gt; {..</code> return a module, with the exports needed to be mocked, replaced with the mocked values</li>
</ol>





<pre tabindex="0"><code>//foo-bar-baz.js 
// we want to mock `foo` in one of our tests 

export const foo = &#39;foo&#39;;
export const bar = () =&gt; &#39;bar&#39;;
export default () =&gt; &#39;baz&#39;;</code></pre>




<pre tabindex="0"><code>//test.js

import defaultExport, {bar, foo} from &#39;../foo-bar-baz&#39;;
jest.mock(&#39;../foo-bar-baz&#39;, () =&gt; {  
	const originalModule = jest.requireActual(&#39;../foo-bar-baz&#39;);  
	//Mock the default export and the named export &#39;foo&#39;  
	return {    __esModule: true,    
				...originalModule,    
				default: jest.fn(() =&gt; &#39;mocked baz&#39;),   
				foo: &#39;mocked foo&#39;,  }
				;});
test(&#39;should do a partial mock&#39;, () =&gt; {  
		const defaultExportResult = defaultExport();
		expect(defaultExportResult).toBe(&#39;mocked baz&#39;);    
		expect(defaultExport).toHaveBeenCalled();  
		expect(foo).toBe(&#39;mocked foo&#39;); 
		expect(bar()).toBe(&#39;bar&#39;);});</code></pre><p>You can also use it in a diff. way</p>





<pre tabindex="0"><code>jest.mock(&#39;node-fetch&#39;);
import fetch from &#39;node-fetch&#39;;
// we obtain the original implementation for the Response class
const {Response} = jest.requireActual(&#39;node-fetch&#39;);

test(&#39;somewhere where we have to mock a fetch request&#39;, async () =&gt; {  
	fetch.mockReturnValue(Promise.resolve(new Response(&#39;4&#39;)));
	let resp = await fetch(&#34;/some-resource&#34;);
	expect(resp.text()).toBe(&#39;4&#39;);</code></pre><h3 id="open-handles">Open Handles</h3>
<p>When Jest finishes running tests, it can checks to see if there are any events preventing the event loop from exiting.
This is useful for example, to find connection objects that aren&rsquo;t closed or (maybe unresolved Promises as well?) that might keep the loop alive. You can detect this by using <code>jest --detectOpenHandles</code>. It has helped me figure out connections objects that I opened and never closed</p>
]]></content:encoded>
    </item>
    <item>
      <title>AVL Trees Part-1 What problem does AVL Tree solve?</title>
      <link>https://gowind.github.io/post/avl_trees_part1/</link>
      <pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/avl_trees_part1/</guid>
      <description>Imagine you have a Binary Search Tree implementation and you are inserting elements in ascending order</description>
      <content:encoded><![CDATA[<p>Imagine you have a Binary Search Tree implementation and you are inserting elements in ascending order</p>
<p>[11., 12, 13, 14, 15, 16, 17, 18]</p>
<p>Your Binary Search Tree would look like this</p>





<pre tabindex="0"><code>11
  12
    13
      14
        15
          16
            17
              18 </code></pre><p>Your tree effectively turns into a Linear list with O(n) access, instead of O(h) access where h ~ log2(n)</p>
<p>This is an <strong>unbalanced</strong> tree and the more unbalanced a tree is, the more avg. access is O(n) instead log2(n)</p>
<p>(Similarly, if we are turning a descending sorted array into a Binary Search Tree, we will run into the mirror image of the above tree)</p>
<p>AVL Trees are a <strong>balanced</strong> tree, where after very insertion and deletion, we <strong>balance</strong> the tree if it becomes unbalanced.</p>
<h5 id="by-keeping-a-tree-balanced--we-are-ensuring-that-access-remains-as-close-to-on-as-possible">By keeping a tree <code>balanced</code> , we are ensuring that access remains as close to O(n) as possible</h5>
<h4 id="how-do-we-know-a-tree-is-unbalanced-">How do we know a tree is unbalanced ?</h4>
<p>We use a value <code>balanceFactor</code> to determine if a node is balanced or not.</p>
<p>Before we formulated <code>balanceFactor</code>, recall that :
The height of the tree is the distance from the node to the lowest leaf in its left or right subtree.
The height of a leaf is <code>0</code>. <code>height(leaf) -&gt; o</code>
The height of a <code>null</code> leaf is also 0. <code>height(null) -&gt; 0</code>
Height of a node = <code>1 + max(height(node.left), height(node.right))</code></p>
<p><code>balanceFactor = height(left_subtree) - height(right_subtree)</code>
If the <code>balanceFactor</code> is &lt; -1 or &gt; 1 , then the tree is <strong>unbalanced</strong>.</p>
<p>When we start with an empty tree, our tree is balanced. On every insert or delete, we insert/delete into the left or the right subtrees of a current node.
The insertion/deletion disturbs the existing balance of our tree, so we perform a check for each node in our path from the root, until the leaf node we inserted, if the node is balanced.
If any node is unbalanced, then we <code>rebalance</code> that node</p>





<pre tabindex="0"><code>insert/delete(node, val):
  if val &lt; node.val:
	  node.left = insert/delete(node.left, val)
  else:
      node.right = insert/delete(node.right, val)
  balance = calculate_balance(node)
  if balance &lt; -1 or balance &gt; 1 :
	  # rebalance</code></pre><h4 id="how-do-we-do-rebalance-">How do we do rebalance ?</h4>
<p>There are 4 conditions that will cause rebalancing. We name them as
Left Left
Left right
Right Right
Right Left</p>
<ol>
<li>LL (Left  Left)</li>
</ol>





<pre tabindex="0"><code>      14
    13
  12
10      </code></pre><p>The <code>balanceFactor</code> of the root with key <code>14</code>, = height(left_subtree) - height(right_subtree)
height(left_subtree) = 2
height(right_subtree) = 0
<code>balanceFactor</code> &gt; 1, so we rebalance.
Rebalancing this condition is done by a <code>rightRotate</code>.</p>
<p>The <code>rightRotate</code> of a node <code>n</code> is as follows</p>





<pre tabindex="0"><code>def rightRotate(n):
  left = n.left
  left_right = left.right
  new_root = left
  new_root.right = n
  n.left = left_right # since we moved n -&gt; left.right, left.right -&gt; n.left
  return new_root</code></pre><p>Our <code>unbalanced</code> node <code>n</code> becomes</p>





<pre tabindex="0"><code>     14                      13
    13        ---&gt;         12  14
  12                     10
10  </code></pre><p><code>balanceFactor</code> of the root is now <code>1.</code></p>
<ol start="2">
<li>RR (Right Right)</li>
</ol>





<pre tabindex="0"><code>      14
        15
          16
            17      </code></pre><p>The <code>balanceFactor</code> of the root with key <code>14</code>, = height(left_subtree) - height(right_subtree)
height(left_subtree) = 0
height(right_subtree) = 2
<code>balanceFactor</code> &lt; -1, so we rebalance.
Rebalancing this condition is done by a <code>leftRotate</code>.</p>





<pre tabindex="0"><code>def leftRotate(n):
  right = n.right
  right_left = right.left
  new_root = right
  new_root.left = n
  n.right = right_left # since we changed n.right to root
  return new_root</code></pre><p>The <code>leftRotate</code> turns out tree rooted at 14, to this:</p>





<pre tabindex="0"><code></code></pre><pre><code>  14                                 15
    \                               /    \
     15            ----&gt;          14      16
        \                                     \
         16                                     17
           \
            17      
</code></pre>





<pre tabindex="0"><code></code></pre><p>The next 2 conditions will need a combination of left and right rotates to rebalance.</p>
<ol start="3">
<li>Left Right</li>
</ol>





<pre tabindex="0"><code>      18
      /
    13
      \
      14
        \
        16      </code></pre><p>In this situation, a single right rotation wouldn&rsquo;t solve the problem. Why ? Lets try to do a simple LL fixup, which performs a <code>rotateRight(18)</code></p>





<pre tabindex="0"><code>       18                                       13
      /                                          \
    13             -----&gt; LL(18)                  18
      \                                          /
       14                                      14
        \                                       \
         16                                     16</code></pre><p><code>13</code> is the new root. <code>18</code> becomes 13&rsquo;s right. <code>left_right</code> from <code>rightRotate()</code> (14) become&rsquo;s <code>n.left</code> (18&rsquo;s left). <code>x</code> mark&rsquo;s <code>null</code> nodes</p>
<p>If we calculate the <code>balanceFactor</code> of 13, it is now <code>-2</code> instead of becoming 1. So doing a single <code>rightRotate</code> in this case isn&rsquo;t sufficient.</p>
<p>Since our case is a LR (Left of root, then right of left), we do a <code>leftRotate</code> of <code>n.left</code>, followed by a <code>rightRotate</code> of n.</p>
<p>This will first turn LR -&gt; LL, and then we can apply <code>rightRotate</code></p>





<pre tabindex="0"><code>      18                              18                                14
     /    
    13
      \       --&gt; leftRotate(13)    14    --&gt; rightRotate(18) --&gt;.  13.    18
       14                        13.  16                          x   x 16.  x
        16                       </code></pre><p>We now have a balanced Tree.</p>
<p>(We could have stopped after the leftRotate(13), the next insert of a value &lt; 18 would have triggered a further rebalance. I think this is why the algorith now specifies an additional rightRotate of 18 so that we can insert a few more elements before have to rebalance)</p>
<ol start="4">
<li>RL (Right Left)</li>
</ol>





<pre tabindex="0"><code>      18
        \
         29
         /
       27
       /
    22</code></pre><p>Similar to LR, we cannot do just 1 rotation and fix this situation. Let us try to a simple leftRotate on 18 to see why</p>





<pre tabindex="0"><code>   18                                    29
     \                                  /
     29      --RR(18)-&gt;                18
   /                                     \   
  27                                      27
 /                                       /
22                                      22 </code></pre><p>Our <code>balanceFactor</code> for the root is now still -2.</p>
<p>To solve this, we first do a <code>rotateRight(29)</code> and then follow it up with a <code>leftRotate(18)</code></p>





<pre tabindex="0"><code>    18                            18                                    27
      \                             \                                 /   \ 
      29  rightRotate(29) -&gt;         27        leftRotate(18) -&gt;.   18    29
     /                              /  \                              \
   27                              22   29                            22
  /
22</code></pre>]]></content:encoded>
    </item>
    <item>
      <title>AVL Trees Part-2 Deletion</title>
      <link>https://gowind.github.io/post/avl_trees_part2/</link>
      <pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/avl_trees_part2/</guid>
      <description>In [[AVL Trees - Part I]], we saw the need for AVL Trees and how we use the balanceFactor of a node to keep the tree balanced when inserting nodes.</description>
      <content:encoded><![CDATA[<p>In [[AVL Trees - Part I]], we saw the need for AVL Trees and how we use the <code>balanceFactor</code> of a node to keep the tree balanced when inserting nodes.</p>
<p>In a similar fashion, when deleting nodes, the Tree&rsquo;s balance can go out of whack. We therefore do the same rotation operations during deletion, to keep the tree balanced.</p>
<p>Whenever we delete a node/leaf, starting from its parent, all the way to the root, we check the balance of each node and rebalance it the balanceFactor &gt; 1 or &lt; -1</p>
<p>We will go over the same 4 conditions described in Part 1 and see how to apply the operations during Deletion</p>
<ol>
<li>LL (Left  Left)</li>
</ol>





<pre tabindex="0"><code>       14                                              14
      /  \                                           /   \
     13   17        --delete(19)--&gt;.               13     17
    /      \                                      /
   12       19                                   12
  /                                            /
10                                           10</code></pre><p>We do a standard rightRotate(root) to balance this</p>





<pre tabindex="0"><code>          13
         /  \
        12  14
       /      \
      10       17</code></pre><p><code>balanceFactor</code> of the root is now <code>1.</code></p>
<ol start="2">
<li>RR (Right Right)</li>
</ol>





<pre tabindex="0"><code>        14                                    14
       /  \                                 /   \
      10    15         --delete(16)--&gt;.   10      15
     /        \                                    \ 
    6         16                                    16
                \                                    \
                 17                                   17</code></pre><p>We do a standard rotateLeft(root) to balance this</p>





<pre tabindex="0"><code>       15
      /  \
     14   16
    /      \
   10       17</code></pre>




<pre tabindex="0"><code>def leftRotate(n):
  right = n.right
  right_left = right.left
  new_root = right
  new_root.left = n
  n.right = right_left # since we changed n.right to root
  return new_root</code></pre><p>The <code>leftRotate</code> turns out tree rooted at 14, to this:</p>





<pre tabindex="0"><code></code></pre><pre><code>  14                                 15
    \                               /    \
     15            ----&gt;          14      16
        \                                     \
         16                                     17
           \
            17      
</code></pre>





<pre tabindex="0"><code></code></pre><ol start="3">
<li>Left Right</li>
</ol>





<pre tabindex="0"><code>          2418328867                                           
            /.    \                                                    
 2283235063       2441074453           ---delete(2441074453)--&gt; 
       \             \
        2341175950   2452843659
        /
2319367546</code></pre><p>when we delete a node, we replace it&rsquo;s position in the tree by its in-order successor, if it has any.</p>





<pre tabindex="0"><code>           . 2418328867                                           
            /.    \                                                    
 2283235063        2452843659     
       \            
        2341175950   
        /
2319367546</code></pre><p>The balance factor of node rooted at key  <code>2418328867</code> is 2, we rebalance this using LR technique described in the insertion post.</p>
<p>LeftRotate(root.left)</p>





<pre tabindex="0"><code>           2418328867                                           
            /     \                                                    
       2341175950  2452843659     
        /    
2283235063 
       \
       2319367546</code></pre><p>Followed by rightRotate(root)</p>





<pre tabindex="0"><code>		2341175950
		/.       \
	2283235063	2418328867
       \              \
       2319367546      2452843659</code></pre><p>Right Left</p>





<pre tabindex="0"><code>               150265093
	          /       \
    1063987789         1718327935       --delete(406675537)--&gt;
     /                /       \
406675537   1479316738       1957770709
            /        \.                
  1305025970          1480403904</code></pre>




<pre tabindex="0"><code>               150265093
	          /       \
    1063987789         1718327935      
                       /       \
             1479316738       1957770709
            /        \.                
  1305025970          1480403904</code></pre><p>the balanceFactor of the root is -2. So we rebalance this, by perfoming a RightLeft rotation.</p>
<ol>
<li>RotateRight(root.right)</li>
</ol>





<pre tabindex="0"><code>               150265093
	          /       \
    1063987789         1479316738      
                       /       \
		 .   1305025970         1718327935
                              /      \
		            1480403904     1957770709</code></pre><ol start="2">
<li>followed by rotateLeft(root)</li>
</ol>





<pre tabindex="0"><code>			   1479316738
			/           \
		  150265093.      1718327935
		 /.     \              /       \
1063987789.    1305025970. 1480403904.  1957770709</code></pre>]]></content:encoded>
    </item>
    <item>
      <title>A Software Engineer is a professional</title>
      <link>https://gowind.github.io/post/what_do_i_do_as_a_software_engineer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/what_do_i_do_as_a_software_engineer/</guid>
      <description>Who is a professional ? In my words, a professional is a high skilled person, who can be relied upon to fulfil expectations in the area at which he is skilled.</description>
      <content:encoded><![CDATA[<p>Who is a professional ? In my words, a professional is a high skilled person, who can be relied upon to fulfil expectations in the area at which he is skilled.</p>
<p>3 words are important here</p>
<ol>
<li>skill</li>
<li>relied upon (reliability)</li>
<li>expectations</li>
</ol>
<h3 id="skills">Skills</h3>
<p>As a Software Engineer, your skill is your ability to work with software.
You are programming software to fulfil expectations.</p>
<p>you employ your skill in software and programming, to do what needs to be done.</p>
<h3 id="expectations">Expectations</h3>
<p>But what needs to be done ?</p>
<p>My team maintains a feature as a part of a large product that serves 100M+ customers all over the world. The feature provides incentives to the user to continue using our product. The feature has a certain definition and behaviour and must serve all the users on our platform.</p>
<p>What my team (and therefore I) must do is a simple statement:
Identify and improve this feature to improve usage of our product and retain more customers.</p>
<ol>
<li>Communication: To do this effectively, my team has to talk to marketing managers to understand how they market our product and how we can provide incentives to attract more customers. Since Marketing is heavily dependent on the country/demographics/language of our audience, we have to put in the effort to consider the various needs before adding or extending the features.</li>
<li>Scale: We cannot launch features that cannot scale to our entire customer base. so before we decide to add more features, we have to see if we can reliably scale to extend our features to all of our users, otherwise it will have a net impact</li>
<li>Planning and estimation: Developers are expensive. For anything we set out to do, we must be capable of assessing the difficulty of tasks, risks that might delay our estimates and most importantly plan the order of things to be done, so that we aren&rsquo;t wasting time doing a task that will ultimately have to be discarded</li>
<li>Measurement and Analytics : most features are experimental in nature (ie, you do not know if it made an impact or not). To gauge the success of anything we add (or remove), we need to measure the impact. Our job doesn&rsquo;t just stop once we yeet our code changes into Production. We provide tools and data to assess the impact of our changes so that PMs and Marketing people can make informed decisions.</li>
</ol>
<p>Notice how programming is a <em>critical</em> but small part of my responsibilities. My work is a superset of programming related tasks. What I am doing is anything and everything to support this feature that my team is expected to maintain as a part of the larger product and the company.</p>
<p>We get to the final part: how am I doing it ??</p>
<h3 id="reliability">Reliability</h3>
<p>Any automation/script is only as good as how many times you have to manually intervene.
If you have a computer, that is super fast, but has to be restarted every 5 mins, it is worthless than a calculator because you can never depend on it.</p>
<p>Similarly, the most talented developers are only as good as how long they can be relied upon and how frequently their managers have to &ldquo;manage&rdquo; them.</p>
<p>The best software developers are the ones that managers can forget about knowing because they know that they can manage themselves.</p>
<p>The worst software developers are the ones that, like babies, need a full-time caretaker to make sure they aren&rsquo;t soiling themselves or causing ruckus in the house or the nursery.</p>
<p>Your team and manager should be able to count on you to consistently deliver, with the least amount of intervention possible.</p>
<p>This doesn&rsquo;t mean that they never have to message you or setup a meeting or provide you information or basically not talk to you at all, nor does it mean you are expected to do everything by yourself without seeking help.</p>
<p>Your manager and team are happy in the fact that you will seek help, when needed, inform them of the status of your work, really dive into the details and keep track of everything that needs to be done.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Advice on the internet</title>
      <link>https://gowind.github.io/post/advice_on_the_internet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/advice_on_the_internet/</guid>
      <description>TL;DR: In today&amp;rsquo;s information rich world, Learning which advice to ignore is a skill.&#xA;This post is not advice, rather observations based on experience.</description>
      <content:encoded><![CDATA[<p>TL;DR: In today&rsquo;s information rich world, Learning which advice to ignore is a skill.</p>
<p>This post is not advice, rather observations based on experience.</p>
<p>I  classify advice into 2 broad buckets</p>
<ol>
<li>Tactical / specific advice</li>
<li>Generic advice</li>
</ol>
<h2 id="tactical-advice">Tactical advice</h2>
<p>Tactical / specific advice , is highly specific. This bucket, IMO, consists of advice whose effectiveness can be gauged very accurately and often very quickly.Stuck on a programming problem ? Ask a senior and he can tell you how to solve it and you do. Need to file taxes ? Your tax accountant helps you file taxes and reduces your tax burden. In this case there is a strict material number attached to the gain you make for his services.</p>
<h2 id="generic-advice">Generic advice</h2>
<p>Generic / strategic / philosphical advice. These are advice that are &ldquo;generic&rdquo;, as in both applicable to large swaths of the population and very broad, applicable to your life or career at any many points in time. Gauging the effectiveness of such advice is hard, sometimes nigh on impossible because the converse of these statements are often not true. For example, take the statement: &ldquo;hardwork makes you rich&rdquo;. The converse &ldquo;being rich means you did hardwork&rdquo; is not always true (or heck, is not even necessary). Also words like &ldquo;hardwork&rdquo; and &ldquo;rich&rdquo; are very subjective and for it to be a truly scientific statement, you need to control for all other variables (circumstances, education, luck, the exact year in which you did hardwork).</p>
<p>Generic advice is found everywhere on the internet today. The cost of disbursing information has gone down ~0, so you will find everyone handing out advice on how to live life, what are the right principles to have in life, what you must do and what you must eat.</p>
<h2 id="tactical-advice-is-relatively-easy-to-evaluate">Tactical advice is relatively easy to evaluate</h2>
<ol>
<li>Is the advice from a professional  (i.e. someone getting paid for their speciality) and is the advice for something related to that profession ?</li>
<li>and is there a direct metric that tells me how much I stand to gain if following that advice ?</li>
</ol>
<p>Most of the time, the problem is identifying which of the &ldquo;generic&rdquo; advice are valuable and which of them are pure BS. I used a few broad principles to gauge how effective some piece of advice can be</p>
<h4 id="1-most-generic-advice-is-useless-proven-otherwise">1. Most &ldquo;generic&rdquo; advice is useless proven otherwise.</h4>
<p>Thanks to the sheer Noise to Signal ratio of advice flooded on the internet, it is better to discard all new info first and then go pick for valuable ones later, than to hold onto junk in your head.</p>
<h4 id="2-it-is-never-about-the-message-it-is-always-about-the-messenger">2. It is never about the message. It is always about the messenger</h4>
<p><strong>Who</strong> gives which &ldquo;generic&rdquo; advice matters the most. No one will take the daily wage labourer sleeping on the roadside saying that &ldquo;hardwork matters&rdquo; seriously. But, when Narayana Murthy or Jeff Bezos or John Carmack says the same thing, everyone perks up their ears. Why ? because the latter are wealthy, and wealth is the signal that will make people listen to you.</p>
<h4 id="3-follow-the-money">3. Follow the money</h4>
<p><strong>Follow the money</strong> IMO is the most universal advice that I have seen to be consistently true across domains, people and time.</p>
<p>What does the person giving me advice stand to gain from me following the advice ? Take Paul Graham&rsquo;s <a href="https://www.paulgraham.com/articles.html">essays</a>. He gives a lot of advice on startups, hardwork, what you should do and how you should approach life, and they pretty much end up all end up with the message implicit and explicit: do a startup.
It makes sense why PG would say that. He (used to, now retired) runs Y Combinator, probably the most famous tech accelerator in the world, which funds startups in the Seed stage. Given the abysmal statistics around the success rate of startups, the more people that startup, the more options PG has and the more money he stands to make if every talented person pursues a startup in his portfolio that hits it big. PG makes money from people following his advice.</p>
<p>But is the advice useful to <strong>you</strong>: the follower ? While it is true that YC startups have had billions of dollars of payoff and made billionaires out of founders, the <a href="https://www.investopedia.com/articles/personal-finance/040915/how-many-startups-fail-and-why.asp">statistics</a> of starting up mean that the likelihood of a great payday that makes money beyond your wildest dreams (or something that beats the earnings over say 10 years of working at a FAANG) is probably close to zero. If you factor in the conditionality of success (say, Stanford dropout, living in Bay Area, being able to have a Harvard/Stanford co-founder), the more average your background is , the smaller the empirical probability of your personal success is.</p>
<h4 id="4-principal-agent-problem">4. Principal agent problem</h4>
<p>Imagine a housing broker that sells houses and gets a 3% commission from both the buyer and the seller on the sale of a house. The broker, while he might have been hired by you to find a house for you, on the guarantee that he will find the best bargains and haggle with the seller to make buying a house affordable for you,  has every reason to increase the price of a house as much as possible, for every rupee or dollar the price goes up , his bottomline increases.</p>
<p>Take a fund manager charging a 2% carry per year (carry is the fees as percentage of the total value of the fund being managed). The carry is non-negotiable, so whether a funds performs or not, the fund manager gets to pocket the carry irrespective of how well the fund performs. It is very much in the interest of (especially terrible ones) fund managers to maximise the sizes of the funds being managed, whereas you will have your funds locked up for anywhere between 3-10 years that might have made better returns just being invested in an index fund instead (and probably also redeemable when needed)</p>
<p>What are online advice sellers gaining and more specifically what hidden traps are there that you don&rsquo;t see, should you choose to follow that advice ? Follower count (yes, in my case, its not something world changing, but the ego boost of seeing your follower count go up is very much real) ? Do they stand to profit off your hardwork, leveraging it, while you pay the opportunity cost of having a family, social life or control over your time ? Do they have liquidity options that you don&rsquo;t (for example, founders can sell their equity in illiquid startup stock on the secondary market, whereas you, the employee only gets worthless ESOPs)</p>
<p>The thing is, most of the times, you will have to take these bargains knowing that you are still at an disadvantage (eg. ESOPS and low salary at a startup because you can&rsquo;t find a job anywhere else, or you love the startup  and its missions so much that you are willing to take the opportunity cost), but the awareness of the risk plays a role in how one deals with the emotional turmoil of such bets. You can&rsquo;t control the outcomes, but if you know the risks better, you can for sure control your reactions to the said outcomes. And to me that is the key: am I equipped to deal with the emotional consequences of these outcomes ?</p>
]]></content:encoded>
    </item>
    <item>
      <title>C is the universal ABI</title>
      <link>https://gowind.github.io/post/c_is_the_universal_abi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/c_is_the_universal_abi/</guid>
      <description>A ABI is a contract between the program and the Operating system / Hardware.&#xA;Lets write a library in Zig and have it &amp;ldquo;exported&amp;rdquo; in such a way that it conforms to C ABI (the API required by C to call functions, pass arguments and return values)</description>
      <content:encoded><![CDATA[<p>A <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> is a contract between the program and the Operating system / Hardware.</p>
<p>Lets write a library in Zig and have it &ldquo;exported&rdquo; in such a way that it conforms to C ABI (the API required by C to call functions, pass arguments and return values)</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clib.zig" data-lang="clib.zig"><span style="display:flex;"><span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">fn</span> multiplyAndAdd(x<span style="color:#f92672">:</span> <span style="color:#66d9ef">c_int</span>, y<span style="color:#f92672">:</span> <span style="color:#66d9ef">c_int</span>) <span style="color:#66d9ef">c_int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> k<span style="color:#f92672">:</span> <span style="color:#66d9ef">c_int</span> <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> k <span style="color:#f92672">+</span> y;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p><code>export</code> -&gt; This <code>fn</code> is to be compiled in a C ABI compatible way.
<code>c_int</code> -&gt; an integer whose bit layout can be understood by C.</p>
<p>Now lets build it into a shared dynamic library
<code>zig build-lib -fPIC -dynamic clib.zig</code></p>
<p>This will output a <code>libclib.dylib</code> on the <code>macOS</code> (will be <code>libclib.so</code> on Linux)</p>
<p>Lets see if we can call this fn from C code. After all, this is why we exported the fn in the first place.</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-main.c" data-lang="main.c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;clib.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#a6e22e">multiplyAndAdd</span>(k , <span style="color:#ae81ff">16</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, j);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>




<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clib.h" data-lang="clib.h"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">multiplyAndAdd</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);</span></span></code></pre></div>




<pre tabindex="0"><code>gcc -I. -L. main.c -o main -lclib</code></pre><p>Executing this, we get</p>





<pre tabindex="0"><code>./main
160</code></pre><p>Cool. If this is C ABI, can we use it from other languages as well ? Turns out, we can. Lets call this fn from Python</p>





<pre tabindex="0"><code>import ctypes
import pathlib

if __name__ == &#34;__main__&#34;:
    # Load the shared library into ctypes
    libname = pathlib.Path().absolute() / &#34;libclib.dylib&#34;
    c_lib = ctypes.CDLL(libname)
    c_lib.multiplyAndAdd.restype = ctypes.c_int
    answer = c_lib.multiplyAndAdd(ctypes.c_int(12), ctypes.c_int(16))
    print(answer)</code></pre>




<pre tabindex="0"><code>&gt; python pythonclib.py
160</code></pre><p>C is THE universal ABI</p>
]]></content:encoded>
    </item>
    <item>
      <title>C start</title>
      <link>https://gowind.github.io/post/c_start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/c_start/</guid>
      <description>A lot of info is provided here&#xA;_start is called by most c,c++ programs before main.</description>
      <content:encoded><![CDATA[<p>A lot of info is provided <a href="https://embeddedartistry.com/blog/2019/04/08/a-general-overview-of-what-happens-before-main/">here</a></p>
<p><code>_start</code> is called by most c,c++ programs before <code>main</code>.</p>
<p>It is the linker that controls the programs entry point.</p>
<p><code>_start</code> is provided by <code>libc</code>.
<code>_start</code> is often written in assembly and is provided by the object file <code>crt0.o</code></p>
<p>C, C++ standards do not specify <code>_start</code> behaviour. They mostly specify what conditions must exist before <code>main</code> excecution begins.</p>
<p>TODO: What does <code>_start</code> do ?</p>
<p>Where is <code>_start</code> located ?
Most OSes or platforms provide <code>_start</code> in a <code>crt0.o</code> file.</p>
<p>A series of <code>crt0...n.o</code> files in each platform (OS, barebone hardware etc) provide this functionality.</p>
<p>What does <code>_start</code> do ?
All of the below, but not just limited to this :</p>
<ol>
<li>Configuring registers</li>
<li>Initializing external memory</li>
<li>enabling caches</li>
<li>MMU</li>
<li>stack initialization</li>
<li>stack alignment (16 bit address at start of execution in case of x86-64)</li>
<li>Frame Pointer initialization</li>
<li>C/C++ runtime setup</li>
<li>Jumping to main</li>
<li>Exiting the program once main finishes</li>
</ol>
<p><strong>Note</strong>: In Linux (Ubuntu 19.10, gcc 9.2.1), initialization starts with <code>_init</code> that is part of the final executable (questioin, does it come from <code>crt0.o</code>. Also linux doesn&rsquo;t seem to have any <code>crt0.o</code> file at all ). I followed the tutorial <a href="https://0xax.gitbooks.io/linux-insides/content/Misc/linux-misc-3.html">here</a></p>
<p>Linux + glibc defines _start in <code>crt1.o</code> under /usr/lib/x86_64</p>
<p>After following tutorial ^ , you will realize that crt1.o , crti.o, crtn.o define a lot of program startup stuff. WHy does it do so ? Can we directly execute our program from main ?
Follow this tutorial
<a href="http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html</a></p>
<p><code>objdump -R</code> shows relocation entries only on compiled dynanic object files (ie, files linked together)</p>
]]></content:encoded>
    </item>
    <item>
      <title>CLI tools for quick perf. measurement</title>
      <link>https://gowind.github.io/post/cli_tools_for_perf_measuring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/cli_tools_for_perf_measuring/</guid>
      <description>Some tools I use I have been moving away from the venerable time utlity to benchmark short running code.</description>
      <content:encoded><![CDATA[<h1 id="some-tools-i-use">Some tools I use</h1>
<p>I have been moving away from the venerable <code>time</code> utlity to benchmark short running code.</p>
<p>Here are some of the tools I have using</p>
<h3 id="hyperfine">Hyperfine</h3>
<p><a href="https://github.com/sharkdp/hyperfine">Hyperfine</a> has intuitive CLI options to quickly do multiple runs of a program
along with options to run warmups before executing the program and reports the mean and deviation of the wallclock run times of the program</p>
<h3 id="flamegraph-rs">flamegraph-rs</h3>
<p><a href="https://www.brendangregg.com/flamegraphs.html">Flamegraphs</a> are a proven way to profile programs to identify bottlenecks in the code. <a href="https://github.com/flamegraph-rs/flamegraph">flamegraph-rs</a> makes it very easy to quickly obtain a flamegraph of the program&rsquo;s execution.</p>
<h3 id="termshot">Termshot</h3>
<p>This is not a profiling/benchmarking tool, but <a href="https://github.com/homeport/termshot">termshot</a> takes a screenshot of your terminal, that you can use for posting to social media / forums etc</p>
]]></content:encoded>
    </item>
    <item>
      <title>Compiling C code with Zig</title>
      <link>https://gowind.github.io/post/compiling_c_code_with_zig/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/compiling_c_code_with_zig/</guid>
      <description>This doesn&amp;rsquo;t cover cross-compiling to other targets. We will only focus on creating libraries and executables on the same platform.</description>
      <content:encoded><![CDATA[<h3 id="this-doesnt-cover-cross-compiling-to-other-targets">This doesn&rsquo;t cover cross-compiling to other targets.</h3>
<p>We will only focus on creating libraries and executables on the same platform.</p>
<p>This small intro covers creating</p>
<ol>
<li>A static library</li>
<li>A shared (dynamic) library</li>
<li>and an executable</li>
</ol>
<p>I wrote a build file in Zig to built the <code>whisper</code> executable in the <code>whisper.cpp</code> repo by Greg Gregarinov. This project is a good intro to compiling C/C++ code with Zig.
<code>whisper.cpp</code> involves using</p>
<ol>
<li>ggml - A c library for tensor/matrix operations. This library consists of a <code>.c</code> file and a corresponding header file.</li>
<li>whisper.cpp - A cpp library that can be used for audio transcription</li>
<li>A main file from <code>main.cpp</code> and <code>common.cpp</code> that uses the previously built <code>whisper.cpp</code></li>
</ol>
<p><code>ggml</code> performs a lot of intensive math operations, so on each platform we will have to leverage the platform&rsquo;s SIMD intrinsics or special Matrix libraries if available.</p>
<p>The <code>builtin</code> package/library in Zig provides information about the system the program is running in via <a href="https://github.com/ziglang/zig/blob/8d6336420b937075e3363f9548adb0092af7f819/src/Compilation.zig#L5083">this</a> fn , which is called by <a href="https://github.com/ziglang/zig/blob/8d6336420b937075e3363f9548adb0092af7f819/src/Compilation.zig#L3500">this</a> in the <a href="https://github.com/ziglang/zig/blob/8d6336420b937075e3363f9548adb0092af7f819/src/Compilation.zig#L3008">main</a> thread, when we call zig build or <code>zig build-exe</code></p>
<ol>
<li>Based on the <code>cpu</code> of the platform (<code>builtin.cpu</code>) we decide the C and the C++ flags we need to pass to the compiler</li>
<li>If an accelerator has to be used (Accelerate in macos or OpenBLAS) we also set the corresponding flags. The usage of these accelerators is controlled by passing an option to <code>zig build</code> using <code>zig build -Doption=val</code>. In our file, for example, setting <code>-Dmacos_accelerate=true</code> enables the usage of the AI accelerator in macos.</li>
</ol>
<p>We then build a bunch of intermediate object files that will be linked into the static, dynamic and main executables.</p>





<pre tabindex="0"><code>    const ggmlObject = b.addObject(.{
        .name = &#34;ggml.o&#34;,
        .target = target,
        .optimize = optimize,
    });
    ggmlObject.addIncludePath(&#34;./&#34;); 
ggmlObject.addIncludePath(&#34;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include&#34;);
    ggmlObject.addCSourceFiles(&amp;.{
        &#34;ggml.c&#34;,
    }, c_flags.items);</code></pre><p>This for example, builds the <code>ggml</code> object file from our ggml source code with the C flags we have defined.
We then build a <code>whisper</code> object and then use them both in each of the shared library, static library and the executable.</p>
<p>We can only install artifacts that are either a shared,static library or an executable file. We <strong>cannot <code>install</code> any intermediate object files that were created by Zig</strong></p>
<p>To procedurally instruct Zig build to install these files, using <code>std.build.Builder.installArtifact</code></p>





<pre tabindex="0"><code>var lib_dynamic = b.addSharedLibrary(.{ .name = &#34;whisper&#34;, .optimize = optimize, .target = target });
    lib_dynamic.addObject(ggmlObject);
    lib_dynamic.addObject(whisperObject);
    b.installArtifact(lib_dynamic);
    b.installArtifact(lib_static_library);
    b.installArtifact(mainFile);</code></pre>




<pre tabindex="0"><code>const std = @import(&#34;std&#34;);
const builtin = @import(&#34;builtin&#34;);

pub fn build(b: *std.build.Builder) !void {
    var basic_cflags = [_][]const u8{ &#34;-I.&#34;, &#34;-O3&#34;, &#34;-std=c11&#34;, &#34;-fPIC&#34;, &#34;-pthread&#34; };
    var basic_cppflags = .{ &#34;-I.&#34;, &#34;-I./examples&#34;, &#34;-O3&#34;, &#34;-std=c++11&#34;, &#34;-fPIC&#34;, &#34;-pthread&#34; };
    var alloc = b.allocator;
    var c_flags = std.ArrayList([]const u8).init(alloc);
    var cpp_flags = std.ArrayList([]const u8).init(alloc);
    defer c_flags.deinit();
    defer cpp_flags.deinit();
    try c_flags.appendSlice(&amp;basic_cflags);
    try cpp_flags.appendSlice(&amp;basic_cppflags);

    const target = b.standardTargetOptions(.{});

    var target_cpu = builtin.cpu;
    var all_features = target_cpu.features;
    if (target_cpu.arch.isX86()) {
        const x86_target = std.Target.x86;
        if (x86_target.featureSetHas(all_features, x86_target.Feature.f16c)) {
            try c_flags.append(&#34;-mf16c&#34;);
        }
        if (x86_target.featureSetHas(all_features, x86_target.Feature.fma)) {
            try c_flags.append(&#34;-mfma&#34;);
        }

        if (x86_target.featureSetHas(all_features, x86_target.Feature.avx)) {
            try c_flags.append(&#34;-mavx&#34;);
        }

        if (x86_target.featureSetHas(all_features, x86_target.Feature.avx2)) {
            try c_flags.append(&#34;-mavx2&#34;);
        }

        if (x86_target.featureSetHas(all_features, x86_target.Feature.sse3)) {
            try c_flags.append(&#34;-msse3&#34;);
        }
    }
    if (target_cpu.arch.isPPC64()) {
        const ppc64_target = std.Target.powerpc;
        if (ppc64_target.featureSetHas(all_features, ppc64_target.Feature.power9_vector)) {
            try c_flags.append(&#34;-mpower9-vector&#34;);
        }
        try cpp_flags.append(&#34;-std=c++23&#34;);
        try cpp_flags.append(&#34;-DGGML_BIG_ENDIAN&#34;);
    }

    var maybe_use_accelerate = b.option(bool, &#34;macos_accelerate&#34;, &#34;use the accelerate framework in macOS (if available) for ML models&#34;);
    if (maybe_use_accelerate) |use_accelerate| {
        if (use_accelerate) {
            try c_flags.append(&#34;-DGGML_USE_ACCELERATE&#34;);
        }
    }

    var maybe_use_openblas = b.option(bool, &#34;use_openblas&#34;, &#34;use open BLAS when available&#34;);
    if (maybe_use_openblas) |use_openblas| {
        if (use_openblas) {
            try c_flags.appendSlice(&amp;.{ &#34;-DGGML_USE_OPENBLAS&#34;, &#34;-I/usr/local/include/openblas&#34; });
        }
    }
    var maybe_use_gprof = b.option(bool, &#34;gprof&#34;, &#34;use gnu prof&#34;);
    if (maybe_use_gprof) |use_gprof| {
        if (use_gprof) {
            try c_flags.append(&#34;-pg&#34;);
            try cpp_flags.append(&#34;-pg&#34;);
        }
    }

    if (!target_cpu.arch.isAARCH64()) {
        try c_flags.append(&#34;-mcpu=native&#34;);
        try cpp_flags.append(&#34;-mcpu=native&#34;);
    }

    if (target_cpu.arch.isARM()) {
        if (!std.mem.startsWith(u8, target_cpu.model.name, &#34;armv6&#34;)) {
            try c_flags.appendSlice(&amp;.{ &#34;-mfpu=neon-fp-armv8&#34;, &#34;-mfp16-format=ieee&#34;, &#34;-mno-unaligned-access&#34; });
        }
        if (!std.mem.startsWith(u8, target_cpu.model.name, &#34;armv7&#34;)) {
            try c_flags.appendSlice(&amp;.{ &#34;-mfpu=neon-fp-armv8&#34;, &#34;-mfp16-format=ieee&#34;, &#34;-mno-unaligned-access&#34;, &#34;-funsafe-math-optimizations&#34; });
        }

        if (!std.mem.startsWith(u8, target_cpu.model.name, &#34;armv8&#34;)) {
            try c_flags.appendSlice(&amp;.{ &#34;-mfp16-format=ieee&#34;, &#34;-mno-unaligned-access&#34; });
        }
    }
    //TODO: Flags for accelerate, aarch64, arm and rpi
    const optimize = b.standardOptimizeOption(.{});
    const ggmlObject = b.addObject(.{
        .name = &#34;ggml.o&#34;,
        .target = target,
        .optimize = optimize,
    });
    ggmlObject.addIncludePath(&#34;./&#34;);
    ggmlObject.addIncludePath(&#34;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include&#34;);
    ggmlObject.addCSourceFiles(&amp;.{
        &#34;ggml.c&#34;,
    }, c_flags.items);
    if (maybe_use_accelerate) |use_accelerate| {
        if (use_accelerate) {
            ggmlObject.linkFramework(&#34;Accelerate&#34;);
        }
    }
    if (maybe_use_openblas) |open_blas| {
        if (open_blas) {
            ggmlObject.linkSystemLibraryName(&#34;openblas&#34;);
        }
    }
    ggmlObject.linkLibC();

    const whisperObject = b.addObject(.{ .name = &#34;whisper.o&#34;, .target = target, .optimize = optimize });
    whisperObject.addIncludePath(&#34;./&#34;);
    whisperObject.addIncludePath(&#34;./examples&#34;);
    whisperObject.addCSourceFile(&#34;whisper.cpp&#34;, cpp_flags.items);
    whisperObject.linkLibCpp();

    // zig automatically adds `lib` prefix and a `.a` suffix
    var lib_static_library = b.addStaticLibrary(.{ .name = &#34;whisper&#34;, .optimize = optimize, .target = target });
    lib_static_library.addObject(ggmlObject);
    lib_static_library.addObject(whisperObject);

    var lib_dynamic = b.addSharedLibrary(.{ .name = &#34;whisper&#34;, .optimize = optimize, .target = target });
    lib_dynamic.addObject(ggmlObject);
    lib_dynamic.addObject(whisperObject);
    b.installArtifact(lib_dynamic);
    b.installArtifact(lib_static_library);
    var mainFile = b.addExecutable(.{ .name = &#34;main&#34; });
    mainFile.addIncludePath(&#34;./&#34;);
    mainFile.addIncludePath(&#34;./examples&#34;);
    mainFile.addCSourceFiles(&amp;.{ &#34;examples/main/main.cpp&#34;, &#34;examples/common.cpp&#34; }, cpp_flags.items);
    mainFile.addObject(whisperObject);
    mainFile.addObject(ggmlObject);
    if (maybe_use_accelerate) |use_accelerate| {
        if (use_accelerate) {
            mainFile.linkFramework(&#34;Accelerate&#34;);
        }
    }

    b.installArtifact(mainFile);
}</code></pre><h3 id="alternate-ways-of-setting-c-macros">Alternate ways of setting C macros</h3>
<h5 id="in-zig-code">In Zig Code:</h5>
<p>Setting C preprocess macros with @cDefine or <code>-Dmacro=value</code> during compile time.
This compile time macro can be set via <code>build/build-exe -Dmacro=val</code> or programatically
object.addCSourceFiles(&ldquo;file&rdquo;, c_cpp_flags);</p>
]]></content:encoded>
    </item>
    <item>
      <title>ELF and Loaders</title>
      <link>https://gowind.github.io/post/elfs_and_loaders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/elfs_and_loaders/</guid>
      <description>A dynamic loader is an executable ? that is used to load a program so that the program&amp;rsquo;s main can start executing.</description>
      <content:encoded><![CDATA[<p>A dynamic loader is an executable ? that is used to load a program so that the program&rsquo;s <code>main</code> can start executing.
For some details, check out t he section on <code>ELFs</code> and <code>System</code> <a href="https://en.wikipedia.org/wiki/Dynamic_linker#Unix-like_systems_using_ELF,_and_Darwin-based_systems">here</a>, and <a href="https://greek0.net/elf.html">here</a> (<a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/#why-learn-the-details-of-elf">https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/#why-learn-the-details-of-elf</a>)
and <a href="https://unix.stackexchange.com/questions/467999/how-to-run-programs-with-ld-linux-so">here</a></p>
<p>Dynamically linked executables</p>
<p>Basically, dynamically linked executables are interpreted. An interpreter has to read the contents of the elf, <code>mmap</code> the sections in the binary to the RAM before executing the <code>main</code> section of the executable.
Each <code>executable</code> hardcodes the path to the interpreter in the binary, under the <code>INTERP</code> entry, under the <code>dynamic</code> section of the library.</p>
<p>This <code>interpreter</code> is the linux <code>ld</code> libary (<code>/usr/lib/ld-linux-x86-64.so.2</code>, etc)</p>
<p>Statically linked executables</p>
<p>Staticalyl linked executables do not link to <code>libc</code> statically. When run, they do not have an <code>mmap</code> section loading <code>libc</code> in their runtime memory.
To generate a statically linked executable , look in <a href="https://www.systutorials.com/how-to-statically-link-c-and-c-programs-on-linux-with-gcc/">here</a></p>
<p><code>dlopen</code>
<a href="https://linux.die.net/man/3/dlopen">https://linux.die.net/man/3/dlopen</a> - open dll file</p>
<h2 id="understanding-elfs">Understanding ELFs</h2>
<p>A lot of it is documented in [these](https://stffrdh q 	rn.github.io/hardware/embedded/openrisc/2019/11/29/relocs.html) posts.</p>
<p><a href="https://www.altoros.com/blog/golang-internals-part-5-the-runtime-bootstrap-process/">https://www.altoros.com/blog/golang-internals-part-5-the-runtime-bootstrap-process/</a> shows how to start debugging ELF&rsquo;s. <code>objdump -f elf-file</code> shows the <code>start address</code> of Execution in an ELF file.</p>
<p><code>BFD</code> - binary format description  (+ library) is an abstraction library to work on object files, irrespective of  the object file format.
<code>BFD</code> is used by readelf.</p>
<p><a href="https://zig.news/gw1/learning-about-elf-with-zig-22eb">https://zig.news/gw1/learning-about-elf-with-zig-22eb</a>
Is a blog post on learning about ELF&rsquo;s with Zig.</p>
]]></content:encoded>
    </item>
    <item>
      <title>ELF relocations</title>
      <link>https://gowind.github.io/post/elf_relocations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/elf_relocations/</guid>
      <description>Let us try to understand what are relocations and how they happen.&#xA;When we compile our code , there will be certain &amp;ldquo;things&amp;rdquo; that we do not know where they exist.</description>
      <content:encoded><![CDATA[<p>Let us try to understand what are relocations and how they happen.</p>
<p>When we compile our code , there will be certain &ldquo;things&rdquo; that we do not know where they exist. For example , in the following snippet, we do not know where <code>printf</code> is coming from, but we just assume that <code>printf</code> is defined somewhere and is available when we execute our code.</p>
<p>Here is a C file with a <code>main</code> function:</p>





<pre tabindex="0"><code>#include&lt;stdio.h&gt;
//#include &#34;lib.h&#34;

int main(int argc, char** argv) {
  printf(&#34;factorial of 5 is %d\n&#34;, factorial(5));
  return 0;
}</code></pre><p>I haven&rsquo;t defined the <code>factorial</code> function yet as well, so if I try to compile it into an executable, it will fail:</p>





<pre tabindex="0"><code>gcc main.c -o main                              
main.c: In function ‘main’:
main.c:5:36: warning: implicit declaration of function ‘factorial’ [-Wimplicit-function-declaration]
    5 |   printf(&#34;factorial of 5 is %d\n&#34;, factorial(5));
      |                                    ^~~~~~~~~
/usr/bin/ld: /tmp/ccbCLA27.o: in function `main&#39;:
main.c:(.text+0x1e): undefined reference to `factorial&#39;
collect2: error: ld returned 1 exit status</code></pre><p><code>collect2</code> is the GNU <code>linker</code> that will link object files into an Executable</p>
<p>We can compile our C file into a relocatable object file (<code>.o</code>).
This relocatable can be linked with other libraries or relocatables into an EXE and contains <code>relocatable</code> sections (<code>.rela.</code>) that say which symbols should be relocated.</p>
<p><code>gcc -c main.c</code></p>
<p><code>readelf -h main.c</code>  gives the following output</p>





<pre tabindex="0"><code>ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          888 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         14
  Section header string table index: 13</code></pre><p>(Question to self: How does the linker know which section defines the <code>main</code> function, and set it as the starting point of the executable)</p>
<p>Let us look at the symbols in our Relocatable file</p>
<p><code>readelf --symbols main.o</code></p>





<pre tabindex="0"><code>Symbol table &#39;.symtab&#39; contains 14 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 
    10: 0000000000000000    60 FUNC    GLOBAL DEFAULT    1 main
    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND factorial
    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</code></pre><p>While we use <code>factorial</code>  and <code>printf</code> even though we haven&rsquo;t defined (or declared) them, the symbol table in our <code>main.o</code>  contains entries for them.</p>
<p><code>$ readelf --relocs main.o</code></p>





<pre tabindex="0"><code>Relocation section &#39;.rela.text&#39; at offset 0x2a0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000001e  000c00000004 R_X86_64_PLT32    0000000000000000 factorial - 4
000000000027  000500000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000031  000d00000004 R_X86_64_PLT32    0000000000000000 printf - 4

Relocation section &#39;.rela.eh_frame&#39; at offset 0x2e8 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</code></pre><p>Our relocations are of different types. We can be relocating calls to functions (R_X86_64_PLT32) or to data (R_X86_64_PC32).</p>
<p>The <code>offset</code> of the relocation tells us where in our code the relocation exists. Let us take a look at it using <code>objdump</code></p>
<p><code>objdump -s main.o</code></p>





<pre tabindex="0"><code>0000000000000000 &lt;main&gt;:
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
   c:   89 7d fc                mov    %edi,-0x4(%rbp)
   f:   48 89 75 f0             mov    %rsi,-0x10(%rbp)
  13:   bf 05 00 00 00          mov    $0x5,%edi
  18:   b8 00 00 00 00          mov    $0x0,%eax
  1d:   e8 00 00 00 00          callq  22 &lt;main+0x22&gt;
  22:   89 c6                   mov    %eax,%esi
  24:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 2b &lt;main+0x2b&gt;
  2b:   b8 00 00 00 00          mov    $0x0,%eax
  30:   e8 00 00 00 00          callq  35 &lt;main+0x35&gt;
  35:   b8 00 00 00 00          mov    $0x0,%eax
  3a:   c9                      leaveq 
  3b:   c3                      retq</code></pre><p>Looks scary ! (but pretty understandable)</p>
<p>The first relocation <code>001e</code>  points to a value of <code>00 00 00 00</code>. This comes after an <code>e8</code> value,  which is the opcode for a <code>callq</code> instruction. What is being called ? <code>00</code> ?</p>
<p>In our source code, we call 2 functions: <code>printf</code> and <code>factorial</code>.
`printf(&ldquo;factorial of 5 is %d\n&rdquo;, factorial(5));</p>
<p>We call <code>factorial</code> with an argument of <code>5</code> and then <code>printf</code> with 2 arguments : a format string, and the result of the call of <code>factorial(5)</code>. The first <code>callq</code> is the <code>factorial(5)</code> and the second <code>callq</code> at offset <code>30</code> is to <code>printf</code>.</p>
<p>We also see that we pass a <code>5</code> to <code>factorial()</code> by setting <code>edi</code> to <code>5</code>  (for more info on how parameters to functions are passed, read the [[From Source Code to Hello World/X86 calling convention]] page)</p>
<p>We do not know the address where <code>printf</code> or <code>factorial</code> will be located in memory, so <code>gcc</code> simply sets the address of the <code>call</code> instruction to <code>00 00 00 00</code> and emits a <code>relocation</code> entry in the object file. This will tell the linker when it is generating the executable, to somehow generate an address to <code>factorial</code> or redirect the callq to a location, which then knows how to call <code>factorial</code>.
(Note to self: is this the <code>PLT</code>, aka <code>Procedure Link Table</code>  ?)</p>
<p>Lets implement factorial in a <code>lib.c</code> file and then link it with our executable.</p>





<pre tabindex="0"><code>$ cat lib.c  
int factorial(int base) {
  int res = 1;
  int i = 1;
  if(base == 0) {
    return 1;
  }
  while(i &lt;= base) {
    res *= i;
    i += 1;
  }
  return res;
}</code></pre><p><code>gcc lib.c main.c -o main</code></p>





<pre tabindex="0"><code>000000003db8  000000000008 R_X86_64_RELATIVE                    1140
000000003dc0  000000000008 R_X86_64_RELATIVE                    1100
000000004008  000000000008 R_X86_64_RELATIVE                    4008
000000003fd8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0
000000003fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
000000003fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
000000003ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0
000000003ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0

Relocation section &#39;.rela.plt&#39; at offset 0x5e8 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000003fd0  000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0</code></pre><p>As you can see, <code>factorial</code> is no longer a relocatable symbol as the compiler knows where to find it and then generates an address to jump to, when <code>factorial</code> is to be called.
We can verify it in our <code>objdump</code> output.</p>





<pre tabindex="0"><code>    119d:       bf 05 00 00 00          mov    $0x5,%edi
    11a2:       b8 00 00 00 00          mov    $0x0,%eax
    11a7:       e8 9d ff ff ff          callq  1149 &lt;factorial&gt;</code></pre>




<pre tabindex="0"><code>0000000000001149 &lt;factorial&gt;:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp</code></pre><p>What about <code>printf</code> ? How do we call printf when we really don&rsquo;t know its address ?
That is the topic of the next section : <code>PLTs</code> ,a.ka Procedure Link Tables.</p>
<h5 id="footnote">Footnote</h5>
<p>Each relocation section denotes which section will be updated.
For example: <code>.rela.text</code> means these relocations apply to the <code>.text</code> section.
Similar <code>.rela.plt</code> means this relocation will apply to the <code>.plt</code> section.</p>
]]></content:encoded>
    </item>
    <item>
      <title>ELF Sections</title>
      <link>https://gowind.github.io/post/elf_sections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/elf_sections/</guid>
      <description>The file view of an ELF is sections - parts that take part in different usecases.</description>
      <content:encoded><![CDATA[<p>The <code>file</code> view of an ELF is sections - parts that take part in different usecases.
Sections are defined by Section Headers.
Examples of sections are:
<code>.text</code> : assembly instructions
<code>.rodata</code> : Read-only data
<code>.bss</code>: Read only initialized data</p>
<h2 id="section-headers">Section Headers</h2>
<p>Sections, their types and permissions are defined by a <code>Section Header</code>.
Section Headers are stored as an array in the ELF, starting at offset <code>e_shoff</code>  (which is defined in the ELF Header)</p>
<p><code>readelf -S /path/to/elffile</code>  lists the sections in the Header file</p>
<p>How do we know what the name of a section is ? Each section holds a field: <code>sh_name</code>, that is an offset into the <code>String Table</code></p>
<h5 id="and-what-is-a-string-table-">And what is a <code>String Table</code> ?</h5>
<p>A <code>STRTAB</code> is itself a section in an ELF. It is a linear array, where the first byte is <code>0x00</code> followed by NULL terminated strings, ending in an <code>0x00</code>.  Each string is used for either naming <code>symbols</code> (more on that later) or sections or other purposes (debugging, maybe ?).</p>
<h4 id="convenience">Convenience</h4>
<p>To make computation easy, we can use the following fields in the ELF header, to peek at the String Table.</p>
<ol>
<li><code>e_shoff</code>  : offset into  file to the section Headers array.</li>
<li><code>e_shentsize</code> : Size of each section header.</li>
<li><code>e_shstrndx</code>  points to the index of the STRTAB in the Section Header array.</li>
<li>. String Table Header offset = File[<code>e_shoff</code> + <code>e_shentsize</code> * <code>e_shstrndx</code>]</li>
<li>
<ol start="4">
<li>Actual String Table = (String Table Header).<code>sh_offset</code></li>
</ol>
</li>
</ol>
<h4 id="miscellaneous-sections">Miscellaneous Sections.</h4>
<p><code>.eh_frame</code> is for Exception Handling frames (for languages that support exceptions , such as C++)
<a href="https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/ehframechpt.html">https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/ehframechpt.html</a>
Can be disabled with <code>-fno-asynchronous-unwind-tables</code> (<a href="https://stackoverflow.com/questions/26300819/why-gcc-compiled-c-program-needs-eh-frame-section">https://stackoverflow.com/questions/26300819/why-gcc-compiled-c-program-needs-eh-frame-section</a>)
DWARF debugging symbols (<code>gcc -g</code>) are stored in <code>.debug_frame</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>GOT, `__stubs` and Linking</title>
      <link>https://gowind.github.io/post/got_stubs_and_linking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/got_stubs_and_linking/</guid>
      <description>This is a version of the Procedure Link Tables article I wrote for x86_64, but for macOS and aarch64.</description>
      <content:encoded><![CDATA[<h4 id="this-is-a-version-of-the-procedure-link-tables-article-i-wrote-for-x86_64-but-for-macos-and-aarch64">This is a version of the Procedure Link Tables article I wrote for x86_64, but for macOS and aarch64.</h4>
<p>Lets start with a simple program</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-main.c" data-lang="main.c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">moorthySir</span>(<span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> blarty <span style="color:#f92672">=</span> <span style="color:#ae81ff">46</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">malarchy</span>(<span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> martyMcBoe;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> martyMcBoe;
</span></span><span style="display:flex;"><span>  a <span style="color:#f92672">+=</span> blarty;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, a);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> mal <span style="color:#f92672">=</span> <span style="color:#a6e22e">malarchy</span>(<span style="color:#ae81ff">683</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, mal);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">moorthySir</span>(<span style="color:#ae81ff">346</span>));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>We have a small helper <code>shared</code> library</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-helper.c" data-lang="helper.c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> martyMcBoe <span style="color:#f92672">=</span> <span style="color:#ae81ff">895</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">malarchy</span>(<span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> b <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p><code>gcc -c -fpic helper.c</code>
<code>gcc -shared -o libhelper.so helper.o</code></p>
<p>Our <code>main</code> depends on functionality from <code>libhelper.so</code> (a global variable and a function). What problems are we solving when linking them together ?</p>
<ol>
<li>main.c might be compiled with other <code>.o</code> (object files) to create the final executable. If we rely on an hardcoded address for <code>blarty</code>, when we create the final executables, this address will be invalid. This is because other <code>.o</code> or libraries will also have statically initialized data and in the final executable, we will have only one <code>.data</code> section that concatenates all the <code>.data</code> sections of the object files.</li>
<li>We declare that we depend or need a global variable <code>martyMcBoe</code> and a fn <code>malarychy</code> (and <code>printf</code>). We don&rsquo;t know which other object file or shared library will provide it, just that we need an <code>int</code> martyMcBoe and a <code>int -&gt; int fn</code> named <code>malarchy</code>.</li>
</ol>
<p>So how do we figure out the right addresses to load our global variables from, or the right addresses to jump to ?
Enter <code>relocations</code>.</p>
<p>Now let us look at relocations in the file.</p>





<pre tabindex="0"><code>objdump --reloc  main.o

main.o:	file format mach-o arm64

RELOCATION RECORDS FOR [__text]:
OFFSET           TYPE                     VALUE
00000000000000b8 ARM64_RELOC_BRANCH26     _printf
00000000000000a0 ARM64_RELOC_BRANCH26     _moorthySir
0000000000000098 ARM64_RELOC_BRANCH26     _printf
0000000000000078 ARM64_RELOC_BRANCH26     _malarchy
0000000000000070 ARM64_RELOC_BRANCH26     _printf
0000000000000068 ARM64_RELOC_PAGEOFF12    l_.str
0000000000000064 ARM64_RELOC_PAGE21       l_.str
0000000000000044 ARM64_RELOC_PAGEOFF12    _blarty
0000000000000040 ARM64_RELOC_PAGE21       _blarty
0000000000000034 ARM64_RELOC_GOT_LOAD_PAGEOFF12 _martyMcBoe
0000000000000030 ARM64_RELOC_GOT_LOAD_PAGE21 _martyMcBoe</code></pre><p>The <code>offset</code> of a relocation depends on what kind of file we are looking at. In an object file, the <code>offset</code> is an offset into the <code>_text</code> section of the file and indicates what must be changed.
For example <code>ARM64_RELOC_BRANCH26</code> _printf indicates that at an offset 70 into the file, we should do a relocation so that the code there can call the fn printf.</p>
<p>We can see that at 70 offset into <code>_text</code>, there is indeed a <code>bl</code> instructions there (similar to call/jmp in x86)</p>
<p>[Side Note] Relocations in macOS for global variables is a little tricky, which is why you will see 2 relocations for each global variable, such as <code>_martyMcBoe</code> (in macOS, all names of C fns or variables is prefixed with an `_)</p>
<p>There is also another problem with aarch64. All instructions (including operands) in aarch64 are 32 bits wide. How do you then jump to another 64-bit address ?</p>
<p>This is how the linker does this on aarch64:</p>
<ol>
<li>Provide a 26-bit (+/- 128 MB) offset relative to the current instruction pointer (PC) as arg. to the <code>bl</code> instruction.</li>
<li>control jumps to that addres. There, we load the actual address of <code>printf</code> from a special location.</li>
<li>Once the actual address of <code>printf</code> is in a register, we then use the <code>br</code> instruction to jump to the 64-bit address in the register</li>
</ol>
<p>Lets now compile our object file into an executable with the shared library
<code>gcc -L. -g -o test main.c -lhelper</code></p>
<p><code>test</code> is the name of our executable. We can verify that all the relocations we needed are patched</p>





<pre tabindex="0"><code>
100003f88: 08 00 00 94 	bl	0x100003fa8 &lt;_printf+0x100003fa8&gt;
100003f8c: e0 13 40 b9 	ldr	w0, [sp, #16]
100003f90: fd 7b 42 a9 	ldp	x29, x30, [sp, #32]
100003f94: ff c3 00 91 	add	sp, sp, #48
100003f98: c0 03 5f d6 	ret</code></pre><p>Our executable first <code>trampolines</code> into a <code>__stubs</code> section. From there it knows how to call into <code>printf</code></p>
<ol>
<li>Jump into the the trampoline in <code>__stubs</code>.</li>
<li>Load the address of <code>printf</code> from the <code>GOT</code> (Global Offset Table) into <code>x16</code>.</li>
<li>Jump to <code>printf</code>.</li>
</ol>





<pre tabindex="0"><code>
Disassembly of section __TEXT,__stubs:

0000000100003f9c &lt;__stubs&gt;:
100003f9c: 10 00 00 b0 	adrp	x16, 0x100004000 &lt;__stubs+0x4&gt;
100003fa0: 10 02 40 f9 	ldr	x16, [x16]
100003fa4: 00 02 1f d6 	br	x16
100003fa8: 10 00 00 b0 	adrp	x16, 0x100004000 &lt;__stubs+0x10&gt;
100003fac: 10 0a 40 f9 	ldr	x16, [x16, #16]
100003fb0: 00 02 1f d6 	br	x16</code></pre><p>We can verify that the <code>GOT</code> is at the address <code>0x100004000</code></p>





<pre tabindex="0"><code>objdump -s -j __got test

test:	file format mach-o arm64
Contents of section __DATA_CONST,__got:
 100004000 00000000 00001080 01000000 00001080  ................
 100004010 02000000 00000080                    ........</code></pre><p>The dynamic linker knows which shared libraries (like <code>libc</code> ) our executable needs and loads the shared libraries into memory and maps the address of fns we need into the GOT.</p>
<p>Running this program in the debugger, we see that from <code>__stubs</code> , we can jump into <code>printf</code> without knowing the exact address of <code>printf</code></p>





<pre tabindex="0"><code>test`printf:
-&gt;  0x100003fb0 &lt;+8&gt;: br     x16
    0x100003fb4:      .long  0x000a6425                ; unknown opcode
    0x100003fb8:      udf    #0x1
    0x100003fbc:      udf    #0x1c
Target 0: (test) stopped.
(lldb) register read x16
     x16 = 0x000000018c7351d0  libsystem_c.dylib`printf
(lldb) disassemble
test`printf:
    0x100003fa8 &lt;+0&gt;: adrp   x16, 1
    0x100003fac &lt;+4&gt;: ldr    x16, [x16, #0x10]
-&gt;  0x100003fb0 &lt;+8&gt;: br     x16
(lldb) image lookup -n printf
1 match found in /usr/lib/system/libsystem_c.dylib:
        Address: libsystem_c.dylib[0x00000001802bd1d0] (libsystem_c.dylib.__TEXT.__text + 192556)
        Summary: libsystem_c.dylib`printf</code></pre>]]></content:encoded>
    </item>
    <item>
      <title>Introduction to ELF</title>
      <link>https://gowind.github.io/post/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/introduction/</guid>
      <description>The best introduction is the actual ELF description document : http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf However, it is kinda hard to read from from scratch and definitely boring.</description>
      <content:encoded><![CDATA[<p>The best introduction is the actual ELF description document : <a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf">http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf</a>
However, it is kinda hard to read from from scratch and definitely boring.
Not to worry ! I will doing most of the hardwork and spitting out useful information step by step as we go along.</p>
<h3 id="what-is-an-elf-">What is an ELF ?</h3>
<p>ELF - Executable and Linkable Format. As the name says: an ELF defines files that are either linked together into an Executable or an Executable that can be run by the operating system (via a system call such as  <code>execve</code> )</p>
<p>ELF files fall into one of 3 types</p>
<ol>
<li>Relocatable file - A file that is linked with other files to form an executable</li>
<li>Executable file - A file that can be run by the operating system</li>
<li>Shared Object file - A file that is loaded into a process at runtime (after an OS loads the executable). Shared object files provide common functionality (like <code>printf</code>) that need not be copied into every single executable.</li>
</ol>
<p>Since an ELF can be either linked into other files or run, it contains information about linking and loading/Executing the file.This information is provided via 2 parts of the ELF - <code>Program headers</code> and <code>Sections</code></p>
<p>All ELFs contain an ELF Header that provides information the ELF : Is it an executable , a relocatable file, or a shared object file ? What architecture is this executable for ? What is the address from which this executable must be run  ?</p>
<p>If the ELF is an executable , the <strong>Program Headers</strong> tell the Operating system what <code>virtual</code> address the program&rsquo;s code and data should be loaded into  and what additional memory addresses has to be allocated to the program etc.</p>
<p>In case of dynamically linked executables (more on that later), it also points to the location of the interpreter that must &ldquo;interpret&rdquo; this executable , so that it can be run.</p>
<p>Lets look at a sample ELF header.
In order to simplify things, I am going to use a statically compiled binary using <code>Zig</code>. I will explain what I mean when I say <code>statically</code> compiled.</p>
<p>Lets take a small program that basically does nothing.</p>





<pre tabindex="0"><code>fn factorial(x: u32) u32 {
    if (x &lt;= 1) return 1;
    var i: u32 = 1;
    var res: u32 = 1;
    while (i &lt;= x) : (i += 1) {
        res *= i;
    }
    return res;
}

pub fn main() void {
    _ = factorial(4);
}</code></pre><p>This program computes a factorial (but doesn&rsquo;t print it). I left out printing the result, as it would have resulted in bloating our executable and making it too hard to understand how an ELF works.</p>
<p>Build an executable out of this using:
<code> zig build-exe -O ReleaseSmall -fsingle-threaded zig_factorial.zig</code>
This should net us an executable named <code>zig_factorial</code>.
For now , ignore the <code>ReleaseSmall</code> and <code>single-threaded</code> flags to the compiler. This is just to make our binary small enough and readable for learning purposes.</p>
<h4 id="tool-1-readelf-is-your-best-friend">Tool 1: readelf is your best friend</h4>
<p><code>readelf</code> as the name suggests, reads ELFs and prints out useful information for us.
Let us look at the ELF header.</p>
<p><code>readelf -h zig_factorial</code></p>





<pre tabindex="0"><code>ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x205e60
  Start of program headers:          64 (bytes into file)
  Start of section headers:          581424 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         8
  Size of section headers:           64 (bytes)
  Number of section headers:         19
  Section header string table index: 17</code></pre><p>You will find a lot of interesting info: 1. this is a 64 bit executable (Class : ELF64), built for the x86-64 architecture running System V (Linux and UNIX like OS) and the address from which we must start executing code is <code>0x205e60</code></p>
<p>Lets run <code>ldd</code> on this exectuable:</p>
<p><code>$ ldd zig_factorial</code>
<code>           not a dynamic executable</code></p>
<p><code>ldd</code> tells us that this .exe file does not depend on any other libraries on the operating system. Hence it is <code>static</code>.</p>
<p>Lets look at the elf using another tool <code>nm</code>
<code>nm zig_factorial</code></p>
<p>It should produce a large output like this</p>





<pre tabindex="0"><code>0000000000204e20 t std.debug.assert
0000000000226330 t std.debug.attachSegfaultHandler
000000000020e4d0 t std.debug.chopSlice
000000000021c6d0 t std.debug.Config.setColor
000000000020a9c0 t std.debug.DebugInfo.getModuleForAddress
000000000020a460 t std.debug.DebugInfo.init
000000000020b070 t std.debug.DebugInfo.lookupModuleDl
0000000000207940 t std.debug.detectTTYConfig
0000000000206770 t std.debug.dumpCurrentStackTrace
00000000002064e0 t std.debug.dumpStackTrace
0000000000233c50 t std.debug.dumpStackTraceFromBase
0000000000207880 t std.debug.getDebugInfoAllocator
0000000000207730 t std.debug.getSelfDebugInfo
000000000021d0b0 t std.debug.getSymbolFromDwarf
000000000022ca60 t std.debug.handleSegfaultPosix
0000000000225880 t std.debug.LineInfo.deinit
000000000020e200 t std.debug.mapWholeFile</code></pre><p>We aren&rsquo;t interested in any of these symbols except what lies at address <code>0x205e60</code> , as this is our entry point into the executable, so let us grep for that.
<code>$ nm zig_factorial | grep 0x205e60</code></p>
<p><code>0000000000205e60 T _start</code></p>
<p>Curiourser and curiouser. In our program , we defined a <code>main</code> function and assumed that that is what gets executed when we run our program. What then is <code>_start</code> ?</p>
<p>When you execute your program, there has to be a lot of things that have to be done before <code>main</code> is called. Some of the tasks are like ensuring that the <code>argc</code> and <code>argv</code> parameters to the function are passed in the right registers, any state needed by the program before main is executed is updated . These might vary from platform to platform and runtime to runtime (zig, c, c++, insert prog. lang. of your choice).</p>
<p>The convention therefore is to point the entry point of the executable to <code>_start</code> which does the initialization and calls <code>main</code>. Similarly, once your program exists , either by returning from main or calling some sort of <code>exit</code> function, an optional <code>exit</code>  like section runs, cleaning up resources before the program actually exits.</p>
<p>(Self note: Glic binaries have no <code>exit</code> sections defined)</p>
<p>Infact, the ELF defines 2 special sections<code>.init</code> and <code>.fini</code> to hold code for these entry and cleanup routines. We will discuss this in detail later.</p>
<p>In case of our zig based program, the <code>zig</code> compiler (more specifically: the <code>musl</code> C library) provides all the necessary startup/cleanup code and compiles this into our executable, which then calls our <code>main</code> .</p>
<h2 id="static-vs-dynamically-linked-executables">Static vs dynamically linked Executables</h2>
<p><code>Static</code>:  Executable contains a copy of all the code it needs to interact with the Operating system and other systems
<code>Dynamic</code>: Executable tells what code it needs, but doesn&rsquo;t have it bundled in the same file. Instead it is the duty of the <code>dynamic linker</code>, to load this exe and link the code that executable needs before the executable actually starts executing the code.</p>
<h5 id="why-are-executables-dynamic-">Why are executables dynamic ?</h5>
<ol>
<li>A lot of code (such as <code>printf</code>) are commonly used by most programs. When programs are executed, they are loaded into memory  first so that they can be run.  In the old days, when memory was scarce, each executable loading code for the same function <code>printf</code>, <code>read</code>, <code>write</code> etc. meant wasting memory due to duplication</li>
<li>Thanks to virtual memory, the memory addresses that processes see is not the same as the actual addreses in RAM. This meant that you can load <code>printf</code> in one RAM location and share it with many different processes , with a different virtual address in each process, thus reducing memory usage.</li>
<li><code>glibc</code> or the C standard library is probably the most commonly used layer to interact with Linux. Therefore by shipping one instance of glibc with all Linux based OS, applications need not worry about the API to Linus and can rely on glibc to provide the functionality.</li>
</ol>
<p>The <code>dynamic linker</code> is a program that links your executable to <code>glibc</code> before the executable is run. All dynamically linked executables have an <code>INTERP</code> section (more on sections later), that points to the location of the <code>dynamic linker</code>.</p>
<p>When you do something like <code>./my-executable</code> in your shell, your shell invokes <code>execve(./executable)</code>.
<code>execve</code> is a family of Linux system calls that create a Process and to run your executables. When they see that your executable is a <code>dynamic</code> one, they invoke the <code>dynamic linker</code> present in the <code>INTERP</code> section of your executable, which then links your executable to <code>glibc</code> before running it.</p>
<h5 id="problems">Problems</h5>
<ol>
<li>Like any dependency versioning is a problem. Your user&rsquo;s OS might have a different version of Glibc that might not have the features your application needs , thus breaking the experience for the user.</li>
<li>Platform inconsistencies: Dynamically linked executables hardcode the path to the <code>dynamic linker</code>. If you run your executable on an OS or a Linux installation with the dynamic linker at a different location, then your application will not be run (however, this can be solved by setting the <code>LD_LIBRARY_PATH</code> environment variable in the shell if the <code>dynamic linker</code> is present in a differnt location)</li>
</ol>
<h5 id="why-are-executables-static-">Why are executables static ?</h5>
<ol>
<li>All code/data needed in one single file. No need to worry about dependencies.</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Module customization hooks in Node 20</title>
      <link>https://gowind.github.io/post/module_customization_hooks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/module_customization_hooks/</guid>
      <description>Node 20 changed/added behaviour to handle import statements in .js files. We will go through some code to see how it works.</description>
      <content:encoded><![CDATA[<p>Node 20 changed/added behaviour to handle <code>import</code> statements in <code>.js</code> files.
We will go through some code to see how it works.</p>
<h3 id="no-type-module-in-packagejson">No <code>type: module</code> in <code>package.json</code></h3>
<ol>
<li><code>import</code> statements in <code>.js</code> files won&rsquo;t work.</li>
</ol>





<pre tabindex="0"><code>
$ cat my-app.js
import { hello } from &#39;./my-app-x&#39;;
import crypto from &#34;node:crypto&#34;;
console.log(hello());
console.log(crypto.randomBytes(32).toString(&#39;hex&#39;));</code></pre>




<pre tabindex="0"><code>~/personal/node_hooks ⌚ 22:28:57
$ cat my-app-x.js
export function hello() {
  return 4;
}</code></pre>




<pre tabindex="0"><code>~/personal/node_hooks ⌚ 22:29:04
$ node my-app.js
(node:58013) Warning: To load an ES module, set &#34;type&#34;: &#34;module&#34; in the package.json or use the .mjs extension.
(Use `node --trace-warnings ...` to show where the warning was created)
/Users/govind/personal/node_hooks/my-app.js:1
import { hello } from &#39;./my-app-x&#39;;
^^^^^^</code></pre><h4 id="solution-change-js-files-to-mjs-files-and-rename-import-specifiers--to-work-with-modules">Solution: change <code>.js</code> files to <code>.mjs</code> files (and rename import <code>specifiers</code> ) to work with modules</h4>





<pre tabindex="0"><code>$ cat my-app.mjs
import { hello } from &#39;./my-app-x.mjs&#39;;
import crypto from &#34;node:crypto&#34;;
console.log(hello());
console.log(crypto.randomBytes(32).toString(&#39;hex&#39;));

~/personal/node_hooks ⌚ 22:37:34
$ cat my-app-x.mjs
export function hello() {
  return 4;
}

~/personal/node_hooks ⌚ 22:37:38
$ node my-app.mjs
4
0ad44de8f3ffa9e769f593b9228c13e7b765c78aa50b3e3909c991bb96aaee1f</code></pre><h3 id="adding-type-module-in-packagejson">Adding <code>type: module</code> in package.json</h3>
<p>Will allow you to use <code>import</code> statements within <code>.js</code> files</p>





<pre tabindex="0"><code>node my-app.js
node:internal/process/esm_loader:48
      internalBinding(&#39;errors&#39;).triggerUncaughtException(
                                ^

Error [ERR_MODULE_NOT_FOUND]: Cannot find module &#39;/Users/govind/personal/node_hooks/my-app-x&#39; imported from /Users/govind/personal/node_hooks/my-app.js
Did you mean to import ../my-app-x.js?</code></pre><p><strong>However, You cannot import from js modules (that are single files) without a <code>.js</code> suffix</strong></p>





<pre tabindex="0"><code>$ cat my-app.js
import { hello } from &#39;./my-app-x.js&#39;;
import crypto from &#34;node:crypto&#34;;
console.log(hello());
console.log(crypto.randomBytes(32).toString(&#39;hex&#39;));

~/personal/node_hooks ⌚ 22:33:30
$ node my-app.js
4
b287ab28bd13f778ffb49df44c7a5eac942e119fee786b6f9a196b21aa497ceb</code></pre><p><strong>The solutions work fine for new code , but what about existing JS code where you might already be using js modules without a <code>.js</code> suffix in the code ?</strong></p>
<h3 id="module-customization-hooks">Module customization hooks</h3>
<p>You can use <a href="https://nodejs.org/docs/latest-v20.x/api/module.html#customization-hooks">Module customization hook</a> to customize module resolution and loading.
The hook is provided in a <code>.mjs</code>/<code>.js</code> that is run in a separate thread , before your entry file is executed.
The hook is executed as thus:</p>





<pre tabindex="0"><code>```bash
node --import ./register-hooks.js ./my-app.js</code></pre><p>Where <code>register-hooks</code> calls the <code>register</code> method of <code>node:module</code> builtin with the path to a file containing the hooks</p>





<pre tabindex="0"><code>const { register } = require(&#39;node:module&#39;);
const { pathToFileURL } = require(&#39;node:url&#39;);

const { port1, port2 } = new MessageChannel();

const pfUrl = pathToFileURL(__filename);
console.log(pfUrl);
register(&#39;./hooks.mjs&#39;, {parentURL: pfUrl.href, data: {number: 1, port: port2 }, transferList: [port2]});</code></pre><p>The <code>hooks.mjs</code> exports 3 fns: <code>initialize</code>, <code>resolve</code> and <code>load</code> that will allow you to resolve import specifiers (<code>./my-app</code> or <code>crypto</code> or <code>@package/some-name</code> etc) and then allow you to customize how they are loaded
You will find a sample implementation <a href="https://github.com/GoWind/algorithms/tree/master/node_hooks">here</a>.</p>
<p>I <a href="https://github.com/GoWind/algorithms/tree/master/node_hooks">customized</a> the hooks to import es modules with a <code>.mjs</code> or a <code>type</code>: &ldquo;module&rdquo; in package.json.</p>
<p>The output is something like this</p>





<pre tabindex="0"><code>$ node --import ./register-hooks.cjs ./my-app.js
URL {
  href: &#39;file:///Users/govind/personal/algorithms/node_hooks/register-hooks.cjs&#39;,
  origin: &#39;null&#39;,
  protocol: &#39;file:&#39;,
  username: &#39;&#39;,
  password: &#39;&#39;,
  host: &#39;&#39;,
  hostname: &#39;&#39;,
  port: &#39;&#39;,
  pathname: &#39;/Users/govind/personal/algorithms/node_hooks/register-hooks.cjs&#39;,
  search: &#39;&#39;,
  searchParams: URLSearchParams {},
  hash: &#39;&#39;
}
got file:///Users/govind/personal/algorithms/node_hooks/my-app.js to resolve
calling load for file:///Users/govind/personal/algorithms/node_hooks/my-app.js
got ./my-app-x to resolve
got node:crypto to resolve
calling load for file:///Users/govind/personal/algorithms/node_hooks/my-app-x.js
calling load for node:crypto
4
32a902c4ec08d14308ed0ac00b5e2340b31dd298e964e07a4635997939e5041b</code></pre><p>Happy hacking !</p>
]]></content:encoded>
    </item>
    <item>
      <title>Procedure Link Tables Part I</title>
      <link>https://gowind.github.io/post/procedure_link_tables_part1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/procedure_link_tables_part1/</guid>
      <description>TODO: Start with example from ELF Relocations. Note: A lot seems to have changed in how PLTs and GOTs are resolved and loaded, especially from 32 bits to 64 bits .</description>
      <content:encoded><![CDATA[<pre><code>	TODO: Start with example from ELF Relocations.
</code></pre>
<p><strong>Note</strong>: A lot seems to have changed in how PLTs and GOTs are resolved and loaded, especially from 32 bits to 64 bits . A lot of my Google searches (example <a href="https://www.youtube.com/watch?v=kUk5pw4w0h4&amp;t=271s">here</a>) ended up showing stuff like <code>dl_resolve</code> that no longer seemed to be used anymore ????
Anyway, we can still get a rough idea of how PLTs and GOTs work, nevertheless.</p>
<p>Let me start from the previous source listing of a <code>main.c</code> and <code>lib.c</code> from the [[From Source Code to Hello World/ELF Relocations]] post.</p>
<p>We saw that the (static) linker was able to resolve the reference to <code>factorial</code> in our <code>main</code>  when creating the executable. Resolve here means it can place the code for factorial in our executable file and generate a <code>call</code> instruction:</p>





<pre tabindex="0"><code>11a7:       e8 9d ff ff ff          call   1149 &lt;factorial&gt;</code></pre><p>However, <code>printf</code> is part of <code>glibc</code>, which will be dynamically linked during runtime by the dynamic linker. The Executable does not know what address <code>printf</code> will be loaded at, so how will it know which memory address the <code>call</code> should jump to ?</p>
<p>ELFs solve this problem using <code>PLT</code>s or Procedure Link Tables. The idea is simple:</p>
<ol>
<li>For each dynamically linked function (<code>printf</code> etc), generate a <code>stub</code> or a <code>trampoline</code> entry in the PLT.
2.In the user&rsquo;s functions, generate a <code>call</code> or a <code>jmp</code> instruction to this <code>stub</code>.</li>
<li>This stub will then <code>jmp</code> to some location (<code>GOT</code>), that can then figure out where printf is located and further <code>jmp</code> or <code>call</code> that location.
3a. At 3, every function call from the application code to the dynamically linked function will need 2 jumps. Therefore, as an optimization, at 3) once we know the address of <code>printf</code>, we can put this address directly in our <code>GOT</code>, so that our <code>stub</code> can <code>jmp</code> to <code>printf</code> instead of having to get it resolved  everytime.</li>
</ol>
<p>In th executable, 2 things have to be  done:</p>
<ol>
<li>We need to signal the dynamic linker, that we need  <code>printf</code></li>
</ol>
<p>This is done using <code>relocation</code> sections (<code>readelf --relocs main</code>).</p>





<pre tabindex="0"><code>Relocation section &#39;.rela.plt&#39; at offset 0x5e8 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000003fd0  000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0</code></pre><p>The <code>Offset</code> has different meanings, depending on if our file is Relocatable file (<code>.o</code>) or an executable. <code>main</code> here is an executable, so <code>Offset</code> here is a virtual address (this will be changed when our executable is run as a process anyway).</p>
<p>Let us look at our <code>main</code> to see how it indirectly calls <code>printf</code>.
<code>objdump -M intel -dS main</code> (<code>-M</code> is for setting assembly syntax flavor. Intel flavor is a little easier to understand than the default AT&amp;T syntax).</p>





<pre tabindex="0"><code>000000000000118a &lt;main&gt;:
... some assembly dropped
11b5:       b8 00 00 00 00          mov    eax,0x0
11ba:       e8 91 fe ff ff          call   1050 &lt;printf@plt&gt;</code></pre><p>We <code>call</code> to location <code>0x1050</code>. Lets inspect what is at location <code>0x1050</code>.</p>





<pre tabindex="0"><code>Disassembly of section .plt.sec:

0000000000001050 &lt;printf@plt&gt;:
    1050:       f3 0f 1e fa             endbr64 
    1054:       f2 ff 25 75 2f 00 00    bnd jmp QWORD PTR [rip+0x2f75]        # 3fd0 &lt;printf@GLIBC_2.2.5&gt;
    105b:       0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]</code></pre><p>Okay, so we have a <code>PLT entry for printf</code> . Lets ignore the <code>endbr64</code>instruction and focus on the next instruction (0x1054).
We still don&rsquo;t know the address of the actual <code>printf</code>. What we see here is an <code>indirect jump</code>, like dereferencing a pointer. The <code>[]</code> means, look up the value stored at address <code>rip + 0x2f75</code> and then jmp to that value.
When executing <code>0x1054</code>, <code>rip</code> points to the next instruction (<code>0x105b</code>). The jmp value is stored at <code>rip + 0x2f75</code> =&gt; <code>0x3fd0</code>.
<strong>Note</strong> that <code>0x3fd0</code> is the address where we request our dynamic linker to place the address of <code>printf</code> in our <code>relocs</code> section.</p>
<p>To really probe the next step, we have to fire up <code>gdb</code> and execute our exe file step by step.
This will be turned into Part 2.</p>
<h4 id="reference">Reference:</h4>
<p><a href="https://www.youtube.com/watch?v=kUk5pw4w0h4">https://www.youtube.com/watch?v=kUk5pw4w0h4</a></p>
<p>Why you need PLT AND GOT
<a href="https://stackoverflow.com/questions/45355013/why-trampoline-from-plt-to-got-instead-of-directly-jumping-to-got">https://stackoverflow.com/questions/45355013/why-trampoline-from-plt-to-got-instead-of-directly-jumping-to-got</a> (hint: When stub from PLT jumps to GOT, it pushes information in the stack for the resolving function in the GOT that <code>printf</code> or whatever function is called via the <code>plt</code> needs to be resolved.)</p>
<p>Also <a href="https://stackoverflow.com/questions/43048932/why-does-the-plt-exist-in-addition-to-the-got-instead-of-just-using-the-got">https://stackoverflow.com/questions/43048932/why-does-the-plt-exist-in-addition-to-the-got-instead-of-just-using-the-got</a>
(It is hard to know if you have to do a <code>jmp</code> vs if you have to do a <code>call</code> , so there in seems to be the biggest problem)</p>
]]></content:encoded>
    </item>
    <item>
      <title>Procedure Link Tables Part II</title>
      <link>https://gowind.github.io/post/procedure_link_tables_part2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/procedure_link_tables_part2/</guid>
      <description>This is a continuation of [[From Source Code to Hello World/Procedure Link Tables Part 1]]</description>
      <content:encoded><![CDATA[<p>This is a continuation of [[From Source Code to Hello World/Procedure Link Tables Part 1]]</p>
<p>Let us fire up good old <code>gdb</code>. I use <code>pwndbg</code>  extension to <code>gdb</code> , as it looks cool and also has some nice additional features (haven&rsquo;t used it to the full extent, maybe will write a post on that)</p>
<p>In you directory with the <code>main</code> executable ( <code>gcc -c lib.c -o lib.o</code>, <code>gcc -c main.c -o main.o</code>, <code>gcc lib.o main.o -o main</code>), run <code>gdb</code> and load the <code>main</code> file using <code>file main</code>
Let us set a breakpoint in <code>main</code> and step through to understand how <code>printf</code> is called.</p>
<p>If you have <code>pwndbg</code> also installed, your console will look like this</p>





<pre tabindex="0"><code>pwndbg&gt; file main 
Reading symbols from main...
(No debugging symbols found in main)
pwndbg&gt; break main
Breakpoint 1 at 0x118a
pwndbg&gt;</code></pre><p>We have set a <code>breakpoint</code> just before our <code>main</code> fn starts (break is set on <code>main</code> fn, not the executable. Apologies for the confusing naming!)</p>
<p>Type <code>run</code> and press <code>ENTER</code> and you will hit the breakpoint</p>





<pre tabindex="0"><code>&gt;disas/r
Dump of assembler code for function main:
=&gt; 0x000055555555518a &lt;+0&gt;:     f3 0f 1e fa     endbr64 
   0x000055555555518e &lt;+4&gt;:     55      push   rbp
   0x000055555555518f &lt;+5&gt;:     48 89 e5        mov    rbp,rsp
   0x0000555555555192 &lt;+8&gt;:     48 83 ec 10     sub    rsp,0x10
   0x0000555555555196 &lt;+12&gt;:    89 7d fc        mov    DWORD PTR [rbp-0x4],edi
   0x0000555555555199 &lt;+15&gt;:    48 89 75 f0     mov    QWORD PTR [rbp-0x10],rsi
   0x000055555555519d &lt;+19&gt;:    bf 05 00 00 00  mov    edi,0x5
   0x00005555555551a2 &lt;+24&gt;:    b8 00 00 00 00  mov    eax,0x0
   0x00005555555551a7 &lt;+29&gt;:    e8 9d ff ff ff  call   0x555555555149 &lt;factorial&gt;
   0x00005555555551ac &lt;+34&gt;:    89 c6   mov    esi,eax
   0x00005555555551ae &lt;+36&gt;:    48 8d 3d 4f 0e 00 00    lea    rdi,[rip+0xe4f]        # 0x555555556004
   0x00005555555551b5 &lt;+43&gt;:    b8 00 00 00 00  mov    eax,0x0
   0x00005555555551ba &lt;+48&gt;:    e8 91 fe ff ff  call   0x555555555050 &lt;printf@plt&gt;
   0x00005555555551bf &lt;+53&gt;:    b8 00 00 00 00  mov    eax,0x0
   0x00005555555551c4 &lt;+58&gt;:    c9      leave  
   0x00005555555551c5 &lt;+59&gt;:    c3      ret    
End of assembler dump.</code></pre><p>Let us set a breakpoint before we call <code>printf@plt</code>. You can set up a breakpoint on an instruction&rsquo;s address by doing <code>break *addressInHex</code> . Let us set it to
<code>break *0x00005555555551ba</code> and type <code>continue</code>. We will hit our breakpoint</p>





<pre tabindex="0"><code>   0x5555555551b5 &lt;main+43&gt;            mov    eax, 0
 ► 0x5555555551ba &lt;main+48&gt;            call   printf@plt                &lt;printf@plt&gt;
        format: 0x555555556004 ◂— &#39;factorial of 5 is %d\n&#39;
        vararg: 0x78
 </code></pre><p><code>pwndbg</code> is cool ! It shows the arguments to my <code>printf</code> even, below the instruction. As we can see, we are <code>call</code>-in the <code>printf@plt</code>. Lets step again to see what is going on.</p>
<p><strong>slow here</strong>
Here is the tricky part. It took me some time to identify what is going on here.</p>
<p>Lets do <code>disas/r</code> , it will show us the raw hex values of the assembly instructions instead of the disassembled instructions.</p>





<pre tabindex="0"><code>disas/r
....
=&gt; 0x00005555555551ba &lt;+48&gt;:    e8 91 fe ff ff  call   0x555555555050 &lt;printf@plt&gt;
   0x00005555555551bf &lt;+53&gt;:    b8 00 00 00 00  mov    eax,0x0</code></pre><p>Note that we are jumping backward to addres <code>...5050</code>. Let us set a breakpoint there again (<code>break *0x555555555050</code>) and then type <code>continue</code>. we will then stop before address <code>...5050</code></p>





<pre tabindex="0"><code>► 0x555555555050 &lt;printf@plt&gt;      endbr64 
   0x555555555054 &lt;printf@plt+4&gt;    bnd jmp qword ptr [rip + 0x2f75]     &lt;printf&gt;
    ↓
   0x7ffff7e25d70 &lt;printf&gt;          endbr64</code></pre><p>Note the down arrow point to an address much farther than where we set our breakpoint at. Let us look at the raw assembly again</p>





<pre tabindex="0"><code>pwndbg&gt; disas/r
Dump of assembler code for function printf@plt:
=&gt; 0x0000555555555050 &lt;+0&gt;:     f3 0f 1e fa     endbr64 
   0x0000555555555054 &lt;+4&gt;:     f2 ff 25 75 2f 00 00    bnd jmp QWORD PTR [rip+0x2f75]        # 0x555555557fd0 &lt;printf@got.plt&gt;
   0x000055555555505b &lt;+11&gt;:    0f 1f 44 00 00  nop    DWORD PTR [rax+rax*1+0x0]</code></pre><p>Our next instruction is a <code>jmp QWORD PTR [rip+0x2f75]</code>. When this instruction is executed, <code>rip</code>&rsquo;s value is  0x000055555555505b. We add 0x2f75 to it (resulting in 0x555555557fd0).</p>
<p>The <code>[]</code> around this addition signified that it is an indirect jump , i.e, we first calculate an address, read the value  <code>a</code> at this address and then jmp <code>a</code>.</p>
<p>So our <code>jmp</code> reads the value at 0x555555557fd0 and then jumps to the value. Inspect the value  at 0x555555557fd0 by typing in <code>x/2x 0x555555557fd0</code></p>





<pre tabindex="0"><code>0x555555557fd0 &lt;printf@got.plt&gt;:        0xf7e25d70      0x00007fff
pwndbg&gt;</code></pre><p>Since I am running this on my Intel machine, the value is stored in the little-endian format (least significant bytes first). The address should therefore be interpreted as <code>0x00007ffff7e25d70</code> (reverse of what is displayed above)</p>
<p>Note that this matches the value when we hit the breakpoint <code>5050 &lt;printf@plt&gt;</code> !</p>
<p>This is the real <code>printf</code> !
<strong>And where does this come from ?</strong>
Type in <code>info proc mappings</code>.</p>
<p>This will show you which file /library has been loaded at which address in our process&rsquo; address space.</p>





<pre tabindex="0"><code>process 18722
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x7ffff7dc1000     0x7ffff7de6000    0x25000        0x0 /usr/lib/x86_64-linux-gnu/libc-2.30.so
      0x7ffff7de6000     0x7ffff7f5e000   0x178000    0x25000 /usr/lib/x86_64-linux-gnu/libc-2.30.so
      0x7ffff7f5e000     0x7ffff7fa8000    0x4a000   0x19d000 /usr/lib/x86_64-linux-gnu/libc-2.30.so
	  ....
	  0x7ffff7fae000     0x7ffff7fb4000     0x6000        0x0 
      0x7ffff7fcc000     0x7ffff7fcf000     0x3000        0x0 [vvar]
      0x7ffff7fcf000     0x7ffff7fd0000     0x1000        0x0 [vdso]
      0x7ffff7fd0000     0x7ffff7fd1000     0x1000        0x0 /usr/lib/x86_64-linux-gnu/ld-2.30.so
      0x7ffff7fd1000     0x7ffff7ff3000    0x22000     0x1000 /usr/lib/x86_64-linux-gnu/ld-2.30.so
      0x7ffff7ff3000     0x7ffff7ffb000     0x8000    0x23000 /usr/lib/x86_64-linux-gnu/ld-2.30.so
	  ...
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
pwndbg&gt;</code></pre><p>The address of the actual printf is in the second entry which points to <code>libc-2.30.so</code> ! This is loading is taken care of by the dynamic linker, which maps portions of <code>libc</code> that we use in our program to the process&rsquo;s actual address space.</p>
<p>We learnt how <code>PLTs</code> can be used to link to functions whose address we do not know, by creating a stub for them and then stating that we need this stub to be filled with the address to the actual function at runtime.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Thread Local Storage on macOS</title>
      <link>https://gowind.github.io/post/thread_local_storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/thread_local_storage/</guid>
      <description>How are thread local variables implemented on macOS ? Through some debugging, Googling and reading the source, lets figure out how.</description>
      <content:encoded><![CDATA[<p>How are thread local variables implemented on macOS ? Through some debugging, Googling and reading the source, lets figure out how.</p>
<p>A thread local variable is a variable declared in the program that is accessed like a common variable, but each thread has a unique copy of the variable. When a thread in the program modifies this variable, the modification is visible only to the thread that modified it and not the other threads (consequently, the other threads might see other values based on if and when they modify the variable)</p>
<p>Lets take an example. The variable <code>i</code> is <code>thread local</code> (<code>__thread</code> is a GNU extension to the C language). We create 3 threads, each of which increment <code>i</code> by 1. If all the threads add 1 to <code>i</code>, and <code>i</code> were a normal variable, then <code>i</code> must be 14.
But since <code>i</code> is defined as <code>thread local</code>, each thread gets a copy of <code>i</code>, initialized to <code>10</code> and then each thread increments it by <code>1</code>, equaling <code>11</code> in each thread.
We can verify this behaviour.</p>





<pre tabindex="0"><code>#include&lt;stdio.h&gt;
#include&lt;pthread.h&gt;

__thread int i = 10;
void increment_i(void);
int main() {

  pthread_t t1, t2, t3;
  int ret1, ret2, ret3;
  ret1 = pthread_create(&amp;t1, NULL, (void *)increment_i, NULL);
  ret2 = pthread_create(&amp;t2, NULL, (void *)increment_i, NULL);
  ret3 = pthread_create(&amp;t3, NULL, (void *)increment_i, NULL);

  pthread_join(t1, NULL);
  pthread_join(t2, NULL);
  pthread_join(t3, NULL);

  return 0;
}


void increment_i() {
  int k = i + 1;
  i = k;
  printf(&#34;value of k is %d\n&#34;, k);
}</code></pre><p>compiling it
<code>gcc tlocal.c -o tlocal -lpthread</code></p>
<p>and executing it</p>





<pre tabindex="0"><code>./tlocal
value of k is 11
value of k is 11
value of k is 11</code></pre><h3 id="so-how-are-thread-local-variables-implemented-">So how are thread local variables implemented ?</h3>
<p>To understand this, we need to setup a breakpoint in <code>increment_i</code> to observe the behavior. Lets load up our executable in lldb and step through the code.</p>
<p><code>&gt;lldb --file tlocal</code></p>





<pre tabindex="0"><code>(lldb) b increment_i
Breakpoint 1: where = tlocal`increment_i, address = 0x0000000100003f64
(lldb) run
Process 95169 launched: &#39;/Users/govind/gowind-whisper/tlocal&#39; (arm64)
Process 95169 stopped
* thread #2, stop reason = breakpoint 1.1
    frame #0: 0x0000000100003f64 tlocal`increment_i
tlocal`increment_i:
-&gt;  0x100003f64 &lt;+0&gt;:  sub    sp, sp, #0x20
    0x100003f68 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]
    0x100003f6c &lt;+8&gt;:  add    x29, sp, #0x10
    0x100003f70 &lt;+12&gt;: adrp   x0, 5
  thread #3, stop reason = breakpoint 1.1
    frame #0: 0x0000000100003f64 tlocal`increment_i
tlocal`increment_i:
-&gt;  0x100003f64 &lt;+0&gt;:  sub    sp, sp, #0x20
    0x100003f68 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]
    0x100003f6c &lt;+8&gt;:  add    x29, sp, #0x10
    0x100003f70 &lt;+12&gt;: adrp   x0, 5
  thread #4, stop reason = breakpoint 1.1
    frame #0: 0x0000000100003f64 tlocal`increment_i
tlocal`increment_i:
-&gt;  0x100003f64 &lt;+0&gt;:  sub    sp, sp, #0x20
    0x100003f68 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]
    0x100003f6c &lt;+8&gt;:  add    x29, sp, #0x10
    0x100003f70 &lt;+12&gt;: adrp   x0, 5
Target 0: (tlocal) stopped.
(lldb)</code></pre><p>3 threads are launched and all stop at the beginning of <code>increment_i</code>
Lets select one thread and step through it, to make it less confusing.</p>





<pre tabindex="0"><code>thread select 4
* thread #4, stop reason = breakpoint 1.1
    frame #0: 0x0000000100003f64 tlocal`increment_i
tlocal`increment_i:
-&gt;  0x100003f64 &lt;+0&gt;:  sub    sp, sp, #0x20
    0x100003f68 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]
    0x100003f6c &lt;+8&gt;:  add    x29, sp, #0x10
    0x100003f70 &lt;+12&gt;: adrp   x0, 5</code></pre><p>Now, what we are interested in is the <code>adrp</code> instruction. As covered in the previous <a href="https://github.com/GoWind/GoWind.github.io/blob/master/got_stubs_and_linking.md">post</a> , we use the <code>GOT</code> (global offset table) to load the address of a global variable. The address is at a fixed offset from the base of the GOT. We then fetch the value of the variable from the address.
<code>adrp</code> sets <code>x0</code> to an offset into the GOT (GOT + some value), where we will find the address of our global variable. we then load the actual value of our variable from this address (using <code>ldr x0, [x0]</code>)</p>
<h4 id="in-this-case-we-cant-use-a-got-why-">In this case, we can&rsquo;t use a GOT. Why ?</h4>
<p>All threads share the same memory space. If var <code>i</code> is stored at address <code>x</code>, then all threads will see the same address <code>x</code> when they try to load the value for <code>i</code>. In <code>increment_i</code>, we aren&rsquo;t using any thread index or other thread specific identifiers (atleast directly) to load a different address in each thread, so that each thread gets a copy of <code>i</code>.
How does it work then ?</p>
<p>The answers is how thread local storage works. Thread local data (variables) are stored in a section called <code>thread_vars</code> and <code>thread_bss</code> (<code>tdata</code> and <code>tbss</code> on Linux systems). You can see them by dumping the sections present in the image (executable file ) in lldb</p>





<pre tabindex="0"><code>(lldb) image dump sections tlocal
Sections for &#39;/Users/govind/gowind-whisper/tlocal&#39; (arm64):
  SectID     Type             Load Address                             Perm File Off.  File Size  Flags      Section Name
  ---------- ---------------- ---------------------------------------  ---- ---------- ---------- ---------- ----------------------------
  0x00000100 container        [0x0000000000000000-0x0000000100000000)* ---  0x00000000 0x00000000 0x00000000 tlocal.__PAGEZERO
  0x00000200 container        [0x0000000100000000-0x0000000100004000)  r-x  0x00000000 0x00004000 0x00000000 tlocal.__TEXT
....
  0x00000005 regular          [0x0000000100008000-0x0000000100008018)  rw-  0x00008000 0x00000018 0x00000013 tlocal.__DATA.__thread_vars
  0x00000006 regular          [0x0000000100008018-0x000000010000801c)  rw-  0x00000000 0x00000000 0x00000012 tlocal.__DATA.__thread_bss
  0x00000500 container        [0x000000010000c000-0x0000000100010000)  r--  0x0000c000 0x00000403 0x00000000 tlocal.__LINKEDIT</code></pre><p>Our thread local variables seem to have an address somewhere between <code>0x0000000100008000</code>-<code>0x000000010000801c</code>.
Let us see what is the address we get for <code>i</code> when we read the value of <code>i</code> in each thread</p>





<pre tabindex="0"><code>(lldb) stepi -c 3
...
* thread #4, stop reason = instruction step into
    frame #0: 0x0000000100003f70 tlocal`increment_i + 12
tlocal`increment_i:
-&gt;  0x100003f70 &lt;+12&gt;: adrp   x0, 5
    0x100003f74 &lt;+16&gt;: add    x0, x0, #0x0              ; i
    0x100003f78 &lt;+20&gt;: ldr    x8, [x0]
    0x100003f7c &lt;+24&gt;: blr    x8
...
* thread #4, stop reason = instruction step into
    frame #0: 0x0000000100003f74 tlocal`increment_i + 16
tlocal`increment_i:
-&gt;  0x100003f74 &lt;+16&gt;: add    x0, x0, #0x0
    0x100003f78 &lt;+20&gt;: ldr    x8, [x0]
    0x100003f7c &lt;+24&gt;: blr    x8
    0x100003f80 &lt;+28&gt;: ldr    w8, [x0]
Target 0: (tlocal) stopped.
(lldb) register read x0
      x0 = 0x0000000100008000  tlocal`i
(lldb) stepi
...
* thread #4, stop reason = instruction step into
    frame #0: 0x0000000100003f78 tlocal`increment_i + 20
tlocal`increment_i:
-&gt;  0x100003f78 &lt;+20&gt;: ldr    x8, [x0]
    0x100003f7c &lt;+24&gt;: blr    x8
    0x100003f80 &lt;+28&gt;: ldr    w8, [x0]
    0x100003f84 &lt;+32&gt;: add    w8, w8, #0x1
Target 0: (tlocal) stopped.
(lldb) register read x0
      x0 = 0x0000000100008000  tlocal`i
(lldb) stepi
* thread #4, stop reason = instruction step into
    frame #0: 0x0000000100003f7c tlocal`increment_i + 24
tlocal`increment_i:
-&gt;  0x100003f7c &lt;+24&gt;: blr    x8
    0x100003f80 &lt;+28&gt;: ldr    w8, [x0]
    0x100003f84 &lt;+32&gt;: add    w8, w8, #0x1
    0x100003f88 &lt;+36&gt;: stur   w8, [x29, #-0x4]
Target 0: (tlocal) stopped.
(lldb) register read x8
      x8 = 0x000000018c84d120  libdyld.dylib`tlv_get_addr
(lldb)</code></pre><p><code>adrp x0</code> gives us the value <code>0x0000000100008000</code>.
Reading the value stored at this address, we see that this value is not the value of <code>i</code> proper, but is in turn, another address, that points to a fn <code>tlv_get_addr</code> instead.</p>
<p><code>tlv_get_addr</code>, seems to be an macOS specific fn, which is part of the dynamic linker (<code>dyld</code>) on macOS. dyld seems to be mapping itself into the address space of the process, so that the process can , in situations like these, can use fns present in <code>dyld</code> .
We can check this using <code>image lookup</code>.</p>





<pre tabindex="0"><code>(lldb) image lookup -r -n tlv_get_addr #lookup a fn using a regex value tlv_get_addr
1 match found in /usr/lib/system/libdyld.dylib:
        Address: libdyld.dylib[0x00000001803d5120] (libdyld.dylib.__TEXT.__text + 3088)
        Summary: libdyld.dylib`tlv_get_addr</code></pre><p>Stepping over this call to <code>tlv_get_addr</code>, we see that this fns returns a value in <code>x0</code>. <strong>THIS</strong> seems to be the actual address of our variable <code>i</code>  and in the next  instructions, we are adding <code>1</code> to our variable <code>i</code> (<code>k = i + 1</code> in our code)</p>





<pre tabindex="0"><code>(lldb) thread step-over
Process 95169 stopped
* thread #4, stop reason = instruction step over
    frame #0: 0x0000000100003f80 tlocal`increment_i + 28
tlocal`increment_i:
-&gt;  0x100003f80 &lt;+28&gt;: ldr    w8, [x0]
    0x100003f84 &lt;+32&gt;: add    w8, w8, #0x1
    0x100003f88 &lt;+36&gt;: stur   w8, [x29, #-0x4]
    0x100003f8c &lt;+40&gt;: ldur   w8, [x29, #-0x4]
Target 0: (tlocal) stopped.
(lldb) register read x0
      x0 = 0x000060000000c000
(lldb) stepi
Process 95169 stopped
* thread #4, stop reason = instruction step into
    frame #0: 0x0000000100003f84 tlocal`increment_i + 32
tlocal`increment_i:
-&gt;  0x100003f84 &lt;+32&gt;: add    w8, w8, #0x1
    0x100003f88 &lt;+36&gt;: stur   w8, [x29, #-0x4]
    0x100003f8c &lt;+40&gt;: ldur   w8, [x29, #-0x4]
    0x100003f90 &lt;+44&gt;: str    w8, [x0]
Target 0: (tlocal) stopped.
(lldb) register read w8
      w8 = 0x0000000a</code></pre><p>Switching to a different thread, we can see that after the <code>blr x8</code> call, our <code>x0</code> has a different address, which according to thread #3, is the address of the variable <code>i</code></p>





<pre tabindex="0"><code>(lldb) thread select 3
* thread #3
    frame #0: 0x0000000100003f80 tlocal`increment_i + 28
tlocal`increment_i:
-&gt;  0x100003f80 &lt;+28&gt;: ldr    w8, [x0]
    0x100003f84 &lt;+32&gt;: add    w8, w8, #0x1
    0x100003f88 &lt;+36&gt;: stur   w8, [x29, #-0x4]
    0x100003f8c &lt;+40&gt;: ldur   w8, [x29, #-0x4]
(lldb) register read x0
      x0 = 0x0000600000010000
(lldb) stepi
Process 95169 stopped
* thread #3, stop reason = instruction step into
    frame #0: 0x0000000100003f84 tlocal`increment_i + 32
tlocal`increment_i:
-&gt;  0x100003f84 &lt;+32&gt;: add    w8, w8, #0x1
    0x100003f88 &lt;+36&gt;: stur   w8, [x29, #-0x4]
    0x100003f8c &lt;+40&gt;: ldur   w8, [x29, #-0x4]
    0x100003f90 &lt;+44&gt;: str    w8, [x0]
  thread #4, stop reason = trace
    frame #0: 0x0000000100003f84 tlocal`increment_i + 32
tlocal`increment_i:
-&gt;  0x100003f84 &lt;+32&gt;: add    w8, w8, #0x1
    0x100003f88 &lt;+36&gt;: stur   w8, [x29, #-0x4]
    0x100003f8c &lt;+40&gt;: ldur   w8, [x29, #-0x4]
    0x100003f90 &lt;+44&gt;: str    w8, [x0]
Target 0: (tlocal) stopped.
(lldb) register read w8
      w8 = 0x0000000a</code></pre><p>Thread local variables are thus, through one simple indirection, available to userspace programs on macOS.
Linux provides a similar call <code>tls_get_addr</code>. You can find more documentation on how TLS works in  <a href="https://stffrdhrn.github.io/hardware/embedded/openrisc/2020/01/19/tls.html">here</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Useful tools</title>
      <link>https://gowind.github.io/post/useful_tools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/useful_tools/</guid>
      <description>readelf nm pwndbg gdb objdump objdump uses GAS (GNU assembly) syntax ? Anywhere, here is how it works :</description>
      <content:encoded><![CDATA[<ul>
<li><code>readelf</code></li>
<li><code>nm</code></li>
<li><code>pwndbg</code></li>
<li><code>gdb</code></li>
<li><code>objdump</code></li>
</ul>
<p><code>objdump</code> uses GAS (GNU assembly) syntax ?
Anywhere, here is how it works :</p>
<p>operand source -&gt; destination
<code>movb $0x05, %al</code>
<code>$</code> prefixed immediates
<code>%</code>prefixed registers</p>
<h4 id="gdb-commands">gdb commands</h4>
<p><code>file myexec</code> -&gt; loads the excutable <code>myexec</code> for debugging
<code>start</code> -&gt; starts executing the file</p>
<p><code>starti</code> -&gt; start and execute only the next instruction
(This is cool, as <code>start</code> or <code>break main</code> and <code>start</code> go directly to the user-defined main
, and most C libraries have a ton of code executed before the user-defined main is called)</p>
<p><code>break fnname</code> -&gt; sets a breakpoint at a given fnname (if it exists)
<code>break *0xAddress</code> -&gt; sets a breakpoint at the given address (* is important)
<code>stepi</code> -&gt; step into the next instruction
<code>x/Nx address</code> -&gt; display N bytes of values starting at <code>address</code> in hex format.
<code>x/Ni address</code> -&gt; display N bytes of values starting at <code>address</code> interpreting them as instructions.
<code>frame</code> -&gt; shows the frame of the current function under exection.
<code>info proc mappings</code> -&gt; shows the address space and mapping of the
<code>print X</code> -&gt; when you are stopped at a breakpoint, print the value of the variable <code>X</code>
<code>display $registerName</code> -&gt; Display the value stored in the register <code>registerName</code> (e.g. eax, ebx, rax etc)
<code>info threads</code>-&gt; show the threads launched by the process.
<code>info regs</code> -&gt; shows the value in all the registers.</p>
]]></content:encoded>
    </item>
    <item>
      <title>What no one told me</title>
      <link>https://gowind.github.io/post/start_here/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/start_here/</guid>
      <description>Systems programming is less about understanding a Systems programming language (C, Rust, Zig) etc, and more about understanding the platfomr (x86, ARM, Linux) etc.</description>
      <content:encoded><![CDATA[<p>Systems programming is less about understanding a Systems programming language (C, Rust, Zig) etc, and more about understanding the platfomr (x86, ARM, Linux) etc.</p>
<p>After trying multiple times and failing to get a good understanding of systems, I re-thought my approach to learning systems programming and started at understanding the platform.</p>
<p>Here I start with Linux (and x86) and slowly make my way towards understanding at a deep level how programs works on an operating system and the hardware.</p>
<p>What is an ELF is currently being documented in  [[From Source Code to Hello World/Introduction]]</p>
<p>[[From Source Code to Hello World/What is <code>glibc</code>]] tries to explain what glibc is and how it or something like it is essential to any platform</p>
]]></content:encoded>
    </item>
    <item>
      <title>Why is my event loop still running?</title>
      <link>https://gowind.github.io/post/why_is_my_event_loop_still_alive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/why_is_my_event_loop_still_alive/</guid>
      <description>You can find the source to this demo in my repo.&#xA;It all started with tests Well, not a failed test, but I ran into an issue with the node built-in test runner where my unit tests completed, but my test runner wouldn&amp;rsquo;t exit.</description>
      <content:encoded><![CDATA[<p>You can find the <a href="https://github.com/GoWind/algorithms/tree/master/async_hooks_demo">source</a> to this demo in my repo.</p>
<h4 id="it-all-started-with-tests">It all started with tests</h4>
<p>Well, not a failed test, but I ran into an issue with the node built-in test runner where my unit tests completed, but my test runner wouldn&rsquo;t exit.
Frustrated, I switched to Jest, which detected that there might be <code>open handles</code> keeping my code from exiting.
Running <code>Jest</code> with <code>--detectOpenHandles</code>, I was able to figure out that there was a Redis connection object in my code
that was opened, but never closed, which prevented the event loop from returning (and thus exiting).</p>
<p>I didn&rsquo;t really understand why this would keep my event loop from exiting, but digging through the Node API, it
looks like certain objects (like Timers, Sockets etc) can keep the event loop from exiting. An <a href="https://github.com/search?q=repo%3Anodejs%2Fnode%20path%3A%2F%5Edoc%5C%2Fapi%5C%2F%2F%20unref&amp;type=code"><code>unref</code></a> API function
is used to detach an object from the event loop&rsquo;s exit condition (and similary a <code>hasRef()</code> fn tells us if an object that isn&rsquo;t closed can keep an event loop alive or not)</p>
<p>Asking chatGPT how to detect objects that might keep the event loop alive, I stumbled across <a href="https://github.com/mafintosh/why-is-node-running">why-is-node-running</a>, a library that uses Node&rsquo;s <a href="https://nodejs.org/dist/latest-v20.x/docs/api/async_hooks.html">async hooks</a> to track the lifecycle of async objects.</p>
<p>Using the <a href="https://nodejs.org/dist/latest-v20.x/docs/api/async_hooks.html#initasyncid-type-triggerasyncid-resource"><code>init</code></a> hook, we can hook into async objects (such as Promises, Timeouts, Immediate&rsquo;s etc) when they are created.
When running my init and destroy hooks, however, the only kind of info I could access was the <code>type</code> of the async object and an <code>id</code> associated with it, but nothing else.</p>
<p>But how do we know which part of the code (is it our code, a library, or an Node JS built-in) created it ?</p>
<p>Here is where <code>why-is-node-running</code> uses an interesting trick. The V8 JS library is used by NodeJS as the JS interpreter/JITcompiler (a lot of the speed of NodeJS can be attributed to just how much wicked fast V8 is). V8 has a API that allows one to customize the <code>Error</code> object in Javascript.
More specifically, V8 adds a <code>.stack</code> property to the Error object in Javascript, that contains the trace of the last 10 (customizable) function frames in the stack, leading upto the function where the Error object was created. The trace (stored at .stack propery) is a formatted string.</p>
<p>For example, here is the value of <code>Error.stack</code> on my Node Repl:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">$</span> <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Welcome</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">Node</span>.<span style="color:#a6e22e">js</span> <span style="color:#a6e22e">v20</span>.<span style="color:#ae81ff">6.1</span>.
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Type</span> <span style="color:#e6db74">&#34;.help&#34;</span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">more</span> <span style="color:#a6e22e">information</span>.
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">myFunc</span>() {
</span></span><span style="display:flex;"><span>...   <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;abced&#34;</span>);
</span></span><span style="display:flex;"><span>...   <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">stack</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>... }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">undefined</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">myFunc</span>();
</span></span><span style="display:flex;"><span>Error<span style="color:#f92672">:</span> <span style="color:#a6e22e">abced</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">myFunc</span> (<span style="color:#a6e22e">REPL14</span><span style="color:#f92672">:</span><span style="color:#ae81ff">2</span><span style="color:#f92672">:</span><span style="color:#ae81ff">13</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">REPL15</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">Script</span>.<span style="color:#a6e22e">runInThisContext</span> (<span style="color:#a6e22e">node</span><span style="color:#f92672">:</span><span style="color:#a6e22e">vm</span><span style="color:#f92672">:</span><span style="color:#ae81ff">122</span><span style="color:#f92672">:</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">REPLServer</span>.<span style="color:#a6e22e">defaultEval</span> (<span style="color:#a6e22e">node</span><span style="color:#f92672">:</span><span style="color:#a6e22e">repl</span><span style="color:#f92672">:</span><span style="color:#ae81ff">593</span><span style="color:#f92672">:</span><span style="color:#ae81ff">29</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">bound</span> (<span style="color:#a6e22e">node</span><span style="color:#f92672">:</span><span style="color:#a6e22e">domain</span><span style="color:#f92672">:</span><span style="color:#ae81ff">433</span><span style="color:#f92672">:</span><span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">REPLServer</span>.<span style="color:#a6e22e">runBound</span> [<span style="color:#a6e22e">as</span> eval] (<span style="color:#a6e22e">node</span><span style="color:#f92672">:</span><span style="color:#a6e22e">domain</span><span style="color:#f92672">:</span><span style="color:#ae81ff">444</span><span style="color:#f92672">:</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">REPLServer</span>.<span style="color:#a6e22e">onLine</span> (<span style="color:#a6e22e">node</span><span style="color:#f92672">:</span><span style="color:#a6e22e">repl</span><span style="color:#f92672">:</span><span style="color:#ae81ff">923</span><span style="color:#f92672">:</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">REPLServer</span>.<span style="color:#a6e22e">emit</span> (<span style="color:#a6e22e">node</span><span style="color:#f92672">:</span><span style="color:#a6e22e">events</span><span style="color:#f92672">:</span><span style="color:#ae81ff">526</span><span style="color:#f92672">:</span><span style="color:#ae81ff">35</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> <span style="color:#a6e22e">REPLServer</span>.<span style="color:#a6e22e">emit</span> (<span style="color:#a6e22e">node</span><span style="color:#f92672">:</span><span style="color:#a6e22e">domain</span><span style="color:#f92672">:</span><span style="color:#ae81ff">489</span><span style="color:#f92672">:</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">at</span> [<span style="color:#a6e22e">_onLine</span>] [<span style="color:#a6e22e">as</span> <span style="color:#a6e22e">_onLine</span>] (<span style="color:#a6e22e">node</span><span style="color:#f92672">:</span><span style="color:#a6e22e">internal</span><span style="color:#f92672">/</span><span style="color:#a6e22e">readline</span><span style="color:#f92672">/</span><span style="color:#66d9ef">interface</span><span style="color:#f92672">:</span><span style="color:#ae81ff">416</span><span style="color:#f92672">:</span><span style="color:#ae81ff">12</span>)</span></span></code></pre></div><p>The formatted string stored at <code>.stack</code> can be customized. You can do this by attaching a function to the <code>prepareStackTrace</code> property of the error <code>Error</code> object. This is a function of 2 params: The Error object created and an array of callsites, where callsite is a function present in the stack above the fn where the Error object is created. The return value of this <code>prepareStackTrace</code> function is stored in the <code>Error.stack</code> property when <code>new Error(...)</code> is created. You can find more information about this in the <a href="https://v8.dev/docs/stack-trace-api">Stack Trace API</a> documentation.</p>
<p><code>why-is-node-running</code> uses this trick to store a trace of the code where the async object is created. When a new async object (Promise, Timeout etc) is created, the init hooks runs. In the hook fn, the library creates a error object that is tracked along with the async object, thus pointing to where this object was initialized</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>  <span style="color:#a6e22e">init</span> (<span style="color:#a6e22e">asyncId</span>, <span style="color:#a6e22e">type</span>, <span style="color:#a6e22e">triggerAsyncId</span>, <span style="color:#a6e22e">resource</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">type</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;TIMERWRAP&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">type</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;PROMISE&#39;</span>) <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">type</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;PerformanceObserver&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">type</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;RANDOMBYTESREQUEST&#39;</span>) <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;whatevs&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">stacks</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">stackback</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">active</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">asyncId</span>, {<span style="color:#a6e22e">type</span>, <span style="color:#a6e22e">stacks</span>, <span style="color:#a6e22e">resource</span>})</span></span></code></pre></div><p><code>Stackback</code> is a library that provides some helpers around extracting the info. about the fn frames leading to the Error object</p>
<p>The <code>active</code> object is a global Map mapping each <code>asyncId</code> to its type, the stack of fns in the Error.</p>
<p>When you need the information about why your node process is kept alive, you call the <code>whyIsNodeRunning</code> function, which iterates through the list of all async object created, identifies the ones that can keep the even loop alive (for example, Unresolved Promises do not keep the event loop alive). The objects that can keep the event loop alive, have a <code>hasRef</code> function that returns <code>true</code> when called.  An extract from the <code>why-is-node-running</code> library:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">whyIsNodeRunning</span> (<span style="color:#a6e22e">logger</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">logger</span>) <span style="color:#a6e22e">logger</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">console</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">hook</span>.<span style="color:#a6e22e">disable</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">activeResources</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">active</span>.<span style="color:#a6e22e">values</span>()].<span style="color:#a6e22e">filter</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">r</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">resource</span>.<span style="color:#a6e22e">hasRef</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;function&#39;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">resource</span>.<span style="color:#a6e22e">hasRef</span>()
</span></span><span style="display:flex;"><span>    ) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">logger</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#39;There are %d handle(s) keeping the process running&#39;</span>, <span style="color:#a6e22e">activeResources</span>.<span style="color:#a6e22e">length</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">o</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">activeResources</span>) <span style="color:#a6e22e">printStacks</span>(<span style="color:#a6e22e">o</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">printStacks</span> (<span style="color:#a6e22e">o</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">stacks</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">stacks</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">1</span>).<span style="color:#a6e22e">filter</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">s</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">filename</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">getFileName</span>()
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">filename</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">filename</span>.<span style="color:#a6e22e">indexOf</span>(<span style="color:#a6e22e">sep</span>) <span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">filename</span>.<span style="color:#a6e22e">indexOf</span>(<span style="color:#e6db74">&#39;internal&#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">sep</span>) <span style="color:#f92672">!==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    })</span></span></code></pre></div><p>Well if my Node instance is stuck, how do I trigger this function ?</p>
<p>Enter Unix Signals.</p>
<p>We can send a Signal to a process, which triggers a signal handler to handle it. Some Signals (like KILL, SEGV) cannot be handled and the process terminates, but there are standard signals that can be customized and handled by our process. For example, SIGUSR1 and SIGUSR2 can be customized by the program for Interprocess communication or custom signal handling etc (you can also use SIGPIPE, because Node by default ignores SIGPIPE)</p>
<p>In NodeJS, we can setup a signal handler on our process to execute a function when a signal is received. I set up
the signal handler in my demo, to trigger the function that iterates through the map of async objects created to see
what object could possibly keeping the program alive</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;SIGUSR1&#39;</span>, () =&gt; { <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;captured sigterm&#34;</span>) ; <span style="color:#a6e22e">showMeTheCulprit</span>(<span style="color:#a6e22e">fd</span>)});</span></span></code></pre></div><h4 id="caveats">Caveats</h4>
<p>Async Hooks have a <a href="https://github.com/nodejs/benchmarking/issues/181">performance impact</a>. It might be prudent to have this instrumentation as an alternate <code>main</code> function of sorts, to be used only when you run into issues and have to debug the program and not running all the time in Production</p>
<h4 id="conclusion">Conclusion</h4>
<p>Researching on this topic was a fantastic way for me to learn a bit more about NodeJS internals and how asynchronous object work :) To more such hacking and learning</p>
]]></content:encoded>
    </item>
    <item>
      <title>WTF is `glibc`?</title>
      <link>https://gowind.github.io/post/what_is_glibc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/what_is_glibc/</guid>
      <description>C is a language + a standard that lists out certain features that has to be provided.</description>
      <content:encoded><![CDATA[<p>C is a language + a standard that lists out certain features that has to be provided.
There are 2 standareds -</p>
<ol>
<li><code>ANSI</code> or <code>standard</code> C (open, read, write, printf etc)</li>
<li><code>POSIX</code> C (pthreads semaphores, mutexes etc)</li>
</ol>
<p>Each standard provides a set of functionality, a lot of which need to call operating specific functions (System calls).</p>
<p><code>glibc</code> (or GNU C library), and other C libraries, provide the interface <code>headers</code> and <code>functions</code>  that  call the operating system specific routines/system calls etc to provide the functionality defined in <code>ANSI</code> or <code>POSIX</code></p>
<p>Note; <code>ANSI</code> and <code>POSIX</code> seem to be the most standard. OSes like Linux have additional APIs that are also provided by <code>glibc</code> , but they are probably not standard across operating systems.</p>
<p>WTF is <code>musl</code> ?
<code>glibc</code> is heavy, because it provides A LOT of features.
<code>musl</code> is an alternative <code>glibc</code> implementation that is more lightweight and can also be <strong>statically linked</strong>.</p>
<p><code>statically</code> linked =&gt; no need of a <code>libc.so</code> needed at runtime to run the executable.</p>
<p>For more information look at how Executables in Linux are actually executed in [[From Source Code to Hello World/ELFs and Loaders]]</p>
<h3 id="how-to-link-an-application-with-musl">How to link an application with <code>musl</code></h3>
<p><code>glibc</code> The GNU C library
TODO:</p>
<h3 id="musl--documentation">Musl  documentation</h3>
<p>Start from <a href="https://musl.libc.org/doc/1.1.24/manual.html">Part III - Programmer&rsquo;s Manual</a></p>
<h3 id="once-we-link-an-application-how-can-we-tell-the-difference-">Once we link an application, how can we tell the difference ?</h3>
<p>TODO:</p>
]]></content:encoded>
    </item>
    <item>
      <title>x86 calling convention</title>
      <link>https://gowind.github.io/post/x86_calling_convention/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>mailto:petrovgovind@gmail.com (Govind)</author>
      <guid>https://gowind.github.io/post/x86_calling_convention/</guid>
      <description>Introduction Note : While the title of the Folder is Linux Stuff, I am filing this article, which is about x86 architecture in general, under Linux stuff for now</description>
      <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p><strong>Note</strong> : While the title of the Folder is <code>Linux Stuff</code>, I am filing this article, which is about x86 architecture in general, under Linux stuff for now</p>
<p>Also a good <a href="https://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/">source</a> for understanding how a stack is pushed/popped and the calling convention.</p>
<h2 id="what-is-a-calling-convention-">What is a calling convention ?</h2>
<p>A calling convention is a standardized  way of passing function arguments and return values to and from function in x86 assembly.</p>
<h3 id="why-do-we-need-a-calling-convention-">Why do we need a calling convention ?</h3>
<p>Interoperability. The operating system for eexample, provides a libc: [[[What is <code>glibc</code>]], that is in the form of a dynamic  library.</p>
<p>A lot of other libraries and opeerating systems provide functionality via shared or static libraries <code>.dll</code>, <code>.so</code>, <code>.a</code> files etc.</p>
<p>The advantage of this format is you can use any language that can compile code to assembly to use these libraries.</p>
<p>But to do so, you need to know  how to communicate with these dynamic libraries.</p>
<p>The calling convention is the protocol for applications to call into such shared library functions.</p>
<p>Calling convention depends on the version of the x86 architecture (32-bit vs 64 bit), and there are slightly different versions of Calling Conventions (cdecl, fastcall, slowcall, etc). More information <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#Register_preservation">here</a></p>
<p>Here let us take a look <code>cdecl</code> and how it deals with the stack. This version deals with the 32-bit architecture</p>
<h3 id="x86-basics">X86 basics</h3>
<p>Memory is linear and addressed in terms of bytes.
The Stack of a function grows towards lower addresses.
The Heap of a the program grows higher.</p>
<h3 id="pushing-and-popping-esp">Pushing and popping <code>esp</code></h3>
<p>esp -&gt; Points to the top of he stack.
esp is always aligned to a 4-byte address / 16? byte address (esp modulo 32 == 0)</p>
<h4 id="push">Push</h4>
<p>push <code>x</code> -&gt; Pushes <code>x</code> to the top of the stack
<strong>Basically</strong>:
esp = esp - 4
Memory[esp] = <code>x</code></p>
<h4 id="pop">Pop</h4>
<p>pop <code>target</code>
pops the top of the stack into <code>target</code> (register, or memory address)
Memory[target] (or target registry) = Memory[esp]
esp = esp - 4</p>
<h3 id="base-pointer">Base Pointer</h3>
<p><code>ebp</code>, or the Base pointer, points to the Base of a function&rsquo;s stack.</p>
<h3 id="alignment">Alignment</h3>
<p>Stack must be multiple of 8 aligned before doing a <code>call</code> instruction, otherwise it will segfault.</p>
<h3 id="order-of-operands">Order of operands</h3>
<p>Operands to functions are passed via registers. Registers are chosen as follows</p>
<ul>
<li>For integers and pointers, <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code>.
-  For floating-point (float, double), <code>xmm0</code>, <code>xmm1</code>, <code>xmm2</code>, <code>xmm3</code>, <code>xmm4</code>, <code>xmm5</code>, <code>xmm6</code>, <code>xmm7</code>.</li>
</ul>
<h3 id="return-values">Return values</h3>
<p>return values are stored in <code>rax</code> or <code>rdx:rax</code> in case of integers and <code>xmm0</code> or <code>xmm1:xmm0</code> in case of floats.</p>
<h4 id="interesting-notes">Interesting notes</h4>
<p><strong>LEA</strong>
LEA stands for load effective address. <code>lea</code> doesnt manipulate (read or write to memory address), but is only used for calculating addresses, instead of <code>add</code> or <code>mul</code>.
Why ?</p>
<ol>
<li>Add cannot operate on 3 registers at once. Using <code>lea</code> once can use the [Base Reg + N* Step REG + offset Reg] notation to calculate mem address and store it an anddress</li>
<li>Does not affect <code>EFLAGS</code> as opposed to <code>ADD</code></li>
</ol>
<p>When you see something like <code>lea RDX, [RCX + 4 * RBX  + RAX]</code>, ignore the <code>[]</code>. It is basically <code>RDX = RCX + 4 * RBX  + RAX</code></p>
]]></content:encoded>
    </item>
  </channel>
</rss>
