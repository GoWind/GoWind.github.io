<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://gowind.github.io/favicons" />
<title>From 500 secs to 3.5 - The 1brc Challenge | Gowind&#39;s site</title>
<meta name="title" content="From 500 secs to 3.5 - The 1brc Challenge" />
<meta name="description" content="All measurements run on an M2Pro Macbook 16&quot; with 32GB RAM.
For those of you that aren&rsquo;t aware of the 1brc challenge, the goal is to parse 1 billion rows in a plain text file, each row mapping a city to the temperature observed on a particular day and computing the min,max,average and total temperatures of each city." />
<meta name="keywords" content="" />






  
  <meta property="og:title" content="From 500 secs to 3.5 - The 1brc Challenge" />
<meta property="og:description" content="All measurements run on an M2Pro Macbook 16&quot; with 32GB RAM.
For those of you that aren&rsquo;t aware of the 1brc challenge, the goal is to parse 1 billion rows in a plain text file, each row mapping a city to the temperature observed on a particular day and computing the min,max,average and total temperatures of each city." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gowind.github.io/post/1brc/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-01-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-01-20T00:00:00+00:00" /><meta property="og:site_name" content="Gowind&#39;s site" />



  
  <meta name="twitter:card" content="summary"/><meta name="twitter:title" content="From 500 secs to 3.5 - The 1brc Challenge"/>
<meta name="twitter:description" content="All measurements run on an M2Pro Macbook 16&quot; with 32GB RAM.
For those of you that aren&rsquo;t aware of the 1brc challenge, the goal is to parse 1 billion rows in a plain text file, each row mapping a city to the temperature observed on a particular day and computing the min,max,average and total temperatures of each city."/>
<meta name="twitter:site" content="@DeepknowledgeU"/>


  
  <meta itemprop="name" content="From 500 secs to 3.5 - The 1brc Challenge">
<meta itemprop="description" content="All measurements run on an M2Pro Macbook 16&quot; with 32GB RAM.
For those of you that aren&rsquo;t aware of the 1brc challenge, the goal is to parse 1 billion rows in a plain text file, each row mapping a city to the temperature observed on a particular day and computing the min,max,average and total temperatures of each city."><meta itemprop="datePublished" content="2024-01-20T00:00:00+00:00" />
<meta itemprop="dateModified" content="2024-01-20T00:00:00+00:00" />
<meta itemprop="wordCount" content="2629">
<meta itemprop="keywords" content="" />

<meta name="referrer" content="no-referrer-when-downgrade" />

  
  <link href="/original.min.css" rel="stylesheet">

  
    
    <link href="/syntax.min.css" rel="stylesheet">
  

  

  
</head>

<body>
  <header><a class="skip-link" href="#main-content">Skip to main content</a>

<a href="/" class="title"><h1>Gowind&#39;s site</h1></a>
<nav>
  <a href="/post/">Posts</a>

  <a href="/">About</a>

<a href='https://gowind.github.io/index.xml'>RSS</a>







</nav>
</header>
  <main id="main-content">

<h1>From 500 secs to 3.5 - The 1brc Challenge</h1>
<p class="byline">
  <time datetime='2024-01-20' pubdate>
    2024-01-20
  </time>
  
</p>

<content>
  <p>All measurements run on an M2Pro Macbook 16&quot; with 32GB RAM.</p>
<p>For those of you that aren&rsquo;t aware of the <a href="">1brc</a> challenge, the goal is to parse 1 billion rows in a plain text file, each row mapping a city to the temperature observed on a particular day and computing the min,max,average and total temperatures of each city.
The output has to be alphabetically sorted based on the name of the city.</p>
<p>The title is a little clickbait-y, because I knew that my initial solution was going to be slow, but yet I still ran it for the sake of it.</p>
<h2 id="if-it-works-it-aint-stupid">If it works, it ain&rsquo;t stupid</h2>
<p>My first solution was to write a dumb shell script. Too lazy, I asked chatGPT to generate an <code>awk</code> script for me to do it and then I ran it on my local machine.</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat average.sh
</span></span><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Input file path</span>
</span></span><span style="display:flex;"><span>input_file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;measurements.txt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Check if the file exists</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -f <span style="color:#e6db74">&#34;</span>$input_file<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Error: File not found: </span>$input_file<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use awk to calculate average temperature per city</span>
</span></span><span style="display:flex;"><span>awk -F<span style="color:#e6db74">&#39;;&#39;</span> <span style="color:#e6db74">&#39;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    city = $1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    temperature = $2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sum[city] += temperature
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    count[city]++
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">END {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    for (city in sum) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        average = sum[city] / count[city]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf &#34;City: %s, Average Temperature: %.2f\n&#34;, city, average
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}&#39;</span> <span style="color:#e6db74">&#34;</span>$input_file<span style="color:#e6db74">&#34;</span></span></span></code></pre></div><p>The result ? 487 secs for a single run.</p>
<p>That shell scripts are slow is a known thing. What next ? I didn&rsquo;t want to spend too much time on it, so I wrote a similar script in Javascript with a single thread (I lost the code for it, but it isn&rsquo;t too hard to write). The script didn&rsquo;t do much faster, running at about 460ish seconds (even V8 can only do so much I guess).</p>
<h2 id="going-brrr">Going brrr</h2>
<p>How do I make this faster ? This problem is trivially parallelizable. Since each line is a separate entry, we can split the giant file to be worked on by different <code>worker</code> threads and then merge the results of all the <code>worker</code> threads together in the main thread. The tricky bit is how do we split the file ?</p>
<p>We can use the <a href="https://linux.die.net/man/2/stat">stat</a> api to find the size of a file without having to read the entire file.
Once we know the size of the file, we can split it into chunks , where chunk size = <code>sizeof(file)/num_threads</code>. Each thread will read the lines present between bytes : [ <code>thread_index * chunk_size</code> &hellip; <code>(thread_index + 1) * chunk_size</code>] and in a thread local HashMap, map each city =&gt; number of times we saw an entry for the city , the min , max temperatures and the total sum of all the temperatures we have seen.
Once the threads sum up their chunk of the file, we then merge the results of these local HashMap into a global HashMap to calculate each city&rsquo;s min, max and avg. temperatures.</p>
<p>The file is made of lines like <code>Vienna;19.1\nPhoenix;16.1\n</code>. The <code>\n</code> at the end and the <code>V</code> at the beginning might not align exactly for all the chunks of our threads. What do we do in that case ?</p>
<p>Before a thread begins to process a chunk, we need to adjust its start and end offsets such that the start offset starts at a character right after a <code>\n</code> (thus a new entry) and adjust the end character so that it aligns with a <code>\n</code> .</p>
<p>Here is how I did it in my code</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">startOffset</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">buf</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">readHundred</span>(<span style="color:#a6e22e">handle</span>, <span style="color:#a6e22e">startOffset</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">buf</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>) {
</span></span><span style="display:flex;"><span> } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nextPos</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nextNewLine</span>(<span style="color:#a6e22e">buf</span>, <span style="color:#e6db74">&#34;start&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">startOffset</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nextPos</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">startOffset</span>;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">readHundred</span>(<span style="color:#a6e22e">handle</span>, <span style="color:#a6e22e">pos</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Buffer</span>.<span style="color:#a6e22e">alloc</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">results</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">b</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>, <span style="color:#a6e22e">pos</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">results</span>.<span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">slice</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">results</span>.<span style="color:#a6e22e">bytesRead</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>).<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>I took the liberty that each line is less than a 100 chars long, so that we can always find the <code>\n</code> by just reading 100 chars past the start offset.</p>
<p>Similarly for the end offset</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">endOffset</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">totalSize</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">buf</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">readHundred</span>(<span style="color:#a6e22e">handle</span>, <span style="color:#a6e22e">endOffset</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">buf</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">buf</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;\x00&#34;</span>) {
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nn</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nextNewLine</span>(<span style="color:#a6e22e">buf</span>, <span style="color:#e6db74">&#34;end&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">endOffset</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">nn</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">endOffset</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">nextNewLine</span>(<span style="color:#a6e22e">buffer</span>, <span style="color:#a6e22e">ev</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">buffer</span>.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">j</span>.<span style="color:#a6e22e">length</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">j</span>[<span style="color:#a6e22e">x</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Once the thread finds the start and the end offsets for each chunk,it creates a stream between the 2 offsets and iterates through them line by line :</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">readStream</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">handle</span>.<span style="color:#a6e22e">createReadStream</span>({<span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">startOffset</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">endOffset</span>});
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rl</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">readline</span>.<span style="color:#a6e22e">createInterface</span>({
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">input</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">readStream</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">crlfDelay</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">Infinity</span> <span style="color:#75715e">// To handle Windows line endings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rl</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;line&#39;</span>, (<span style="color:#a6e22e">row</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">processRow</span>(<span style="color:#a6e22e">row</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rl</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;close&#39;</span>, () =&gt; {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">wrapUp</span>();
</span></span><span style="display:flex;"><span>});</span></span></code></pre></div><p>You can find this version of code in <a href="https://github.com/GoWind/1brc/commit/7a64018720365608c5ba8fcb080c63f61cb54f2e">this</a> commit. Running this code with 12 threads (8 E cores and 4 P cores on my M2 Pro machine), I got it run at about 48 secs on avg.</p>
<p>Readline is a rather slow way to iterate over a chunk of data because it reads a chunk of text line by line. When looping over a ReadStream, we can loop over Text Chunks rather than lines and this might be faster (you can find this version of my solution in <a href="https://github.com/GoWind/1brc/commit/3d3be7fd1c51d9304b3cce34bde4d29818db565b">this</a>commit)</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">-const rl = readline.createInterface({
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    input: readStream,
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    crlfDelay: Infinity // To handle Windows line endings
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  });
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-rl.on(&#39;line&#39;, (row) =&gt; {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-  processRow(row);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+for await (const chunk of readStream) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    let res = await handler(chunk);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    if(res == false) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+      break;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    }
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+}
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-rl.on(&#39;close&#39;, () =&gt; {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">- wrapUp();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+async function handler(chunk) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  let updatedChunk = globalBuffer.concat(chunk);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  let rows = updatedChunk.split(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  if(rows.length) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+     if(rows[rows.length-1] == &#34;&#34;) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+        globalBuffer = &#34;&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+        processRows(rows.slice(0, -1));
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+     } else {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+       globalBuffer = rows[rows.length-1];
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+       processRows(rows.slice(0, -1));
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+     }
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+}
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+wrapUp();
</span></span></span></code></pre></div><p>Using chunking as opposed to ReadLine improved the solution by roughly 20%. I was able to get the solution to run on an avg. of 40secs.</p>
<h3 id="faster-">Faster ?</h3>
<p>I was running out of ideas to improve the speed in JS, so time to bring out the BFG 9000: Zig.
As a statically-typed, compiled language, we should be able to (hopefully) run much faster in Zig.
I used the same approach to build a multi-threaded Zig program, using the same offset calculation with threads swapping the JS for Zig.</p>
<h4 id="timing-">Timing ?</h4>
<p>6.7 secs !</p>
<p>I initially got a shock, because I was doing a Debug build and the Debug build ran with an average of 56secs. For a few moments, I was questioning my life decisions and existence in a world where JS was faster than Zig. Running <code>zig build</code> with the <code>Doptimize=ReleaseFast</code> flag turned on optimizations that literally 8xed the speed of my <a href="https://github.com/GoWind/1brc/commit/7760c6dda6930ff4464cc2cc049bf35988960441">solution</a></p>
<p>I was happy, but by this point, the Java peeps had made the Java solution complete in under 6 secs. Can I beat that ?</p>
<h3 id="moaaar-power">Moaaar power</h3>
<p>I wanted to do a couple of tweaks before calling it quits. These tweaks were stuff I found in Danny Van Kooten&rsquo;s <a href="https://github.com/dannyvankooten/1brc/blob/main/analyze.c">solution</a> in C.</p>
<ol>
<li>Use <code>mmap</code> to map the file into the virtual memory, instead of trying to read chunks of the file in each thread to find the start and the end offsets</li>
<li>A faster hashMap implementation</li>
<li>not trying to parse the temperatures as floats</li>
</ol>
<p><a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a> takes the contents of a file and maps it into the virtual memory of a process. This makes reading the file as simple as updating a pointer , while the Filesystem + OS takes care of swapping in and out the parts of the files currently being read. We are not updating the mapping/file, only reading it , so <code>mmap</code>ing the file turned out to be a simple choice</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">-    const file = try std.fs.openFileAbsoluteZ(filepath, .{});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    defer file.close();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const stat = try file.stat();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    std.debug.print(&#34;file size is {}\n&#34;, .{stat.size});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+    const fd = try std.os.open(filepath, std.os.O.RDONLY, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    defer std.os.close(fd);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    const stat = try std.os.fstat(fd);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    const mapping = try std.os.mmap(null, @as(u64, @intCast(stat.size)), std.os.PROT.READ, std.os.MAP.PRIVATE, fd, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    defer std.os.munmap(mapping);
</span></span></span></code></pre></div>




<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#75715e">@@ -43,146 +44,60 @@ fn calculate(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     idx: usize,
</span></span><span style="display:flex;"><span>     workerSize: u64,
</span></span><span style="display:flex;"><span>     allocator: std.mem.Allocator,
</span></span><span style="display:flex;"><span><span style="color:#f92672">-    filepath: [*:0]u8,
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+    file: []u8,
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span> ) !void {
</span></span><span style="display:flex;"><span><span style="color:#f92672">-    var buffer = [_]u8{&#39;a&#39;} ** 80000;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const waterMarkSize: usize = 80000;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const slice = buffer[0..100];
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const View = struct { slice: []u8, len: usize };
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const file = try std.fs.openFileAbsoluteZ(filepath, .{});
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    const stat = try file.stat();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-    defer file.close();
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+    const finalEndOffset = file.len - 1;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>     var startOffset = idx * workerSize;
</span></span><span style="display:flex;"><span>     var endOffset = (idx + 1) * workerSize - 1;
</span></span><span style="display:flex;"><span>     if (startOffset &gt; 0) {
</span></span><span style="display:flex;"><span>         const prev = startOffset - 1;
</span></span><span style="display:flex;"><span><span style="color:#f92672">-        try file.seekTo(prev);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-        const read = try file.readAll(slice);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-        if (read == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            @panic(&#34;failed to read from starting offset&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-        }
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-        if (buffer[0] != &#39;\n&#39;) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            var i: usize = 1;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            while (i &lt; read) : (i += 1) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                if (buffer[i] == &#39;\n&#39;) {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                    startOffset += i;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                    break;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                }
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+        if (file[prev] != &#39;\n&#39;) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            while (file[startOffset] != &#39;\n&#39;) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                startOffset += 1;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>             }
</span></span><span style="display:flex;"><span><span style="color:#f92672">-        }
</span></span></span></code></pre></div><p>I didn&rsquo;t record the timings for [this] change alone, but my measurements varied anywhere from ~5.5-9secs (probably depending on filesystem caches in memory being cold/warm)</p>
<p>The next trick I attempted to use was to parse each temperature as an <code>i32</code> and not as a <code>f32</code>. Float parsing is tricky, and slower than parsing integers. Since each temperature entry in the challenge has only one digit after the decimal point, we can parse <code>16.1</code> as <code>161</code> and divide the final result only by <code>10</code>, thus saving a lot of time spent parsing</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#f92672">-pub const Record = struct { min: f32 = 0, max: f32 = 0, total: f32 = 0, count: u32 = 0 };
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+const SliceList = std.ArrayList([]const u8);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+const writer = std.io.getStdOut().writer();
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+pub const Record = struct { min: i32 = 0, max: i32 = 0, total: i32 = 0, count: u32 = 0 };
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>...
</span></span><span style="display:flex;"><span><span style="color:#f92672">-            const temp = try std.fmt.parseFloat(f32, num);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+            const temp = parsei32(num);
</span></span></span></code></pre></div><p>(Again, I did not record the timings for this change <a href="https://github.com/GoWind/1brc/commit/23fafbfebbb82bafcd9433e1230f89a6c6cdf52a">this</a> change alone)</p>
<p>The last trick I wanted to try was using a custom Hash function / HashMap for tracking city -&gt; temperature stats. From profiling my application with flamegraphs, it was clear that most of the time was spent in looking up a city&rsquo;s existing entry in the threadlocal HashMap. Since our keys are strings, we can use a simple hash function to hash the city names. A simple function that is easy to compute is <a href="https://t.co/C2ZfSSiYSW">djb2</a>. I decided to use this as my hash fn</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">hashSlice</span>(<span style="color:#a6e22e">data</span><span style="color:#f92672">:</span> []<span style="color:#a6e22e">u8</span>, <span style="color:#a6e22e">totalSize</span>: <span style="color:#66d9ef">usize</span>) <span style="color:#a6e22e">usize</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">k</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">hash</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">k</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">len</span>) <span style="color:#f92672">:</span> (<span style="color:#a6e22e">k</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">hash</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">hash</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">31</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">k</span>]) <span style="color:#f92672">&amp;</span> (<span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hash</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>As for a HashMap, is there a faster way ? We know that there aren&rsquo;t a lot of cities in the entry, so we probably can get away with replacing the thread local HashMap with an array instead (actually 2 arrays)</p>
<ol>
<li>We create a threadlocal array with 2^16 entries and fill each of them with a <code>0</code>.</li>
<li>We create another array: <code>entries</code>, with index <code>i</code> starting at 0. Each new string is provided a new index in this array. The values of entries are all set to a sentinel value.</li>
<li>We hash each string and then perform a module of that hash with (2^16-1) thus getting a number N between [0, 2^16-1].</li>
<li>We then start at array[N] and proceed with N = (N+ 1) % 2^16-1 , till array[N] == Sentinel Value or array[N] == N.</li>
<li>if entries[N] is a Sentinel Value, it means we have not encountered string S yet. We create a Record for this city at <code>entries[N]</code> and set Array[N] = N</li>
<li>Else, it means we already have a valid entry for the city S. We then simply update the count and the min,max and average of the City at entries[N]</li>
</ol>
<p>It is probably much simpler to understand the code:</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#a6e22e">+    var hashList = try NumList.initCapacity(allocator, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    var indexList = try NumList.initCapacity(allocator, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    hashList.appendNTimesAssumeCapacity(0, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    indexList.appendNTimesAssumeCapacity(1 &lt;&lt; 16, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>// 1 &lt;&lt; 16 is the sentinel value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            const maybeEntry = threadMap[idx].getEntry(city);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-            if (maybeEntry) |entry| {
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                entry.value_ptr.*.count += 1;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                entry.value_ptr.*.total += temp;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                entry.value_ptr.*.max = @max(entry.value_ptr.*.max, temp);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                entry.value_ptr.*.min = @min(entry.value_ptr.*.min, temp);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+            var hashVal = hashSlice(city, maxSize);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            while (hashList.items[hashVal] != hashVal and hashList.items[hashVal] != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                hashVal = (hashVal + 1) &amp; (maxSize - 1);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            }
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            const entryIdx = indexList.items[hashVal];
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+            if (entryIdx == 1 &lt;&lt; 16) {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                const cityNameForRec = try allocator.alloc(u8, city.len);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                @memcpy(cityNameForRec, city);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                const rec = Record{ .city = cityNameForRec, .count = 1, .min = temp, .max = tem
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>p, .total = temp };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                try threadMap[idx].append(rec);
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                indexList.items[hashVal] = threadMap[idx].items.len - 1;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                hashList.items[hashVal] = hashVal;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>             } else {
</span></span><span style="display:flex;"><span><span style="color:#f92672">-                const rec = Record{ .count = 1, .min = temp, .max = temp, .total = temp };
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                const k = try allocator.alloc(u8, city.len);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                @memcpy(k, city);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">-                try threadMap[idx].put(k, rec);
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+                threadMap[idx].items[entryIdx].count += 1;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                threadMap[idx].items[entryIdx].total += temp;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                threadMap[idx].items[entryIdx].max = @max(threadMap[idx].items[entryIdx].max, t
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>emp);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+                threadMap[idx].items[entryIdx].min = @min(threadMap[idx].items[entryIdx].min, t
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>emp);
</span></span><span style="display:flex;"><span>             }
</span></span></code></pre></div><p>We replaced the zig HashMap with our custom one. So how did the end result go ?</p>
<h4 id="answer-faaast-">Answer: Faaast !</h4>
<p>The <a href="https://github.com/GoWind/1brc/commit/dfc37a92b5fcb835dc994e48ef54eab060fd03bb?diff=unified&amp;w=1">updated</a>solution hit ~3.5 secs on the average. This was almost 2x faster than our previous solution ! I was elated that such simple optimizations could make such a big difference.</p>
<p>I wanted to proceed with more optimizations to make the solution go even faster, but unfortunately I no longer had the time to pursue the project , and having hit the deadline I set for myself, was happy to have come so far. Also given that my daily driver is a Mac, it was very hard to generate flamegraphs for Zig programs and trying to optimize programs without them is like trying to navigate a race course blind. In the end, I decided to wrap up the experiments and call it a day</p>
<h2 id="takeaways">Takeaways</h2>
<p>Zig is faaaast ! More than that, it makes doing things that could be done by C (mmap, allocations) etc so much simpler. The only language wart that I still hate is that I never know when it copies a data structure vs when it doesn&rsquo;t , so I ended up spending a lot of time debugging subtle bugs.</p>
<p>For example, take this update in a fn that runs in a worker thread</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">TempMap</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">std</span>.<span style="color:#a6e22e">StringHashMap</span>(<span style="color:#a6e22e">Record</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">threadMap</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">numWorkers</span>]<span style="color:#a6e22e">RecordList</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">threads</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">numWorkers</span>]<span style="color:#a6e22e">std</span>.<span style="color:#a6e22e">Thread</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">undefined</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">NumList</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">std</span>.<span style="color:#a6e22e">ArrayList</span>(<span style="color:#a6e22e">usize</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">maxSize</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">14</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pub</span> <span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">main</span>() <span style="color:#f92672">!</span><span style="color:#66d9ef">void</span> {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">calculate</span>(...) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">total</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">temp</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">max</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">@max</span>(<span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">max</span>, <span style="color:#a6e22e">temp</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">min</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">@min</span>(<span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>].<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">min</span>, <span style="color:#a6e22e">temp</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>In fn <code>calculate</code>, I had done</p>





<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">threadMap</span>[<span style="color:#a6e22e">idx</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">items</span>[<span style="color:#a6e22e">entryIdx</span>].<span style="color:#a6e22e">total</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">temp</span>;</span></span></code></pre></div><p>What happened was, this created a new copy of <code>threadMap[idx]</code> for each thread  in the fn calculate and the updates were going into this copy <code>t</code> , rather than at <code>threadMap[idx]</code>. As a result, after my threads finished running, when attempting to merge all the entries from each thread&rsquo;s threadMap, I was running into empty maps, because none of the entries added to <code>t</code> were actually added to <code>threadMap[idx]</code>. The fix was simple, but the lack of docs or syntax about move semantics or copy constructors makes it sometimes a frustrating experience.</p>
<p>In the end though, the ability of Zig to provide the speed of C with a far better syntax and APIs make these frustrations vanish. Happy Hacking !</p>

</content>
<p>
  
</p>

  <p>
    <a href='mailto:mailto:petrovgovind@gmail.com?subject=Reply%20to%20"From%20500%20secs%20to%203.5%20-%20The%201brc%20Challenge"'>
      Reply to this post by email ↪
    </a>
  </p>


  </main>
  <footer><small>
   | 
</small></footer>

    
</body>

</html>
