<!DOCTYPE html><html lang="en" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.9.1"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://gowind.github.io/blog/modulo_to_the_rescue/"><!-- Primary Meta Tags --><title>Modulo to the Resuce</title><meta name="title" content="Modulo to the Resuce"><meta name="description" content="An interesting algorithm to calculate linear index from a 3-D one"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://gowind.github.io/blog/modulo_to_the_rescue/"><meta property="og:title" content="Modulo to the Resuce"><meta property="og:description" content="An interesting algorithm to calculate linear index from a 3-D one"><meta property="og:image" content="https://gowind.github.io/blog-placeholder-1.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://gowind.github.io/blog/modulo_to_the_rescue/"><meta property="twitter:title" content="Modulo to the Resuce"><meta property="twitter:description" content="An interesting algorithm to calculate linear index from a 3-D one"><meta property="twitter:image" content="https://gowind.github.io/blog-placeholder-1.jpg"><!-- Cloudflare Web Analytics --><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;4de85a62d838459fafd8a042c2f1c7c2&quot;}"></script><!-- End Cloudflare Web Analytics --><style>:root{--accent: #2337ff;--accent-dark: #000d8a;--black: 15, 18, 25;--gray: 96, 115, 159;--gray-light: 229, 233, 240;--gray-dark: 34, 41, 57;--gray-gradient: rgba(var(--gray-light), 50%), #fff;--box-shadow: 0 2px 6px rgba(var(--gray), 25%), 0 8px 24px rgba(var(--gray), 33%), 0 16px 32px rgba(var(--gray), 33%)}@font-face{font-family:Atkinson;src:url(/fonts/atkinson-regular.woff) format("woff");font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:Atkinson;src:url(/fonts/atkinson-bold.woff) format("woff");font-weight:700;font-style:normal;font-display:swap}body{font-family:Atkinson,sans-serif;margin:0;padding:0;text-align:left;background:linear-gradient(var(--gray-gradient)) no-repeat;background-size:100% 600px;word-wrap:break-word;overflow-wrap:break-word;color:rgb(var(--gray-dark));font-size:20px;line-height:1.7}main{width:720px;max-width:calc(100% - 2em);margin:auto;padding:3em 1em}h1,h2,h3,h4,h5,h6{margin:0 0 .5rem;color:rgb(var(--black));line-height:1.2}h1{font-size:3.052em}h2{font-size:2.441em}h3{font-size:1.953em}h4{font-size:1.563em}h5{font-size:1.25em}strong,b{font-weight:700}a,a:hover{color:var(--accent)}p{margin-bottom:1em}.prose p{margin-bottom:2em}textarea{width:100%;font-size:16px}input{font-size:16px}table{width:100%}img{max-width:100%;height:auto;border-radius:8px}code{padding:2px 5px;background-color:rgb(var(--gray-light));border-radius:2px}pre{padding:1.5em;border-radius:8px}pre>code{all:unset}blockquote{border-left:4px solid var(--accent);padding:0 0 0 20px;margin:0;font-size:1.333em}hr{border:none;border-top:1px solid rgb(var(--gray-light))}@media (max-width: 720px){body{font-size:18px}main{padding:1em}}.sr-only{border:0;padding:0;margin:0;position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);clip-path:inset(50%);white-space:nowrap}.tag{display:inline-block;background-color:#f3f4f6;border-radius:.5rem;padding:.25rem .75rem;margin:0 .5rem .5rem 0;font-size:.875rem;font-weight:600;color:#4b5563}header[data-astro-cid-3ef6ksr2]{margin:0;padding:0 1em;background:#fff;box-shadow:0 2px 8px rgba(var(--black),5%)}h2[data-astro-cid-3ef6ksr2]{margin:0;font-size:1em}nav[data-astro-cid-3ef6ksr2]{display:flex;align-items:center;justify-content:space-between}nav[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{padding:1em .5em;color:var(--black);border-bottom:4px solid transparent;text-decoration:none}nav[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]:hover{color:var(--accent);color:#a12323;animation:shake .2s;animation-iteration-count:1;text-shadow:2px 4px rgba(0,0,0,.2);font-weight:bolder}@keyframes shake{0%{transform:translate(1px,1px) rotate(0)}10%{transform:translate(-1px,-2px) rotate(-5deg)}20%{transform:translate(-3px) rotate(5deg)}30%{transform:translate(3px,2px) rotate(0)}40%{transform:translate(1px,-1px) rotate(5deg)}50%{transform:translate(-1px,2px) rotate(-5deg)}60%{transform:translate(-3px,1px) rotate(0)}70%{transform:translate(3px,1px) rotate(-5deg)}80%{transform:translate(-1px,-1px) rotate(5deg)}90%{transform:translate(1px,2px) rotate(0)}to{transform:translate(1px,-2px) rotate(-5deg)}}nav[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2].active{text-decoration:none;border-bottom-color:#a12323}.social-links[data-astro-cid-3ef6ksr2],.social-links[data-astro-cid-3ef6ksr2] a[data-astro-cid-3ef6ksr2]{display:flex}@media (max-width: 720px){.social-links[data-astro-cid-3ef6ksr2]{display:none}}footer[data-astro-cid-sz7xmlte]{padding:2em 1em 6em;background:linear-gradient(var(--gray-gradient)) no-repeat;color:rgb(var(--gray));text-align:center}.social-links[data-astro-cid-sz7xmlte]{display:flex;justify-content:center;gap:1em;margin-top:1em}.social-links[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]{text-decoration:none;color:rgb(var(--gray))}.social-links[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]:hover{color:rgb(var(--gray-dark))}
a[data-astro-cid-eimmu3lg]{display:inline-block;text-decoration:none}a[data-astro-cid-eimmu3lg].active{font-weight:bolder;text-decoration:underline}
.scrollrectangle[data-astro-cid-bvzihdzo]{position:fixed;right:20px;width:20px;height:100px;background-color:#2c65d7;border-radius:10%;transition:top .3s ease-out;transform-origin:center center;animation:squeeze 1s infinite}@keyframes squeeze{0%{transform:scaleY(1)}50%{transform:scaleY(1.5)}to{transform:scaleY(1)}}main[data-astro-cid-bvzihdzo]{width:calc(100% - 2em);max-width:100%;margin:0}.hero-image[data-astro-cid-bvzihdzo]{width:100%}.hero-image[data-astro-cid-bvzihdzo] img[data-astro-cid-bvzihdzo]{display:block;margin:0 auto;border-radius:12px;box-shadow:var(--box-shadow)}.prose[data-astro-cid-bvzihdzo]{width:720px;max-width:calc(100% - 2em);margin:auto;padding:1em;color:rgb(var(--gray-dark))}.title[data-astro-cid-bvzihdzo]{margin-bottom:1em;padding:1em 0;text-align:center;line-height:1}.title[data-astro-cid-bvzihdzo] h1[data-astro-cid-bvzihdzo]{margin:0 0 .5em}.date[data-astro-cid-bvzihdzo]{margin-bottom:.5em;color:rgb(var(--gray))}.last-updated-on[data-astro-cid-bvzihdzo]{font-style:italic}
</style></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <nav data-astro-cid-3ef6ksr2> <h2 data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2>Govind&#39;s Blog</a></h2> <div class="internal-links" data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Home </a>  <a href="/blog" class="active" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Blog </a>  <a href="/ideas" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Steal My Ideas </a>  <a href="/editor" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Image Editor </a>  </div> <div class="social-links" data-astro-cid-3ef6ksr2> <a href="https://x.com/DeepknowledgeU" target="_blank" data-astro-cid-3ef6ksr2> <span class="sr-only" data-astro-cid-3ef6ksr2>Follow Astro on X</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/twitter" data-astro-cid-3ef6ksr2><path fill="currentColor" d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z" data-astro-cid-3ef6ksr2></path></svg> </a> <a href="https://github.com/Gowind" target="_blank" data-astro-cid-3ef6ksr2> <span class="sr-only" data-astro-cid-3ef6ksr2>My Github</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/github" data-astro-cid-3ef6ksr2><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-3ef6ksr2></path></svg> </a> </div> </nav> </header>  <main data-astro-cid-bvzihdzo> <article data-astro-cid-bvzihdzo> <div class="scrollrectangle" data-astro-cid-bvzihdzo></div> <script type="module">const o=document.querySelector(".ball"),c=document.querySelector("header"),r=document.documentElement.scrollHeight-window.innerHeight,t=c?.offsetHeight;o.style.top=`${t+100}px`;window.addEventListener("scroll",()=>{const n=window.scrollY/r,l=window.innerHeight-100;let e=n*l;e=e>=t+100?e:t+100,o.style.top=`${e}px`});</script> <div class="hero-image" data-astro-cid-bvzihdzo>  </div> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2025-05-29T22:00:00.000Z"> May 30, 2025 </time>  </div> <h1 data-astro-cid-bvzihdzo>Modulo to the Resuce</h1> <hr data-astro-cid-bvzihdzo> </div>  <p>One of the problems on <a href="https://github.com/ScalingIntelligence/KernelBench">KernelBench</a> that Tensara poses as a challenge is the <a href="https://github.com/ScalingIntelligence/KernelBench/blob/main/KernelBench/level1/51_Argmax_over_a_dimension.py">Argmax</a> of a Tensor. Simply put, we find the index of the maximum element in dim d and reduce the array along that dimension, replacing multiple values with the index. Sounds confusing ? Here is a visualization to help you:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="py"><code><span class="line"><span style="color:#F97583">>>></span><span style="color:#E1E4E8"> A</span></span>
<span class="line"><span style="color:#E1E4E8">tensor([[[</span><span style="color:#79B8FF">35</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">21</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">24</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">11</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#E1E4E8">         [ </span><span style="color:#79B8FF">8</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">48</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">39</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">48</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#E1E4E8">         [</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">42</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">20</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">16</span><span style="color:#E1E4E8">]],</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">        [[</span><span style="color:#79B8FF">16</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">37</span><span style="color:#E1E4E8">,  </span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">46</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#E1E4E8">         [</span><span style="color:#79B8FF">40</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">44</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">44</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">47</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#E1E4E8">         [</span><span style="color:#79B8FF">31</span><span style="color:#E1E4E8">,  </span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">40</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">]]])</span></span>
<span class="line"><span style="color:#F97583">>>></span><span style="color:#E1E4E8"> A.argmax(</span><span style="color:#FFAB70">dim</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">tensor([[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#E1E4E8">        [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#E1E4E8">        [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]])</span></span>
<span class="line"><span style="color:#F97583">>>></span><span style="color:#E1E4E8"> A.argmax(</span><span style="color:#FFAB70">dim</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">tensor([[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#E1E4E8">        [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">]])</span></span>
<span class="line"><span style="color:#F97583">>>></span><span style="color:#E1E4E8"> A.argmax(</span><span style="color:#FFAB70">dim</span><span style="color:#F97583">=</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">tensor([[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#E1E4E8">        [</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">]])</span></span></code></pre>
<p>In each of the argmax calculations, we went from a 3-D to a 2-D tensor, replacing a row or a column of values with a single one</p>
<p><img src="/public/argmax1.jpg" alt="Argmax image1">
<img src="/public/argmax2.jpg" alt="Argmax image2"></p>
<p>This is the visualization of a 3-D dimensional Tensor. Dim 0 is one of the 2 2-D matrices, Dim 1 are columns and Dim 2 are the rows.</p>
<p>To calculate Argmax across Dim 1 (the column), we find the largest element in A[n][i][0], A[n][i][1], A[n][i][2], A[n][i][3], where n is [0..1], i is [0..2]</p>
<p>So how can we parallelize calculating argmax via CUDA ?</p>
<p><strong>Note that my kernel might not be the most optimal implementation</strong>, but I still found the algorithm interesting enough to write a blog post about it.</p>
<p>To effectively parallelize, let’s figure out how many threads we must launch and what memory addresses the thread must read and update to calculate the argmax.</p>
<p>From the image above, what happens if we chose dim=1 to calculate Argmax ? Since we are calculating an argmax per column and there are 4 columns in each of A[0] &#x26; A[1], we will calculate 2x4 = 8 values of shape (2, 4).</p>
<p>Let’s choose dim=2, that is calculating argmax per row. With 3 rows in each of A[0] and A[1], we calculate 2x3=6 values of shape (2, 3)</p>
<p>With dim=1, we compare A[0][0][0] with A[1][0][0], A[0][0][1] with A[1][0][1] and thus endup calculating 3x4=12 values of dim (1, 12).</p>
<p>Notice a pattern? For argmax along dim d (where d is 0, 1 or 2), we simply remove shape[d] and multiply the remaining sizes in the shape array. For A, with shape = (2, 3, 4), argmax along dim=1 is shape[0]*shape[2], for dim=2: shape[0]*shape[1] and for dim=3: shape[1]*shape[2]</p>
<p>Great, now we know how many values to calculate, we can launch a CUDA thread for each output value to be calculate. What are the input locations then that each thread must compare to find the argmax ?</p>
<p>For argmax along a specific dimension of a tensor, we’re essentially:</p>
<ol>
<li>Breaking the tensor into “slices” perpendicular to our target dimension</li>
<li>Processing each slice independently</li>
</ol>
<p>I found the algorithm hard to understand without a concrete example, so let’s start with an example and generalize it into an algorithm.</p>
<p>Let’s apply our algorithm to a 5D tensor with shape [2, 3, 4, 5, 6] and argmax over dimension 2</p>
<p>The first thing we do is to calculate the <strong>stride</strong> for each of the dimensions, starting from the last one (dim=4). Since the data in the memory is laid out as a 1-D array, the stride of dim d will tell us how many elements we will jump if we increment the value by 1. For dim=4, stride[4] = 1, as everytime we jump, we move to the next element (think of a jump as moving from column 1 -> 2 in the same row).</p>
<p>For dim=3, <code>stride[3]=shape[4]</code> (think of this as moving from one row to the next, we move by the number of elements / row).</p>
<p>For dim=2, <code>stride[3]=shape[3]*stride[4]</code> (think of this as jumping from one 2-D matrix to the next)
Starting stride[n-1] = 1,</p>
<p>Generalizing, we can calculate <code>stride[i]= shape[i]*stride[i+1]</code> going from i=n-2..0</p>
<p>Next up we calculate <strong>weights</strong>. The weights are used later to map the 1-D index of a CUDA thread to the corresponding multi-dimensional index in the input tensor. The calculation of weights is similar to calculating the stride, except we skip over the dimension along which we are calculating the Argmax</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6A737D">    // dim is the dimension we are calculating argmax over</span></span>
<span class="line"><span style="color:#6A737D">    // Calculate weights for dimension mapping</span></span>
<span class="line"><span style="color:#F97583">    int*</span><span style="color:#E1E4E8"> h_weights </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> new </span><span style="color:#F97583">int</span><span style="color:#E1E4E8">[ndim];</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> running_weight </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    </span></span>
<span class="line"><span style="color:#6A737D">    // Process from right to left, skipping the target dimension</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ndim</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">>=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (i </span><span style="color:#F97583">==</span><span style="color:#E1E4E8"> dim) {</span></span>
<span class="line"><span style="color:#FFAB70">            h_weights</span><span style="color:#E1E4E8">[i] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span><span style="color:#6A737D">  // Not used for the target dimension</span></span>
<span class="line"><span style="color:#F97583">            continue</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">        </span></span>
<span class="line"><span style="color:#FFAB70">        h_weights</span><span style="color:#E1E4E8">[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> running_weight;</span></span>
<span class="line"><span style="color:#E1E4E8">        running_weight </span><span style="color:#F97583">*=</span><span style="color:#FFAB70"> h_shape</span><span style="color:#E1E4E8">[i];</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span></code></pre>
<p>For Argmax(dim=2), our <code>h_weights</code> array will look like this : <code>[90, 30, 0, 6, 1]</code></p>
<p>Why is the <code>h_weights</code> array value calculated as such, especialy with <code>h_weights[dim] = 0 </code> ? Each CUDA thread will find the max of all the <code>shape[dim]</code> values. Inside the kernel, we will plug the value of <code>i</code> ranging from <code>0..shape[dim-]-1</code> in a loop to calculate the index of each element that the thread will be comparing.</p>
<p>Also, note that there are fewer threads that the number of elements since we “remove” shape[dim] before calculating threads=prod(shape). Therefore the weights array will help each thread calculate the right multi-dimensional index in a dimensional space where <code>dim</code> is removed from shape</p>
<p>Let us continue using the example above:</p>
<p>Total elements: 2 × 3 × 4 × 5 × 6 = 720</p>
<p>Elements along dimension 2: 4</p>
<p>Number of slices: 720 ÷ 4 = 180</p>
<p>Let’s map thread ID 42 to 4D indices (excluding dimension 2). Recall that <code>h_weights = [90, 30, 0, 6, 1]</code></p>
<p>We are launching a 1-D thread grid of 1-D thread blocks. We thus have a linear thread index and we derive the index in each dimension to help us iterate over the input array (and store it in the array <code>indices</code>)</p>
<p>We start with the linear index of the thread as the <code>remainder</code> and for each dimension, calculate its position by</p>
<ol>
<li>Dividing by the “weight” of each dimension</li>
<li>Taking the remainder for the next division</li>
</ol>
<p>For dim 0: 42 ÷ 90 = 0 remainder 42</p>
<p>For dim 1: 42 ÷ 30 = 1 remainder 12</p>
<p>For dim 3: 12 ÷ 6 = 2 remainder 0</p>
<p>For dim 4: 0 ÷ 1 = 0 remainder 0</p>
<p>This is exactly like converting between number systems, where each position has a different “base” (the size of the dimension).</p>
<p>From here, it is easy to calculate the 1-D index of each element that a thread must access and compare to calculate the Argmax.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6A737D">    // Find the maximum value along the specified dimension</span></span>
<span class="line"><span style="color:#F97583">    float</span><span style="color:#E1E4E8"> max_val </span><span style="color:#F97583">=</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">INFINITY;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> max_idx </span><span style="color:#F97583">=</span><span style="color:#F97583"> -</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    </span></span>
<span class="line"><span style="color:#6A737D">    // Iterate through all positions along the target dimension</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#FFAB70"> shape</span><span style="color:#E1E4E8">[dim]; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">        // Set the index for the dimension we're iterating over</span></span>
<span class="line"><span style="color:#FFAB70">        indices</span><span style="color:#E1E4E8">[dim] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#E1E4E8">        </span></span>
<span class="line"><span style="color:#6A737D">        // Calculate the flat index into the input array</span></span>
<span class="line"><span style="color:#F97583">        int</span><span style="color:#E1E4E8"> flat_idx </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; j </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> ndim; j</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">            flat_idx </span><span style="color:#F97583">+=</span><span style="color:#FFAB70"> indices</span><span style="color:#E1E4E8">[j] </span><span style="color:#F97583">*</span><span style="color:#FFAB70"> strides</span><span style="color:#E1E4E8">[j];</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">        </span></span>
<span class="line"><span style="color:#6A737D">        // Check if this value is larger than our current max</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">input</span><span style="color:#E1E4E8">[flat_idx] </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> max_val) {</span></span>
<span class="line"><span style="color:#E1E4E8">            max_val </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> input</span><span style="color:#E1E4E8">[flat_idx];</span></span>
<span class="line"><span style="color:#E1E4E8">            max_idx </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span></code></pre>
<p>I tried to write down a paragraph to explain how this loop works, but I will be admit that I cannot describe it in words very well. The best explanation is something like this, if you are comparing along dim=2, then each element you have to compare is <code>shape[3]*shape[4]</code> elements away from one another. We used the generic formula <code>position = i₁ × (D₂ × D₃ × ... × Dₙ) + i₂ × (D₃ × ... × Dₙ) + ... + iₙ</code> where i is the value of each dim in the <code>indices</code> array that we calculated for each thread.
I urge you to use Claude or any LLM and sit and work this with a pen and paper as drawing shapes on paper is worth 10,000 or more digital characters.</p>
<p>Storing the output is straight forward. Since we reduce the output size to prod(shape)/shape[dim] outputs, each thread thus outputs only one value (after iterating over shape[dim] values). Thus the kernel’s final output is</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6A737D">// Iterate over the dimension we're reducing</span></span>
<span class="line"><span style="color:#F97583">   for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#FFAB70"> shape</span><span style="color:#E1E4E8">[dim]; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      ...</span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFAB70">   output</span><span style="color:#E1E4E8">[tid] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> max_idx;</span></span></code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>This was a fun kernel exercise for me. It took me a few days of figuring out (and dealing with a stupid size calculation bug that was giving incorrect outputs for a long while before I fixed it) and I sat on writing this article for a long time due to other commitments. I am pasting the entire program in this post (as the leetgpu snippet sharing feature isn’t working yet). If you find any bugs or an improved algorithm, please do reach out to me as I am always on the lookout for advice from CUDA kernel programming masters</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &#x3C;cuda_runtime.h></span></span>
<span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &#x3C;stdio.h></span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">#define</span><span style="color:#B392F0"> MAX_DIM</span><span style="color:#79B8FF"> 16</span></span>
<span class="line"><span style="color:#F97583">#define</span><span style="color:#B392F0"> TOTAL_SIZE</span><span style="color:#79B8FF"> 2</span><span style="color:#F97583">*</span><span style="color:#79B8FF">3</span><span style="color:#F97583">*</span><span style="color:#79B8FF">4</span></span>
<span class="line"><span style="color:#E1E4E8">__global__ </span><span style="color:#F97583">void</span><span style="color:#B392F0"> argmax</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">const</span><span style="color:#F97583"> float*</span><span style="color:#FFAB70"> input</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> dim</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int*</span><span style="color:#FFAB70"> output</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int*</span><span style="color:#FFAB70"> shape</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> ndim</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int*</span><span style="color:#FFAB70"> strides</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int*</span><span style="color:#FFAB70"> weights</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> slices</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#E1E4E8"> tid </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> blockDim.x </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> blockIdx.x </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> threadIdx.x;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">   if</span><span style="color:#E1E4E8"> (tid </span><span style="color:#F97583">>=</span><span style="color:#E1E4E8"> slices) { </span><span style="color:#F97583">return</span><span style="color:#E1E4E8">; }</span></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#6A737D">   // Initialize indices for this particular slice</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#FFAB70"> indices</span><span style="color:#E1E4E8">[MAX_DIM];</span></span>
<span class="line"><span style="color:#F97583">   for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> ndim; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#FFAB70">      indices</span><span style="color:#E1E4E8">[i] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#6A737D">   // Convert linear index to multi-dimensional indices</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#E1E4E8"> rem </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tid;</span></span>
<span class="line"><span style="color:#F97583">   for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> ndim; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span><span style="color:#6A737D">  // Note: forward order</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (i </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> dim) {</span></span>
<span class="line"><span style="color:#F97583">         int</span><span style="color:#E1E4E8"> idx_i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> rem </span><span style="color:#F97583">/</span><span style="color:#FFAB70"> weights</span><span style="color:#E1E4E8">[i];</span></span>
<span class="line"><span style="color:#FFAB70">         indices</span><span style="color:#E1E4E8">[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> idx_i;</span></span>
<span class="line"><span style="color:#E1E4E8">         rem </span><span style="color:#F97583">%=</span><span style="color:#FFAB70"> weights</span><span style="color:#E1E4E8">[i];</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#6A737D">   // Find the maximum value along the specified dimension</span></span>
<span class="line"><span style="color:#F97583">   float</span><span style="color:#E1E4E8"> max_val </span><span style="color:#F97583">=</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">INFINITY;</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#E1E4E8"> max_idx </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span><span style="color:#6A737D">  // Default to first element</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">   // Calculate the base flat index for this slice (excluding the dimension we're maxing over)</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#E1E4E8"> base_idx </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">   for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; j </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> ndim; j</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (j </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> dim) {</span></span>
<span class="line"><span style="color:#E1E4E8">         base_idx </span><span style="color:#F97583">+=</span><span style="color:#FFAB70"> indices</span><span style="color:#E1E4E8">[j] </span><span style="color:#F97583">*</span><span style="color:#FFAB70"> strides</span><span style="color:#E1E4E8">[j];</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#6A737D">   // Iterate over the dimension we're reducing</span></span>
<span class="line"><span style="color:#F97583">   for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#FFAB70"> shape</span><span style="color:#E1E4E8">[dim]; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">      // Calculate flat index - base index plus offset in the dimension we're iterating</span></span>
<span class="line"><span style="color:#6A737D">      // int flat_idx = base_idx + i * strides[dim];</span></span>
<span class="line"><span style="color:#F97583">      int</span><span style="color:#E1E4E8"> flat_idx </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> base_idx </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">*</span><span style="color:#FFAB70"> strides</span><span style="color:#E1E4E8">[dim];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">      // Find maximum</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">input</span><span style="color:#E1E4E8">[flat_idx] </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> max_val) {</span></span>
<span class="line"><span style="color:#E1E4E8">         max_val </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> input</span><span style="color:#E1E4E8">[flat_idx];</span></span>
<span class="line"><span style="color:#E1E4E8">         max_idx </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i;</span><span style="color:#6A737D">  // Store the index along dim dimension</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFAB70">   output</span><span style="color:#E1E4E8">[tid] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> max_idx;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// Note: input, output, shape are all device pointers to float32 arrays</span></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> solution</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">const</span><span style="color:#F97583"> float*</span><span style="color:#FFAB70"> input</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> dim</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int*</span><span style="color:#FFAB70"> output</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int*</span><span style="color:#FFAB70"> shape</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> ndim</span><span style="color:#E1E4E8">) {    </span></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#E1E4E8">  </span></span>
<span class="line"><span style="color:#6A737D">   // Calculate strides (how many elements to move for each dimension)</span></span>
<span class="line"><span style="color:#F97583">   int*</span><span style="color:#E1E4E8"> h_strides </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int*</span><span style="color:#E1E4E8">) </span><span style="color:#B392F0">malloc</span><span style="color:#E1E4E8">(ndim </span><span style="color:#F97583">*</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#FFAB70">   h_strides</span><span style="color:#E1E4E8">[ndim</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">   for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ndim</span><span style="color:#F97583">-</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">>=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#FFAB70">      h_strides</span><span style="color:#E1E4E8">[i] </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> h_strides</span><span style="color:#E1E4E8">[i</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">*</span><span style="color:#FFAB70"> shape</span><span style="color:#E1E4E8">[i</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#6A737D">   // Calculate total number of slices (elements in the output)</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#E1E4E8"> slices </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">   for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> ndim; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (i </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> dim) {</span></span>
<span class="line"><span style="color:#E1E4E8">         slices </span><span style="color:#F97583">*=</span><span style="color:#FFAB70"> shape</span><span style="color:#E1E4E8">[i];</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#F97583">   int*</span><span style="color:#E1E4E8"> h_weights </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int*</span><span style="color:#E1E4E8">) </span><span style="color:#B392F0">malloc</span><span style="color:#E1E4E8">(ndim </span><span style="color:#F97583">*</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#F97583">   for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> ndim; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#FFAB70">      h_weights</span><span style="color:#E1E4E8">[i] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#E1E4E8"> weight </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">   for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ndim</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">>=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (i </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> dim) {</span></span>
<span class="line"><span style="color:#FFAB70">        h_weights</span><span style="color:#E1E4E8">[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> weight;</span></span>
<span class="line"><span style="color:#E1E4E8">        weight </span><span style="color:#F97583">*=</span><span style="color:#FFAB70"> shape</span><span style="color:#E1E4E8">[i];</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">   // Allocate and copy device memory</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">d_strides </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">d_weights </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">   cudaMalloc</span><span style="color:#E1E4E8">((</span><span style="color:#F97583">void**</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">d_strides, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> ndim);</span></span>
<span class="line"><span style="color:#B392F0">   cudaMemcpy</span><span style="color:#E1E4E8">(d_strides, h_strides, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> ndim, cudaMemcpyHostToDevice);</span></span>
<span class="line"><span style="color:#B392F0">   cudaMalloc</span><span style="color:#E1E4E8">((</span><span style="color:#F97583">void**</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">d_weights, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> ndim);</span></span>
<span class="line"><span style="color:#B392F0">   cudaMemcpy</span><span style="color:#E1E4E8">(d_weights, h_weights, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> ndim, cudaMemcpyHostToDevice);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">   // Launch kernel</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#E1E4E8"> threadsPerBlock </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 256</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">   int</span><span style="color:#E1E4E8"> numBlocks </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (slices </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> threadsPerBlock </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> threadsPerBlock;</span></span>
<span class="line"><span style="color:#E1E4E8">   argmax</span><span style="color:#F97583">&#x3C;&#x3C;&#x3C;</span><span style="color:#E1E4E8">numBlocks, threadsPerBlock</span><span style="color:#F97583">>>></span><span style="color:#E1E4E8">(input, dim, output, shape, ndim, d_strides, d_weights, slices);</span></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#B392F0">   cudaDeviceSynchronize</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">   </span></span>
<span class="line"><span style="color:#6A737D">   // Free memory</span></span>
<span class="line"><span style="color:#B392F0">   cudaFree</span><span style="color:#E1E4E8">(d_strides);</span></span>
<span class="line"><span style="color:#B392F0">   cudaFree</span><span style="color:#E1E4E8">(d_weights);</span></span>
<span class="line"><span style="color:#B392F0">   free</span><span style="color:#E1E4E8">(h_strides);</span></span>
<span class="line"><span style="color:#B392F0">   free</span><span style="color:#E1E4E8">(h_weights);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">        float*</span><span style="color:#E1E4E8"> h_input </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">float*</span><span style="color:#E1E4E8">)</span><span style="color:#B392F0">malloc</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">float</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">TOTAL_SIZE);</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;i</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8">(TOTAL_SIZE);i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#FFAB70">          h_input</span><span style="color:#E1E4E8">[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">float</span><span style="color:#E1E4E8">)i;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        int</span><span style="color:#E1E4E8"> h_shapes</span><span style="color:#F97583">[]</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">};</span></span>
<span class="line"><span style="color:#F97583">        float*</span><span style="color:#E1E4E8"> d_input </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">        int*</span><span style="color:#E1E4E8"> d_output </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">        int*</span><span style="color:#E1E4E8"> d_shapes </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">        int</span><span style="color:#E1E4E8"> items </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 2</span><span style="color:#F97583">*</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">        cudaMalloc</span><span style="color:#E1E4E8">((</span><span style="color:#F97583">void**</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">d_input, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">float</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">TOTAL_SIZE);</span></span>
<span class="line"><span style="color:#B392F0">        cudaMemcpy</span><span style="color:#E1E4E8">(d_input, h_input, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">float</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">TOTAL_SIZE, cudaMemcpyHostToDevice);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">        cudaMalloc</span><span style="color:#E1E4E8">((</span><span style="color:#F97583">void**</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">d_output, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">float</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">items);</span></span>
<span class="line"><span style="color:#B392F0">        cudaMalloc</span><span style="color:#E1E4E8">((</span><span style="color:#F97583">void**</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">d_shapes, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(h_shapes));</span></span>
<span class="line"><span style="color:#B392F0">        cudaMemcpy</span><span style="color:#E1E4E8">(d_shapes, h_shapes, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(h_shapes), cudaMemcpyHostToDevice);</span></span>
<span class="line"><span style="color:#B392F0">        solution</span><span style="color:#E1E4E8">(d_input, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, d_output, d_shapes, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">        int*</span><span style="color:#E1E4E8"> output </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">)</span><span style="color:#B392F0">malloc</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">TOTAL_SIZE);</span></span>
<span class="line"><span style="color:#B392F0">        cudaMemcpy</span><span style="color:#E1E4E8">(output, d_output, </span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">items, cudaMemcpyDeviceToHost);</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;i</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8">items;i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">            printf</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">%d</span><span style="color:#9ECBFF"> "</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">output</span><span style="color:#E1E4E8">[i]);</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>  </div> </article> </main> <footer data-astro-cid-sz7xmlte> <div class="social-links" data-astro-cid-sz7xmlte> <a href="https://x.com/DeepknowledgeU" target="_blank" data-astro-cid-sz7xmlte> <span class="sr-only" data-astro-cid-sz7xmlte>Follow Astro on X</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/twitter" data-astro-cid-sz7xmlte><path fill="currentColor" d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z" data-astro-cid-sz7xmlte></path></svg> </a> <a href="https://github.com/Gowind" target="_blank" data-astro-cid-sz7xmlte> <span class="sr-only" data-astro-cid-sz7xmlte>My Github</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/github" data-astro-cid-sz7xmlte><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-sz7xmlte></path></svg> </a> </div> </footer>  </body></html>