<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
  <title>Compiling C code with Zig</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="basic.css">
</head>
<body>

<header>
  <a href="https://gowind.github.io/">Home</a>
</header>
<header>
<h1 class="title">Compiling C code with Zig</h1>
</header>

<h3 id="this-doesnt-cover-cross-compiling-to-other-targets.">This
doesn’t cover cross-compiling to other targets.</h3>
<p>We will only focus on creating libraries and executables on the same
platform.</p>
<p>This small intro covers creating 1. A static library 2. A shared
(dynamic) library 3. and an executable</p>
<p>I wrote a build file in Zig to built the <code>whisper</code>
executable in the <code>whisper.cpp</code> repo by Greg Gregarinov. This
project is a good intro to compiling C/C++ code with Zig.
<code>whisper.cpp</code> involves using 1. ggml - A c library for
tensor/matrix operations. This library consists of a <code>.c</code>
file and a corresponding header file. 2. whisper.cpp - A cpp library
that can be used for audio transcription 3. A main file from
<code>main.cpp</code> and <code>common.cpp</code> that uses the
previously built <code>whisper.cpp</code></p>
<p><code>ggml</code> performs a lot of intensive math operations, so on
each platform we will have to leverage the platform’s SIMD intrinsics or
special Matrix libraries if available.</p>
<p>The <code>builtin</code> package/library in Zig provides information
about the system the program is running in via <a
href="https://github.com/ziglang/zig/blob/8d6336420b937075e3363f9548adb0092af7f819/src/Compilation.zig#L5083">this</a>
fn , which is called by <a
href="https://github.com/ziglang/zig/blob/8d6336420b937075e3363f9548adb0092af7f819/src/Compilation.zig#L3500">this</a>
in the <a
href="https://github.com/ziglang/zig/blob/8d6336420b937075e3363f9548adb0092af7f819/src/Compilation.zig#L3008">main</a>
thread, when we call zig build or <code>zig build-exe</code></p>
<ol type="1">
<li>Based on the <code>cpu</code> of the platform
(<code>builtin.cpu</code>) we decide the C and the C++ flags we need to
pass to the compiler</li>
<li>If an accelerator has to be used (Accelerate in macos or OpenBLAS)
we also set the corresponding flags. The usage of these accelerators is
controlled by passing an option to <code>zig build</code> using
<code>zig build -Doption=val</code>. In our file, for example, setting
<code>-Dmacos_accelerate=true</code> enables the usage of the AI
accelerator in macos.</li>
</ol>
<p>We then build a bunch of intermediate object files that will be
linked into the static, dynamic and main executables.</p>
<pre><code>    const ggmlObject = b.addObject(.{
        .name = &quot;ggml.o&quot;,
        .target = target,
        .optimize = optimize,
    });
    ggmlObject.addIncludePath(&quot;./&quot;); 
ggmlObject.addIncludePath(&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include&quot;);
    ggmlObject.addCSourceFiles(&amp;.{
        &quot;ggml.c&quot;,
    }, c_flags.items);</code></pre>
<p>This for example, builds the <code>ggml</code> object file from our
ggml source code with the C flags we have defined. We then build a
<code>whisper</code> object and then use them both in each of the shared
library, static library and the executable.</p>
<p>We can only install artifacts that are either a shared,static library
or an executable file. We <strong>cannot <code>install</code> any
intermediate object files that were created by Zig</strong></p>
<p>To procedurally instruct Zig build to install these files, using
<code>std.build.Builder.installArtifact</code></p>
<pre><code>var lib_dynamic = b.addSharedLibrary(.{ .name = &quot;whisper&quot;, .optimize = optimize, .target = target });
    lib_dynamic.addObject(ggmlObject);
    lib_dynamic.addObject(whisperObject);
    b.installArtifact(lib_dynamic);
    b.installArtifact(lib_static_library);
    b.installArtifact(mainFile);</code></pre>
<pre><code>const std = @import(&quot;std&quot;);
const builtin = @import(&quot;builtin&quot;);

pub fn build(b: *std.build.Builder) !void {
    var basic_cflags = [_][]const u8{ &quot;-I.&quot;, &quot;-O3&quot;, &quot;-std=c11&quot;, &quot;-fPIC&quot;, &quot;-pthread&quot; };
    var basic_cppflags = .{ &quot;-I.&quot;, &quot;-I./examples&quot;, &quot;-O3&quot;, &quot;-std=c++11&quot;, &quot;-fPIC&quot;, &quot;-pthread&quot; };
    var alloc = b.allocator;
    var c_flags = std.ArrayList([]const u8).init(alloc);
    var cpp_flags = std.ArrayList([]const u8).init(alloc);
    defer c_flags.deinit();
    defer cpp_flags.deinit();
    try c_flags.appendSlice(&amp;basic_cflags);
    try cpp_flags.appendSlice(&amp;basic_cppflags);

    const target = b.standardTargetOptions(.{});

    var target_cpu = builtin.cpu;
    var all_features = target_cpu.features;
    if (target_cpu.arch.isX86()) {
        const x86_target = std.Target.x86;
        if (x86_target.featureSetHas(all_features, x86_target.Feature.f16c)) {
            try c_flags.append(&quot;-mf16c&quot;);
        }
        if (x86_target.featureSetHas(all_features, x86_target.Feature.fma)) {
            try c_flags.append(&quot;-mfma&quot;);
        }

        if (x86_target.featureSetHas(all_features, x86_target.Feature.avx)) {
            try c_flags.append(&quot;-mavx&quot;);
        }

        if (x86_target.featureSetHas(all_features, x86_target.Feature.avx2)) {
            try c_flags.append(&quot;-mavx2&quot;);
        }

        if (x86_target.featureSetHas(all_features, x86_target.Feature.sse3)) {
            try c_flags.append(&quot;-msse3&quot;);
        }
    }
    if (target_cpu.arch.isPPC64()) {
        const ppc64_target = std.Target.powerpc;
        if (ppc64_target.featureSetHas(all_features, ppc64_target.Feature.power9_vector)) {
            try c_flags.append(&quot;-mpower9-vector&quot;);
        }
        try cpp_flags.append(&quot;-std=c++23&quot;);
        try cpp_flags.append(&quot;-DGGML_BIG_ENDIAN&quot;);
    }

    var maybe_use_accelerate = b.option(bool, &quot;macos_accelerate&quot;, &quot;use the accelerate framework in macOS (if available) for ML models&quot;);
    if (maybe_use_accelerate) |use_accelerate| {
        if (use_accelerate) {
            try c_flags.append(&quot;-DGGML_USE_ACCELERATE&quot;);
        }
    }

    var maybe_use_openblas = b.option(bool, &quot;use_openblas&quot;, &quot;use open BLAS when available&quot;);
    if (maybe_use_openblas) |use_openblas| {
        if (use_openblas) {
            try c_flags.appendSlice(&amp;.{ &quot;-DGGML_USE_OPENBLAS&quot;, &quot;-I/usr/local/include/openblas&quot; });
        }
    }
    var maybe_use_gprof = b.option(bool, &quot;gprof&quot;, &quot;use gnu prof&quot;);
    if (maybe_use_gprof) |use_gprof| {
        if (use_gprof) {
            try c_flags.append(&quot;-pg&quot;);
            try cpp_flags.append(&quot;-pg&quot;);
        }
    }

    if (!target_cpu.arch.isAARCH64()) {
        try c_flags.append(&quot;-mcpu=native&quot;);
        try cpp_flags.append(&quot;-mcpu=native&quot;);
    }

    if (target_cpu.arch.isARM()) {
        if (!std.mem.startsWith(u8, target_cpu.model.name, &quot;armv6&quot;)) {
            try c_flags.appendSlice(&amp;.{ &quot;-mfpu=neon-fp-armv8&quot;, &quot;-mfp16-format=ieee&quot;, &quot;-mno-unaligned-access&quot; });
        }
        if (!std.mem.startsWith(u8, target_cpu.model.name, &quot;armv7&quot;)) {
            try c_flags.appendSlice(&amp;.{ &quot;-mfpu=neon-fp-armv8&quot;, &quot;-mfp16-format=ieee&quot;, &quot;-mno-unaligned-access&quot;, &quot;-funsafe-math-optimizations&quot; });
        }

        if (!std.mem.startsWith(u8, target_cpu.model.name, &quot;armv8&quot;)) {
            try c_flags.appendSlice(&amp;.{ &quot;-mfp16-format=ieee&quot;, &quot;-mno-unaligned-access&quot; });
        }
    }
    //TODO: Flags for accelerate, aarch64, arm and rpi
    const optimize = b.standardOptimizeOption(.{});
    const ggmlObject = b.addObject(.{
        .name = &quot;ggml.o&quot;,
        .target = target,
        .optimize = optimize,
    });
    ggmlObject.addIncludePath(&quot;./&quot;);
    ggmlObject.addIncludePath(&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include&quot;);
    ggmlObject.addCSourceFiles(&amp;.{
        &quot;ggml.c&quot;,
    }, c_flags.items);
    if (maybe_use_accelerate) |use_accelerate| {
        if (use_accelerate) {
            ggmlObject.linkFramework(&quot;Accelerate&quot;);
        }
    }
    if (maybe_use_openblas) |open_blas| {
        if (open_blas) {
            ggmlObject.linkSystemLibraryName(&quot;openblas&quot;);
        }
    }
    ggmlObject.linkLibC();

    const whisperObject = b.addObject(.{ .name = &quot;whisper.o&quot;, .target = target, .optimize = optimize });
    whisperObject.addIncludePath(&quot;./&quot;);
    whisperObject.addIncludePath(&quot;./examples&quot;);
    whisperObject.addCSourceFile(&quot;whisper.cpp&quot;, cpp_flags.items);
    whisperObject.linkLibCpp();

    // zig automatically adds `lib` prefix and a `.a` suffix
    var lib_static_library = b.addStaticLibrary(.{ .name = &quot;whisper&quot;, .optimize = optimize, .target = target });
    lib_static_library.addObject(ggmlObject);
    lib_static_library.addObject(whisperObject);

    var lib_dynamic = b.addSharedLibrary(.{ .name = &quot;whisper&quot;, .optimize = optimize, .target = target });
    lib_dynamic.addObject(ggmlObject);
    lib_dynamic.addObject(whisperObject);
    b.installArtifact(lib_dynamic);
    b.installArtifact(lib_static_library);
    var mainFile = b.addExecutable(.{ .name = &quot;main&quot; });
    mainFile.addIncludePath(&quot;./&quot;);
    mainFile.addIncludePath(&quot;./examples&quot;);
    mainFile.addCSourceFiles(&amp;.{ &quot;examples/main/main.cpp&quot;, &quot;examples/common.cpp&quot; }, cpp_flags.items);
    mainFile.addObject(whisperObject);
    mainFile.addObject(ggmlObject);
    if (maybe_use_accelerate) |use_accelerate| {
        if (use_accelerate) {
            mainFile.linkFramework(&quot;Accelerate&quot;);
        }
    }

    b.installArtifact(mainFile);
}
</code></pre>
<h3 id="alternate-ways-of-setting-c-macros">Alternate ways of setting C
macros</h3>
<h5 id="in-zig-code">In Zig Code:</h5>
<p>Setting C preprocess macros with <span class="citation"
data-cites="cDefine">@cDefine</span> or <code>-Dmacro=value</code>
during compile time. This compile time macro can be set via
<code>build/build-exe -Dmacro=val</code> or programatically
object.addCSourceFiles(“file”, c_cpp_flags);</p>


</body>
</html>
