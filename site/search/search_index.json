{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"I sometimes write something Articles System Calls with Rust Crates and Roots in Rust Transducers - A Walkthrough Configuring Spaces and Tabs in Vim [Upcoming: Why I started this site] Too short for articles I wrote some gists here","title":"Home"},{"location":"#i-sometimes-write-something","text":"","title":"I sometimes write something"},{"location":"#articles","text":"System Calls with Rust Crates and Roots in Rust Transducers - A Walkthrough Configuring Spaces and Tabs in Vim [Upcoming: Why I started this site]","title":"Articles"},{"location":"#too-short-for-articles","text":"I wrote some gists here","title":"Too short for articles"},{"location":"about/","text":"Who am I ? I am Govind. I am a software engineer with 5+ years of professional experience. This is my blog. I write articles about tech, opinions and whatever that interests me. If you are interested in my code, check out whatever exists on Github If you are interested in my LinkedIn profile, please find it here here","title":"About"},{"location":"about/#who-am-i","text":"I am Govind. I am a software engineer with 5+ years of professional experience. This is my blog. I write articles about tech, opinions and whatever that interests me. If you are interested in my code, check out whatever exists on Github If you are interested in my LinkedIn profile, please find it here here","title":"Who am I ?"},{"location":"markdown/clojurescriptsetup/","text":"Writing an application in Clojurescript Sections: - Motivation - Setup - Learning - TODOs Motivation I think Javascript is a very unaesthetic and confusing language. I absolutely hate all the confusing, jargon/buzzword fueled tooling around the ecosystem. To a backend developer used to the rather sensible world of package management and build tools like Maven, Javascript's flavor of the day approach to managing products feels like an insult to all the progress made in the world of software management. I love Clojure. I would like to use this amazing language to build web applications . Why web applications? The fastest way to ship your software directly to users is via the web. Web applications can run anywhere, as browsers exist on all smartphones, laptops and desktops. Unless your application is extremely resource intensive or heavy, you can mostly get away with web applications. Clojurescript uses Google's Closure compiler, which seems to do a good job of emitting compact JS. Setup I use lein to configure my clojure/script projects I use figwheel to configure my clojurescript application. Fighweel provides nice tools for interactive development (changing and reloading our clojurescript code in the browser) and a simple server to serve requests and files. Note : There are 2 versions of figwheel. I use lein figwheel which is the older version of the fighweel tool for this demo. The newer version fighwheel is fancier The older, but simpler version suits our needs well without getting distracted by all of the confusing tooling around clojurescript/javascript. I use the lein figwheel template to setup my project lein new figwheel your-application-name This would setup our application for some \"live\" coding. Before that, lets look at the project.clj to understand our project setup and DELETE stuff to better understand how a Clojurescript with fighweel project works. A minimal setup (defproject haha \"0.1.0-SNAPSHOT\" :description \"FIXME: write this!\" :url \"http://example.com/FIXME\" :license {:name \"Eclipse Public License\" :url \"http://www.eclipse.org/legal/epl-v10.html\"} :min-lein-version \"2.9.1\" :dependencies [[org.clojure/clojure \"1.10.0\"] [org.clojure/clojurescript \"1.10.758\"] [org.clojure/core.async \"1.2.603\"] [cljs-ajax \"0.8.0\"] [reagent \"1.0.0-alpha2\"] ;;server-side [cheshire \"5.10.0\"] [ring/ring-core \"1.8.1\"] [ring/ring-devel \"1.8.1\"]] :plugins [[lein-figwheel \"0.5.20\"] [lein-cljsbuild \"1.1.7\" :exclusions [[org.clojure/clojure]]]] :source-paths [\"src-cljs\" \"src-clj\"] :cljsbuild {:builds [{:id \"dev\" :source-paths [\"src-cljs\"] ;; The presence of a :figwheel configuration here ;; will cause figwheel to inject the figwheel client ;; into your build :figwheel {:on-jsload \"haha.core/on-js-reload\" ;; :open-urls will pop open your application in the default browser once Figwheel has started and compiled your application. :open-urls [\"http://localhost:3449/index.html\"]} :compiler {:main haha.core ;;:target :bundle :asset-path \"js\" :output-to \"resources/public/js/haha-dev.js\" :output-dir \"resources/public/js\" :source-map-timestamp true ;; To console.log CLJS data-structures make sure you enable devtools in Chrome ;; https://github.com/binaryage/cljs-devtools :preloads [devtools.preload]}} ;; This next build is a compressed minified build for ;; production. You can build this with: ;; lein cljsbuild once min {:id \"min\" :source-paths [\"src\"] :compiler {:output-to \"resources/public/js/haha.js\" :main haha.core :optimizations :advanced :pretty-print false}}]} :figwheel { :http-server-root \"public\" ;; default and assumes \"resources\" ;; :server-port 3449 ;; default ;; :server-ip \"127.0.0.1\" :css-dirs [\"resources/public/css\"] ;; Start an nREPL server into the running figwheel process ;; :nrepl-port 7888 :ring-handler haha-server.server/handler} Let us understand the tools in this setup lein uses plugins to extend the functionality of our build tool. lein-cljsbuild is a plugin to compile our clojurescript code to Javascript. figwheel is a tool and a plugin, that provides us a nice environment for live coding. It a) watches our source code for changes so that our files can be re-compiled and b) provides a connection to clojurescript environment running on our browser that can be used for executing expressions from our command line repl and is used for re-loading our code. It also provides a watcher for CSS files and can load CSS changes live (pretty cool!) The cljsbuild section consists of builds each with a possibly different configuration for building our Clojurescript code to Javascript. The figwheel configuration provides us a server that we can use for sending responses to AJAX requests from the client and also for injecting the figwheel client into the builds for live re-loading and a REPL session. TODOs Prod builds Creating lists","title":"Writing an application in Clojurescript"},{"location":"markdown/clojurescriptsetup/#writing-an-application-in-clojurescript","text":"Sections: - Motivation - Setup - Learning - TODOs","title":"Writing an application in Clojurescript"},{"location":"markdown/clojurescriptsetup/#motivation","text":"I think Javascript is a very unaesthetic and confusing language. I absolutely hate all the confusing, jargon/buzzword fueled tooling around the ecosystem. To a backend developer used to the rather sensible world of package management and build tools like Maven, Javascript's flavor of the day approach to managing products feels like an insult to all the progress made in the world of software management. I love Clojure. I would like to use this amazing language to build web applications .","title":"Motivation"},{"location":"markdown/clojurescriptsetup/#why-web-applications","text":"The fastest way to ship your software directly to users is via the web. Web applications can run anywhere, as browsers exist on all smartphones, laptops and desktops. Unless your application is extremely resource intensive or heavy, you can mostly get away with web applications. Clojurescript uses Google's Closure compiler, which seems to do a good job of emitting compact JS.","title":"Why web applications?"},{"location":"markdown/clojurescriptsetup/#setup","text":"I use lein to configure my clojure/script projects I use figwheel to configure my clojurescript application. Fighweel provides nice tools for interactive development (changing and reloading our clojurescript code in the browser) and a simple server to serve requests and files. Note : There are 2 versions of figwheel. I use lein figwheel which is the older version of the fighweel tool for this demo. The newer version fighwheel is fancier The older, but simpler version suits our needs well without getting distracted by all of the confusing tooling around clojurescript/javascript. I use the lein figwheel template to setup my project lein new figwheel your-application-name This would setup our application for some \"live\" coding. Before that, lets look at the project.clj to understand our project setup and DELETE stuff to better understand how a Clojurescript with fighweel project works. A minimal setup (defproject haha \"0.1.0-SNAPSHOT\" :description \"FIXME: write this!\" :url \"http://example.com/FIXME\" :license {:name \"Eclipse Public License\" :url \"http://www.eclipse.org/legal/epl-v10.html\"} :min-lein-version \"2.9.1\" :dependencies [[org.clojure/clojure \"1.10.0\"] [org.clojure/clojurescript \"1.10.758\"] [org.clojure/core.async \"1.2.603\"] [cljs-ajax \"0.8.0\"] [reagent \"1.0.0-alpha2\"] ;;server-side [cheshire \"5.10.0\"] [ring/ring-core \"1.8.1\"] [ring/ring-devel \"1.8.1\"]] :plugins [[lein-figwheel \"0.5.20\"] [lein-cljsbuild \"1.1.7\" :exclusions [[org.clojure/clojure]]]] :source-paths [\"src-cljs\" \"src-clj\"] :cljsbuild {:builds [{:id \"dev\" :source-paths [\"src-cljs\"] ;; The presence of a :figwheel configuration here ;; will cause figwheel to inject the figwheel client ;; into your build :figwheel {:on-jsload \"haha.core/on-js-reload\" ;; :open-urls will pop open your application in the default browser once Figwheel has started and compiled your application. :open-urls [\"http://localhost:3449/index.html\"]} :compiler {:main haha.core ;;:target :bundle :asset-path \"js\" :output-to \"resources/public/js/haha-dev.js\" :output-dir \"resources/public/js\" :source-map-timestamp true ;; To console.log CLJS data-structures make sure you enable devtools in Chrome ;; https://github.com/binaryage/cljs-devtools :preloads [devtools.preload]}} ;; This next build is a compressed minified build for ;; production. You can build this with: ;; lein cljsbuild once min {:id \"min\" :source-paths [\"src\"] :compiler {:output-to \"resources/public/js/haha.js\" :main haha.core :optimizations :advanced :pretty-print false}}]} :figwheel { :http-server-root \"public\" ;; default and assumes \"resources\" ;; :server-port 3449 ;; default ;; :server-ip \"127.0.0.1\" :css-dirs [\"resources/public/css\"] ;; Start an nREPL server into the running figwheel process ;; :nrepl-port 7888 :ring-handler haha-server.server/handler} Let us understand the tools in this setup lein uses plugins to extend the functionality of our build tool. lein-cljsbuild is a plugin to compile our clojurescript code to Javascript. figwheel is a tool and a plugin, that provides us a nice environment for live coding. It a) watches our source code for changes so that our files can be re-compiled and b) provides a connection to clojurescript environment running on our browser that can be used for executing expressions from our command line repl and is used for re-loading our code. It also provides a watcher for CSS files and can load CSS changes live (pretty cool!) The cljsbuild section consists of builds each with a possibly different configuration for building our Clojurescript code to Javascript. The figwheel configuration provides us a server that we can use for sending responses to AJAX requests from the client and also for injecting the figwheel client into the builds for live re-loading and a REPL session.","title":"Setup"},{"location":"markdown/clojurescriptsetup/#todos","text":"Prod builds Creating lists","title":"TODOs"},{"location":"markdown/crates-and-roots/","text":"So you want to modularize your Rust code 22 May 2019 Rant The module system in Rust is probably the most confusing module system I have ever encountered in programming languages I have used so far. Not that it is bad or has a serious flaw, but the documentation about how it works is very obfuscated and involves reading multiple, confusing, sources (assuming you can get to the right documentation in the first place. Attempting to find the right Rust book references via Google search is like playing Mario on the NES: the princess is always in another castle) So you have a binary crate with a main.rs . You want to organize your fn s , types and struct definitions to another file so that your source code is better organized. You try to use modules by reading up on the docs and run into all sorts of weird error messages that the compiler is unable to find your module definitions. You pull your hair out in frustration (if there is still some left), read the rustc --explain messages and still don't find out what went wrong and how to organize your code. A moment of silence for my fellow warriors new to Rust Motivation The rant is to be taken lightly. The Rust module system is well designed, though I wish there were better newbie-friendly introduction to them. This article is meant to help newbies better understand how to organize their modules and how the module system works. The crate root The code and the documentation below is written against the Rust 2018 edition. This Rust code is organized into crates . Crates are of 2 types binary , that gets turned into an executable or library that is consumed by other applications Note : You can also ship your crate as a binary and a library, but lets get to it The ROOT of the crate, forms the root node of the tree-like module structure of your code. You declare your sub-modules in the root and the chain commences thereon. So what is the crate root? For a binary crate, the root is main.rs You can declare your modules in main.rs and then either a) implement them in main.rs b) implement them in a modulename.rs or c) implement them in a modulename/mod.rs Lets illustrate each of the way with an example Here is the layout of our illustrative application $ cargo new --bin moduleblog Created binary (application) moduleblog package` cd moduleblog $ tree . \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.rs A) Lets implement a module in main.rs mod foo { pub fn bar(s: String) -> String { format!(\"Hai {} from bar\", s) } } fn main() { println!(\"{}\", foo::bar(String::from(\"baz\"))); } You can use the module directly in your main fn like you would use any other module. The mod keyword has 2 different meanings: A mod foo; statement means that you are declaring that a module foo exists and which is implemented either in foo.rs or foo/mod.rs relative to where it is declared. This declaration is akin to a C type #include \"library.h\" where the library is included in your code and the source code for it is usually present in a library.h and a library.c file. The declaration of a module mod foo; is usually done in the root of the crate (in this case, main.rs ) Let us implement foo via b) and c). >cat main.rs mod foo; fn main() { println!(\"{}\", foo::bar(String::from(\"baz\"))); } >cat foo.rs pub fn bar(s: String) -> String { format!(\"Hai {} from bar\", s) } Note that you no longer have to wrap bar with a mod foo{} as it is implied that this belongs to foo module from the filename Here is foo implemented as foo/mod.rs > cat foo/mod.rs pub fn bar(s: String) -> String { format!(\"Hai {} from bar\", s) } You can also implement submodules this way > cat foo/mod.rs pub mod max; pub fn bar(s: String) -> String { format!(\"Hai {} from bar\", s) } > cat foo/max.rs pub fn baz(s: String) -> String { format!(\"Hi {} from max::baz\", s) } > ls foo max.rs mod.rs > cat main.rs mod foo; fn main() { println!(\"{}\", foo::bar(String::from(\"baz\"))); println!(\"{}\", foo::max::baz(String::from(\"baz\"))); } Library crate A library crate that serves as a library for other applications To create a library crate, one uses cargo new --lib libraryname Here is what a lib crate looks like >tree libmodule libmodule \u251c\u2500\u2500 Cargo.lock \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 lib.rs > cat libmodule/src/lib.rs pub mod libfoo { pub fn gimme_a_song() -> String { String::from(\"Ace of Spades\") } } The lib.rs file now forms the root of the libcrate You can now use the libmodule library in your code just like you would use any other library (std, rng, etc) Here is the main from our previous application using our new library >cat main.rs mod foo; fn main() { println!(\"{}\", foo::bar(String::from(\"baz\"))); println!(\"{}\", foo::max::baz(String::from(\"baz\"))); println!(\"{}\", libmodule::libfoo::gimme_a_song()); } Update our new library as a dependency in the Cargo manifest file > cat Cargo.toml [package] name = \"moduleblog\" version = \"0.1.0\" authors = [\"Govindarajan <ngovind@protonmail.com>\"] edition = \"2018\" [dependencies] libmodule = {path = \"libmodule\"} What if there is lib.rs AND a main.rs ? I have been building up this article to address this very point. For a long time, longer than the last time Liverpool won the PL, I have always been confused by the presence of both a lib.rs and main.rs in a binary crate. Who among you reigns supreme ? In this case, the main.rs becomes a consumer of your application. The lib.rs is assumed to be the crate root. Your main.rs then treats your application code as an external crate and then imports the modules/fns/structs as needed. With both a lib.rs and main.rs > tree moduleblog . \u251c\u2500\u2500 foo \u2502 \u251c\u2500\u2500 max.rs \u2502 \u2514\u2500\u2500 mod.rs \u251c\u2500\u2500 lib.rs \u2514\u2500\u2500 main.rs > cat lib.rs pub mod foo; > cat main.rs use moduleblog; fn main() { println!(\"{}\", moduleblog::foo::bar(String::from(\"baz\"))); println!(\"{}\", moduleblog::foo::max::baz(String::from(\"baz\"))); println!(\"{}\", libmodule::libfoo::gimme_a_song()); } Note how one now consumes the application itself as a library in the main module. For someone not using rust versions before 2018 you have to add an external crate moduleblog before the use statement; Conclusion I haven't covered modules fully as it wasn't my intention (and neither have I used all of the features) I had run into this pain point of organizing my code and not knowing how the heirarchy works and while the compiler was nice enough to get me to a solution without having to fully understand (a testament to how friendly the Rust compiler is) I wrote this blog with the intention of understanding crates and crate roots and I hope it helps. You can find the source code for the post here References It wouldn't have been possible to understand all of this without help from others. These are the references that helped me the most (and I remembered). Thanks to the community for being helpful as always ! https://github.com/rust-lang/book/issues/721 https://doc.rust-lang.org/1.1.0/book/crates-and-modules.html https://learning-rust.github.io/docs/d4.crates.html","title":"So you want to modularize your Rust code"},{"location":"markdown/crates-and-roots/#so-you-want-to-modularize-your-rust-code","text":"22 May 2019","title":"So you want to modularize your Rust code"},{"location":"markdown/crates-and-roots/#rant","text":"The module system in Rust is probably the most confusing module system I have ever encountered in programming languages I have used so far. Not that it is bad or has a serious flaw, but the documentation about how it works is very obfuscated and involves reading multiple, confusing, sources (assuming you can get to the right documentation in the first place. Attempting to find the right Rust book references via Google search is like playing Mario on the NES: the princess is always in another castle) So you have a binary crate with a main.rs . You want to organize your fn s , types and struct definitions to another file so that your source code is better organized. You try to use modules by reading up on the docs and run into all sorts of weird error messages that the compiler is unable to find your module definitions. You pull your hair out in frustration (if there is still some left), read the rustc --explain messages and still don't find out what went wrong and how to organize your code. A moment of silence for my fellow warriors new to Rust","title":"Rant"},{"location":"markdown/crates-and-roots/#motivation","text":"The rant is to be taken lightly. The Rust module system is well designed, though I wish there were better newbie-friendly introduction to them. This article is meant to help newbies better understand how to organize their modules and how the module system works.","title":"Motivation"},{"location":"markdown/crates-and-roots/#the-crate-root","text":"The code and the documentation below is written against the Rust 2018 edition. This Rust code is organized into crates . Crates are of 2 types binary , that gets turned into an executable or library that is consumed by other applications Note : You can also ship your crate as a binary and a library, but lets get to it The ROOT of the crate, forms the root node of the tree-like module structure of your code. You declare your sub-modules in the root and the chain commences thereon.","title":"The crate root"},{"location":"markdown/crates-and-roots/#so-what-is-the-crate-root","text":"For a binary crate, the root is main.rs You can declare your modules in main.rs and then either a) implement them in main.rs b) implement them in a modulename.rs or c) implement them in a modulename/mod.rs Lets illustrate each of the way with an example Here is the layout of our illustrative application $ cargo new --bin moduleblog Created binary (application) moduleblog package` cd moduleblog $ tree . \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.rs A) Lets implement a module in main.rs mod foo { pub fn bar(s: String) -> String { format!(\"Hai {} from bar\", s) } } fn main() { println!(\"{}\", foo::bar(String::from(\"baz\"))); } You can use the module directly in your main fn like you would use any other module. The mod keyword has 2 different meanings: A mod foo; statement means that you are declaring that a module foo exists and which is implemented either in foo.rs or foo/mod.rs relative to where it is declared. This declaration is akin to a C type #include \"library.h\" where the library is included in your code and the source code for it is usually present in a library.h and a library.c file. The declaration of a module mod foo; is usually done in the root of the crate (in this case, main.rs ) Let us implement foo via b) and c). >cat main.rs mod foo; fn main() { println!(\"{}\", foo::bar(String::from(\"baz\"))); } >cat foo.rs pub fn bar(s: String) -> String { format!(\"Hai {} from bar\", s) } Note that you no longer have to wrap bar with a mod foo{} as it is implied that this belongs to foo module from the filename Here is foo implemented as foo/mod.rs > cat foo/mod.rs pub fn bar(s: String) -> String { format!(\"Hai {} from bar\", s) } You can also implement submodules this way > cat foo/mod.rs pub mod max; pub fn bar(s: String) -> String { format!(\"Hai {} from bar\", s) } > cat foo/max.rs pub fn baz(s: String) -> String { format!(\"Hi {} from max::baz\", s) } > ls foo max.rs mod.rs > cat main.rs mod foo; fn main() { println!(\"{}\", foo::bar(String::from(\"baz\"))); println!(\"{}\", foo::max::baz(String::from(\"baz\"))); }","title":"So what is the crate root?"},{"location":"markdown/crates-and-roots/#library-crate","text":"A library crate that serves as a library for other applications To create a library crate, one uses cargo new --lib libraryname Here is what a lib crate looks like >tree libmodule libmodule \u251c\u2500\u2500 Cargo.lock \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 lib.rs > cat libmodule/src/lib.rs pub mod libfoo { pub fn gimme_a_song() -> String { String::from(\"Ace of Spades\") } } The lib.rs file now forms the root of the libcrate You can now use the libmodule library in your code just like you would use any other library (std, rng, etc) Here is the main from our previous application using our new library >cat main.rs mod foo; fn main() { println!(\"{}\", foo::bar(String::from(\"baz\"))); println!(\"{}\", foo::max::baz(String::from(\"baz\"))); println!(\"{}\", libmodule::libfoo::gimme_a_song()); } Update our new library as a dependency in the Cargo manifest file > cat Cargo.toml [package] name = \"moduleblog\" version = \"0.1.0\" authors = [\"Govindarajan <ngovind@protonmail.com>\"] edition = \"2018\" [dependencies] libmodule = {path = \"libmodule\"}","title":"Library crate"},{"location":"markdown/crates-and-roots/#what-if-there-is-librs-and-a-mainrs","text":"I have been building up this article to address this very point. For a long time, longer than the last time Liverpool won the PL, I have always been confused by the presence of both a lib.rs and main.rs in a binary crate. Who among you reigns supreme ? In this case, the main.rs becomes a consumer of your application. The lib.rs is assumed to be the crate root. Your main.rs then treats your application code as an external crate and then imports the modules/fns/structs as needed. With both a lib.rs and main.rs > tree moduleblog . \u251c\u2500\u2500 foo \u2502 \u251c\u2500\u2500 max.rs \u2502 \u2514\u2500\u2500 mod.rs \u251c\u2500\u2500 lib.rs \u2514\u2500\u2500 main.rs > cat lib.rs pub mod foo; > cat main.rs use moduleblog; fn main() { println!(\"{}\", moduleblog::foo::bar(String::from(\"baz\"))); println!(\"{}\", moduleblog::foo::max::baz(String::from(\"baz\"))); println!(\"{}\", libmodule::libfoo::gimme_a_song()); } Note how one now consumes the application itself as a library in the main module. For someone not using rust versions before 2018 you have to add an external crate moduleblog before the use statement;","title":"What if there is lib.rs AND a main.rs ?"},{"location":"markdown/crates-and-roots/#conclusion","text":"I haven't covered modules fully as it wasn't my intention (and neither have I used all of the features) I had run into this pain point of organizing my code and not knowing how the heirarchy works and while the compiler was nice enough to get me to a solution without having to fully understand (a testament to how friendly the Rust compiler is) I wrote this blog with the intention of understanding crates and crate roots and I hope it helps. You can find the source code for the post here","title":"Conclusion"},{"location":"markdown/crates-and-roots/#references","text":"It wouldn't have been possible to understand all of this without help from others. These are the references that helped me the most (and I remembered). Thanks to the community for being helpful as always ! https://github.com/rust-lang/book/issues/721 https://doc.rust-lang.org/1.1.0/book/crates-and-modules.html https://learning-rust.github.io/docs/d4.crates.html","title":"References"},{"location":"markdown/spacesandtabsvim/","text":"Understanding tabstop , shiftwidth , softtabstop and expandtab Dealing with tabs and spaces can be tricky with vim. Here I try to explain how 3 options work to configure vim. tabstop Tabstop defines how many spaces each tab byte in the file represents. If a file has tab bytes, then if tabstop (or ts ) is set to 4 , then each tab visually expands to 4 spaces. tabstop does not automatically convert tabs to spaces. It just merely represents each tab as the number of spaces it is defined to. shiftwidth shiftwidth governs by how many spaces, a line has to be indented left or right when a << or a >> (indent) command is generated in visual mode. If shiftwidth is set to 2 , each << moves the indentation 2 spaces left. If shiftwidth != tabstop , then the tab character, is optionally converted to spaces and or tabs. For example, if you have a tabstop of 8 and a shiftwidth or 2 and you have a \\tdata , the data appears visually to have 8spaces data . Left shifting with << , 6 space chars are inserted. If tabstop were 4, and you have a line \\t\\tdata , with shiftwidth=2 , and you left-ident the line, the line is converted to \\t\\s\\sdata . In general, shiftwidth will try to maximize the number of tabs. softtabstop softtabstop (or sts ), when editing text, defines how many spaces and tabs are inserted/deleted when a tab or a BS (backspace) key is pressed. The number of spaces/tabs added depends on the exact settings. For example, if sts=2 and tabstop=4 , each tab or backspace , adds or deletes 2 spaces. If sts=6 and tabstop=4 , then each tab press adds a tab and a \\t\\s\\s and deletes a \\t\\s\\s respectively. expandtab When set, expandtab converts tabs to spaces when a tab is pressed. The number of spaces that are inserted for every tab depends on the configuration. If softtabstop is set, each tab is expanded to softtabstop no. of spaces. Else, tabstop no. of spaces are inserted Playing with tab settings You can play around with ts , sts and shiftwidth settings and understand how they work. To visualize tabs nicely, set the following options in your ~/.vimrc (or other config file, in case of neovim), so that tabs show up as a >- visually. set list set listchars=tab:>- Try setting different sts , ts and shiftwidth values and turning on and off expandtab . References https://vim.fandom.com/wiki/Converting_tabs_to_spaces https://www.reddit.com/r/vim/comments/99ylz8/confused_about_the_difference_between_tabstop_and/","title":"Understanding `tabstop`, `shiftwidth`, `softtabstop` and `expandtab`"},{"location":"markdown/spacesandtabsvim/#understanding-tabstop-shiftwidth-softtabstop-and-expandtab","text":"Dealing with tabs and spaces can be tricky with vim. Here I try to explain how 3 options work to configure vim.","title":"Understanding tabstop, shiftwidth, softtabstop and expandtab"},{"location":"markdown/spacesandtabsvim/#tabstop","text":"Tabstop defines how many spaces each tab byte in the file represents. If a file has tab bytes, then if tabstop (or ts ) is set to 4 , then each tab visually expands to 4 spaces. tabstop does not automatically convert tabs to spaces. It just merely represents each tab as the number of spaces it is defined to.","title":"tabstop"},{"location":"markdown/spacesandtabsvim/#shiftwidth","text":"shiftwidth governs by how many spaces, a line has to be indented left or right when a << or a >> (indent) command is generated in visual mode. If shiftwidth is set to 2 , each << moves the indentation 2 spaces left. If shiftwidth != tabstop , then the tab character, is optionally converted to spaces and or tabs. For example, if you have a tabstop of 8 and a shiftwidth or 2 and you have a \\tdata , the data appears visually to have 8spaces data . Left shifting with << , 6 space chars are inserted. If tabstop were 4, and you have a line \\t\\tdata , with shiftwidth=2 , and you left-ident the line, the line is converted to \\t\\s\\sdata . In general, shiftwidth will try to maximize the number of tabs.","title":"shiftwidth"},{"location":"markdown/spacesandtabsvim/#softtabstop","text":"softtabstop (or sts ), when editing text, defines how many spaces and tabs are inserted/deleted when a tab or a BS (backspace) key is pressed. The number of spaces/tabs added depends on the exact settings. For example, if sts=2 and tabstop=4 , each tab or backspace , adds or deletes 2 spaces. If sts=6 and tabstop=4 , then each tab press adds a tab and a \\t\\s\\s and deletes a \\t\\s\\s respectively.","title":"softtabstop"},{"location":"markdown/spacesandtabsvim/#expandtab","text":"When set, expandtab converts tabs to spaces when a tab is pressed. The number of spaces that are inserted for every tab depends on the configuration. If softtabstop is set, each tab is expanded to softtabstop no. of spaces. Else, tabstop no. of spaces are inserted","title":"expandtab"},{"location":"markdown/spacesandtabsvim/#playing-with-tab-settings","text":"You can play around with ts , sts and shiftwidth settings and understand how they work. To visualize tabs nicely, set the following options in your ~/.vimrc (or other config file, in case of neovim), so that tabs show up as a >- visually. set list set listchars=tab:>- Try setting different sts , ts and shiftwidth values and turning on and off expandtab .","title":"Playing with tab settings"},{"location":"markdown/spacesandtabsvim/#references","text":"https://vim.fandom.com/wiki/Converting_tabs_to_spaces https://www.reddit.com/r/vim/comments/99ylz8/confused_about_the_difference_between_tabstop_and/","title":"References"},{"location":"markdown/stopcaring/","text":"There is too much of everything today I sat down to write this out of sheer frustration. I was sick of feeling like I have accomplished nothing I was feeling that my life was out of control. I was feeling like I am drowning in a sea of noise. When humans were young on this planet, refined energy sources were hard to come by. Sugars, carbohydrates were scarce. They cost a lot of energy to search for, to grow and to consume. Time spent hunting for protein and fat saved was more worthwhile than foraging for sweet stuff. Fruits were probably barely a tenth as big as they are today. A ready access to food was almost impossible. It kept us lean, our teeth from rotting, our body from sagging. Then came the 20th century, with a revolution in fertilizers, pesticides, food processing and storage. Ability to genetically to modify food to produce, bigger, sweeter varieties. We went from being food scarce to being food surplus. Make no mistake, hunger and a lack of food is not a supply problem, but one of distribution. Amartya Sen's Nobel winning thesis was precisely on this. The same is true of the brain and information Imagine a time before the internet. Information was hard to come by. Unless you make your way to the library, you wouldn't be able to read more than a newspaper or two. You had work through 1000s of pages to find the information you need. Any research involved potentially physically moving yourself to different places to look for what you seek. Your mind was starved for information. Then the internet happened You can acces millions of pages from the tiny phone in your hands. At no point in history has there ever been so much information readliy available. From science to engineering, trivia to gossip, everything is merely a click away. We aren't meant to process so much information It confuses. It makes us insecure. It makes us indecisive. We are drowing in a sea of noise. Of irrelevance. Of ephemeral details. When was the last time you gorged a book top to bottom, again and again ? The best memories I have are of books I probably read 20 times, in a land before the Internet. I forgot most of the details, yet I remember far less, of the information that I read today. It is only getting worse. What good is reading a 100 books if you aren't processing and using that information to make you more happy, satisfied and feeling accomplished ? What do you gain from competing with your friends on who has read the most # of books in a year ? What satisfying knowledge do you get from reading 100 non-fiction books on different topics, if it isn't adding any value to you, except for a shallow sense of \"Oh, I am such a widely read person\". Depth satisfies the brain. Depth of knowledge in a specific field. Skill and craft takes years. I like craftsmanship. It takes years to master a specific craft. Woodworking, machining, weaving, electronics, being a GOOD programmer all takes patience and years. Our lust for quick bits of information is like a sugar rush, a whiff of cocaine. It makes us feel smart for the moment, then when drained, makes us all feel depressed and empty. Abundance is as bad as scarcity. First steps I deleted my Facebook, Instagram a few months ago. Best decision yet. I no longer get doubts about my life being bad or not as good as some of my friends. I don't care. I deactivated my Twitter account. Let's see how it goes. I have promised myself to not carry my phone in the pocket when out on a walk, or during the commute. My internet will be turned OFF for a few hours a day. I will go back to writing stuff down in a notebook, with a pen. I will put myself through a period of scarcity, to work for the information I need. I promise to not read more than 10 books a year. A good book can take years before you understand it's true value. Simultaenously, it teaches you what sort of books are actually valuable. The longer a book remains famous, the more valuable is the information. Stop caring so much about the world The world goes on. Doesn't give a fuck. So don't give a fuck about it either. All politicians are self-centered assholes. All celebrities' lives are vacuous. All influencers, travelers, photographers and fitness enthusiasts show you a false life. Every one of your fitness guru has probably had multiple surgeries. Your influencers lie on a daily basis. Work on yourself. Find out what you want to do in your life. Then do it. No contemplation. Just do it.","title":"Stopcaring"},{"location":"markdown/stopcaring/#there-is-too-much-of-everything-today","text":"I sat down to write this out of sheer frustration. I was sick of feeling like I have accomplished nothing I was feeling that my life was out of control. I was feeling like I am drowning in a sea of noise. When humans were young on this planet, refined energy sources were hard to come by. Sugars, carbohydrates were scarce. They cost a lot of energy to search for, to grow and to consume. Time spent hunting for protein and fat saved was more worthwhile than foraging for sweet stuff. Fruits were probably barely a tenth as big as they are today. A ready access to food was almost impossible. It kept us lean, our teeth from rotting, our body from sagging. Then came the 20th century, with a revolution in fertilizers, pesticides, food processing and storage. Ability to genetically to modify food to produce, bigger, sweeter varieties. We went from being food scarce to being food surplus. Make no mistake, hunger and a lack of food is not a supply problem, but one of distribution. Amartya Sen's Nobel winning thesis was precisely on this.","title":"There is too much of everything today"},{"location":"markdown/stopcaring/#the-same-is-true-of-the-brain-and-information","text":"Imagine a time before the internet. Information was hard to come by. Unless you make your way to the library, you wouldn't be able to read more than a newspaper or two. You had work through 1000s of pages to find the information you need. Any research involved potentially physically moving yourself to different places to look for what you seek. Your mind was starved for information.","title":"The same is true of the brain and information"},{"location":"markdown/stopcaring/#then-the-internet-happened","text":"You can acces millions of pages from the tiny phone in your hands. At no point in history has there ever been so much information readliy available. From science to engineering, trivia to gossip, everything is merely a click away.","title":"Then the internet happened"},{"location":"markdown/stopcaring/#we-arent-meant-to-process-so-much-information","text":"It confuses. It makes us insecure. It makes us indecisive. We are drowing in a sea of noise. Of irrelevance. Of ephemeral details. When was the last time you gorged a book top to bottom, again and again ? The best memories I have are of books I probably read 20 times, in a land before the Internet. I forgot most of the details, yet I remember far less, of the information that I read today. It is only getting worse. What good is reading a 100 books if you aren't processing and using that information to make you more happy, satisfied and feeling accomplished ? What do you gain from competing with your friends on who has read the most # of books in a year ? What satisfying knowledge do you get from reading 100 non-fiction books on different topics, if it isn't adding any value to you, except for a shallow sense of \"Oh, I am such a widely read person\".","title":"We aren't meant to process so much information"},{"location":"markdown/stopcaring/#depth-satisfies-the-brain","text":"Depth of knowledge in a specific field. Skill and craft takes years. I like craftsmanship. It takes years to master a specific craft. Woodworking, machining, weaving, electronics, being a GOOD programmer all takes patience and years. Our lust for quick bits of information is like a sugar rush, a whiff of cocaine. It makes us feel smart for the moment, then when drained, makes us all feel depressed and empty. Abundance is as bad as scarcity.","title":"Depth satisfies the brain."},{"location":"markdown/stopcaring/#first-steps","text":"I deleted my Facebook, Instagram a few months ago. Best decision yet. I no longer get doubts about my life being bad or not as good as some of my friends. I don't care. I deactivated my Twitter account. Let's see how it goes. I have promised myself to not carry my phone in the pocket when out on a walk, or during the commute. My internet will be turned OFF for a few hours a day. I will go back to writing stuff down in a notebook, with a pen. I will put myself through a period of scarcity, to work for the information I need. I promise to not read more than 10 books a year. A good book can take years before you understand it's true value. Simultaenously, it teaches you what sort of books are actually valuable. The longer a book remains famous, the more valuable is the information.","title":"First steps"},{"location":"markdown/stopcaring/#stop-caring-so-much-about-the-world","text":"The world goes on. Doesn't give a fuck. So don't give a fuck about it either. All politicians are self-centered assholes. All celebrities' lives are vacuous. All influencers, travelers, photographers and fitness enthusiasts show you a false life. Every one of your fitness guru has probably had multiple surgeries. Your influencers lie on a daily basis. Work on yourself. Find out what you want to do in your life. Then do it. No contemplation. Just do it.","title":"Stop caring so much about the world"},{"location":"markdown/syscallrust/","text":"Syscalls with Rust I came to know of the Doom Fire Technique for generating the opening scene of the Doom game and I tried to implement it on the command line. If you ever wonder how CLI applications show colored output, there are ANSI escape sequences that one can output for controlling color, text highlighting etc. ANSI escape sequences starts with an ESC character 0x1B followed by a byte in the 0x40-0x5F range. You can read more about ANSI escape codes here Anyway, while my attempt to implement the Doom Fire algorithm using ANSI escape codes ended up looking something like this: I ended up learning a lot more about system calls. The algorithm relies on treating the screen as a 2D grid of cells consisting of rows and columns, which lead me to the question: How do I know how many rows and columns does my terminal have ? Turns out there is a simple command that tells you stty -a It also displays a lot more information that might not be relevant today (example: it shows Baud rate, which is meaningless in the days of pseudoterminals but were set by real Terminal devices that used a serial connection to the computer in the basement) Here is the output of stty -a from my terminal speed 38400 baud; rows 36; columns 146; line = 0; intr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0; -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel iutf8 opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc Now how do we get this information in our program Attempt 1 I wrote a function that creates a new process running stty and then reading the STDOUT of the process and parsing the output to obtain the rows and columns value from it. Here is how the fn looks fn get_tty_rows_columns() -> Result<(i32, i32), String> { let c = Command::new(\"stty\") .arg(\"-a\") .stdin(Stdio::inherit()) .output() .expect(\"failed to get terminal attributes\"); let stty_result = std::str::from_utf8(&c.stdout).unwrap().split(\";\").collect::<Vec<_>>(); let mut rows = 0; let mut cols = 0; for setting in stty_result { if let Some(idx) = setting.find(\"rows\") { let row_setting = setting.trim().split(\" \").collect::<Vec<_>>(); rows = row_setting[1].parse::<i32>().unwrap(); } else if let Some(idx) = setting.find(\"columns\") { let col_setting = setting.trim().split(\" \").collect::<Vec<_>>(); cols = col_setting[1].parse::<i32>().unwrap(); } else { } } Ok((rows, cols)) } Kinda messy, but gets the job done. But wait a minute. We are in UNIX land. Can we not figure out how stty obtains information about the terminal that it formats nicely before displaying to us ? Ofcourse ! Enter strace ! strace shows the system calls made by a program and their arguments. We could look at the system calls list to figure out which of the system calls provides us with information about the terminal Doing a strace stty -a gives the following output Elided output that is not relevant currently and is too large to display ioctl(0, TCGETS, {B38400 opost isig icanon echo ...}) = 0 ioctl(1, TIOCGWINSZ, {ws_row=36, ws_col=146, ws_xpixel=0, ws_ypixel=0}) = 0 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 7), ...}) = 0 ioctl(0, TIOCGWINSZ, {ws_row=36, ws_col=146, ws_xpixel=0, ws_ypixel=0}) = 0 write(1, \"speed 38400 baud; rows 36; colum\"..., 50speed 38400 baud; rows 36; columns 146; line = 0; ) = 50 write(1, \"intr = ^C; quit = ^\\\\; erase = ^?\"..., 137intr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; ) = 137 write(1, \"rprnt = ^R; werase = ^W; lnext =\"..., 70rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0; ) = 70 write(1, \"-parenb -parodd -cmspar cs8 -hup\"..., 66-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts ) = 66 write(1, \"-ignbrk -brkint -ignpar -parmrk \"..., 108-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel iutf8 ) = 108 write(1, \"opost -olcuc -ocrnl onlcr -onocr\"..., 80opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 ) = 80 write(1, \"isig icanon iexten echo echoe ec\"..., 108isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc ) = 108 Bingo ! It looks there is an ioctl that refers to something called ws_row and ws_col that contains the values we need. Googling about ioctl tells me that this is a REALLY powerful system call, used (and abused) to control all sorts of Linux devices In this case, ioctl takes a TIOCGWINSZ (terminal config window size?) constant and its argument is a struct winsize that is filled with the details of the terminal if the call is successful. Now comes the next step: How do we make the system call from our Rust program? With C the answer is as simply as using ioctl.h , which contains all the definitions and implementations that we need. Nix and libc The libc crate provides type definitions and structs required for C or C-like code from Rust programs. This crate contains the definitions that we would need to interact with the Linux system calls libc also has an implementation of ioctl but it looked a bit hard to use it, so enter the nix crate. Nix provides a set of of safe bindings over the libc crate and has a bunch of macros to make it easier to deal with unsafe code Here is how we now use system calls directly from our code: use libc; use nix::{ioctl_read_bad, convert_ioctl_res}; nix::ioctl_read_bad!(read_terminal_size, libc::TIOCGWINSZ , libc::winsize); let mut s: libc::winsize; unsafe { s = std::mem::uninitialized(); read_terminal_size(1, &mut s); } println!(\"\\n\\n\\n\\n\\n rows {} cols {} \\n\\n\\n\\n\", s.ws_row, s.ws_col); The ioctl_read_bad macro creates a fn with the name passed to it as the first argument and the rest as arguments to the ioctl call. When calling the name , you then simply pass in te File descriptor of the device whose info you need and the data structure that serves as the input/output information for the system call. rows 36 cols 146 : What we needed, but much more easier to obtain ! Conclusion ANSI escape codes are a lot fun, and you can use them to build some really interesting CLI applications. There is also a termios crate if you don't want to use escape codes directly and prefer using a library instead. Source here","title":"Syscalls with Rust"},{"location":"markdown/syscallrust/#syscalls-with-rust","text":"I came to know of the Doom Fire Technique for generating the opening scene of the Doom game and I tried to implement it on the command line. If you ever wonder how CLI applications show colored output, there are ANSI escape sequences that one can output for controlling color, text highlighting etc. ANSI escape sequences starts with an ESC character 0x1B followed by a byte in the 0x40-0x5F range. You can read more about ANSI escape codes here Anyway, while my attempt to implement the Doom Fire algorithm using ANSI escape codes ended up looking something like this: I ended up learning a lot more about system calls. The algorithm relies on treating the screen as a 2D grid of cells consisting of rows and columns, which lead me to the question: How do I know how many rows and columns does my terminal have ? Turns out there is a simple command that tells you stty -a It also displays a lot more information that might not be relevant today (example: it shows Baud rate, which is meaningless in the days of pseudoterminals but were set by real Terminal devices that used a serial connection to the computer in the basement) Here is the output of stty -a from my terminal speed 38400 baud; rows 36; columns 146; line = 0; intr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0; -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel iutf8 opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc Now how do we get this information in our program","title":"Syscalls with Rust"},{"location":"markdown/syscallrust/#attempt-1","text":"I wrote a function that creates a new process running stty and then reading the STDOUT of the process and parsing the output to obtain the rows and columns value from it. Here is how the fn looks fn get_tty_rows_columns() -> Result<(i32, i32), String> { let c = Command::new(\"stty\") .arg(\"-a\") .stdin(Stdio::inherit()) .output() .expect(\"failed to get terminal attributes\"); let stty_result = std::str::from_utf8(&c.stdout).unwrap().split(\";\").collect::<Vec<_>>(); let mut rows = 0; let mut cols = 0; for setting in stty_result { if let Some(idx) = setting.find(\"rows\") { let row_setting = setting.trim().split(\" \").collect::<Vec<_>>(); rows = row_setting[1].parse::<i32>().unwrap(); } else if let Some(idx) = setting.find(\"columns\") { let col_setting = setting.trim().split(\" \").collect::<Vec<_>>(); cols = col_setting[1].parse::<i32>().unwrap(); } else { } } Ok((rows, cols)) } Kinda messy, but gets the job done. But wait a minute. We are in UNIX land. Can we not figure out how stty obtains information about the terminal that it formats nicely before displaying to us ? Ofcourse ! Enter strace ! strace shows the system calls made by a program and their arguments. We could look at the system calls list to figure out which of the system calls provides us with information about the terminal Doing a strace stty -a gives the following output Elided output that is not relevant currently and is too large to display ioctl(0, TCGETS, {B38400 opost isig icanon echo ...}) = 0 ioctl(1, TIOCGWINSZ, {ws_row=36, ws_col=146, ws_xpixel=0, ws_ypixel=0}) = 0 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 7), ...}) = 0 ioctl(0, TIOCGWINSZ, {ws_row=36, ws_col=146, ws_xpixel=0, ws_ypixel=0}) = 0 write(1, \"speed 38400 baud; rows 36; colum\"..., 50speed 38400 baud; rows 36; columns 146; line = 0; ) = 50 write(1, \"intr = ^C; quit = ^\\\\; erase = ^?\"..., 137intr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; ) = 137 write(1, \"rprnt = ^R; werase = ^W; lnext =\"..., 70rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0; ) = 70 write(1, \"-parenb -parodd -cmspar cs8 -hup\"..., 66-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts ) = 66 write(1, \"-ignbrk -brkint -ignpar -parmrk \"..., 108-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel iutf8 ) = 108 write(1, \"opost -olcuc -ocrnl onlcr -onocr\"..., 80opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 ) = 80 write(1, \"isig icanon iexten echo echoe ec\"..., 108isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -extproc ) = 108 Bingo ! It looks there is an ioctl that refers to something called ws_row and ws_col that contains the values we need. Googling about ioctl tells me that this is a REALLY powerful system call, used (and abused) to control all sorts of Linux devices In this case, ioctl takes a TIOCGWINSZ (terminal config window size?) constant and its argument is a struct winsize that is filled with the details of the terminal if the call is successful. Now comes the next step: How do we make the system call from our Rust program? With C the answer is as simply as using ioctl.h , which contains all the definitions and implementations that we need.","title":"Attempt 1"},{"location":"markdown/syscallrust/#nix-and-libc","text":"The libc crate provides type definitions and structs required for C or C-like code from Rust programs. This crate contains the definitions that we would need to interact with the Linux system calls libc also has an implementation of ioctl but it looked a bit hard to use it, so enter the nix crate. Nix provides a set of of safe bindings over the libc crate and has a bunch of macros to make it easier to deal with unsafe code Here is how we now use system calls directly from our code: use libc; use nix::{ioctl_read_bad, convert_ioctl_res}; nix::ioctl_read_bad!(read_terminal_size, libc::TIOCGWINSZ , libc::winsize); let mut s: libc::winsize; unsafe { s = std::mem::uninitialized(); read_terminal_size(1, &mut s); } println!(\"\\n\\n\\n\\n\\n rows {} cols {} \\n\\n\\n\\n\", s.ws_row, s.ws_col); The ioctl_read_bad macro creates a fn with the name passed to it as the first argument and the rest as arguments to the ioctl call. When calling the name , you then simply pass in te File descriptor of the device whose info you need and the data structure that serves as the input/output information for the system call. rows 36 cols 146 : What we needed, but much more easier to obtain !","title":"Nix and libc"},{"location":"markdown/syscallrust/#conclusion","text":"ANSI escape codes are a lot fun, and you can use them to build some really interesting CLI applications. There is also a termios crate if you don't want to use escape codes directly and prefer using a library instead.","title":"Conclusion"},{"location":"markdown/syscallrust/#source","text":"here","title":"Source"},{"location":"markdown/transducer/","text":"Transducers - A Walkthrough The idea of the article is to provide a walkthrough guide of sorts for understandig a transducer in Clojure. You can play with the code mentioned below by downloading this file and executing the code in the REPL. (ns transducertutorial.core) ;; A Reducing function is one that takes ;; an accumulator and an item ;; and returns a new accumulator with the item processed (defn my-reducing-fn [accumulator item] (conj accumulator item)) ;; conj is smart enough to know how to how to add the item to the ;; accumulator ;; even conj is a reducing-fn ;; How do we use something like conj to implement map and filter ? ;; Via reduce . Reduce takes a reducing fn., an accumulator and a ;; the collection that must be reduced. (reduce (fn [acc item] (conj acc item)) [] [1 2 3 4 5]) ;; We can implement map and filter via reduce (defn map-via-reduce [mapping-fn coll] (reduce (fn [acc item] (conj acc (mapping-fn item))) [] coll)) (defn filter-via-reduce [filter-fn coll] (reduce (fn [acc item] (if (filter-fn item) (conj acc item) acc) [] coll))) ;; There are 3 tight \"couplings\" ;; a) We use conj to add item to the accumulator ;; b) We use an empty vector [] as the collection ;; for reduction ;; c) If we want to compose our map and filter fns, we can pass the output ;; of one to the other. While doing so we are creating a new collection after ;; each map or reduce, which can be very expensive in terms of memory and ;; computation time ;; Ideally we would a composition of map and filter to look like (defn map-fn [item] (inc item)) (defn filter-fn [item] (some? item)) (reduce (fn [acc item] (if (filter-fn item) (conj acc (map-fn item)) acc)) [] [1 2 3 4 5]) I would say that this, perhaps is the core idea behind transducers, behing able to compose our input processing functions in such a way that they are run only once for each item ;; Lets make a couple of small changes to a reducing function ;; by adding an arity-0 and an arity-1 variation to it (defn my-rf ([] []) ([result] result) ([result input] (conj result input))) ;; Our reducing fn can now ;; a. create a new collection, if called with no args ;; b. if not provided an item but only with a collection, pass the collection on ;; c. when it gets a collection and an item knows how to add the item to ;; the collection`. ;; Let us also create a more \"fun\" version of a multi-arity ;; reducing fn. (defn str-rf ([] \"\") ([a-string] a-string) ([a-string a-input] (str a-string a-input))) ;; we now make tweak map and filter to make them a transducer, a.k.a transforming reducer ;; Map and filter accept a fn as usual, but instead of accepting ;; a mapping fn and a collection, ;; we also have a version where (defn my-map ([f] (fn [rf] (fn ([] (rf)) ([result] result) ([result input] (rf result (f input)))))) ;; The traditional map version ;; There are more arities that accept 2,3 and n colls ;; but I have left them out for the sake of clarity ([f coll] (map f coll))) (defn my-filter [f] (fn [rf] (fn ([] (rf)) ([result] result) ([result input] (if (f input) (rf result input) result))))) ;; Order of applying fns is left -> right (even? is applied first before inc) (transduce (comp (my-filter even?) (my-map inc)) my-rf [10 12 14]) ;; [11 13 15] (transduce (comp (my-filter even?) (my-map inc)) my-rf [10 12 14]) ;; [] ;; What is happening here ? ;; what transduce does internally is ((comp (my-filter even?) (my-map inc)) my-rf) ;; which translates to something like (comment (let [inc-mapped (my-map inc) inc-with-rf (inc-mapped my-rf) even-filter (my-filter even?) even-filter-rf (even-filter inc-with-rf)] even-filter-rf)) ;; What even-filter-rf will do when when it gets an accumulator ;; and an input is something akin to ;; (fn [acc input] (if (even? input) (inc-with-rf acc input) acc)) ;; Notice that inc-with-rf is exactly of the same format. ;; Here, replace the (if (even? input) ..) with (my-rf acc (inc input) ;; lets use our str-rf to see how it works (transduce (comp (my-filter even?) (my-map inc)) str-rf [10 12 14]) ;; We have solved 2 problems so far. ;; 1. Decouple the creation of the output collection by letting the ;; reducing fn take care of that ;; 2. Ensuring that the composition of our filter and map is run only once ;; for each item in our collection ;; There is one more problem: how do we iterate over the input collection? ;; Enter protocols to the rescue ;; Collections implement clojure.lang.IReduceInit ;; or implement clojure.core.protocols/coll-reduce ;; All collections that implement IReduceInit know how to take ;; a. An accumulator ;; b. A reducing fn ;; And reduce themselves using the reducing fn and the accumulator ;; The same goes for coll-reduce ;; We thus solved the problem of iterating (folding) over the collection by letting the ;; collection do it for us. ;; There is also an interesting property of the built-in reduce. ;; A value can be marked reduced , in which case, reduce will simply ;; return the reduced value as the result of the reduce (fold) on the collection (reduce (fn [acc v] (if (= v 5) (reduced 5) (conj acc v))) [] [1 2 3 4]) (reduce (fn [acc v] (if (= v 5) (reduced 5) (conj acc v))) [] [1 2 3 4 5]) ;; You can use reduced to indicate that you no longer want to process a collection further ;; and terminate the fold with the reduced value. ;; This is useful if you want to for example, process the collection until you find the ;; item x, or process the first n items in a collection. ;; take-while takes a fn f and processes the collection, until (f item) returns false ;; and returns the folded value so far. ;; Let us implement our take-while (defn my-take-while [f] (fn [rf] (fn ([] (rf)) ([result] result) ([result input] (if (f input) (rf result input) (reduced result)))))) (transduce (comp (map inc) (my-take-while (fn [n] (< n 50)))) conj [10 44 56 63 2]) ;; => [11 45] ;; There are also transducers that can do stateful transformations. ;; One such transformer is take (defn take [n] (fn [rf] ;; clojure.core/take uses a volatile! which is out of scope for this ;; article (let [counter (atom n)] (fn ([] (rf)) ([result] result) ([result input] (let [v @counter nn (swap! counter dec)] (if (pos? v) (rf result input) (reduced result)))))))) (transduce (comp (map inc) (take 5)) conj (range 1 1000))","title":"Transducers - A Walkthrough"},{"location":"markdown/transducer/#transducers-a-walkthrough","text":"The idea of the article is to provide a walkthrough guide of sorts for understandig a transducer in Clojure. You can play with the code mentioned below by downloading this file and executing the code in the REPL. (ns transducertutorial.core) ;; A Reducing function is one that takes ;; an accumulator and an item ;; and returns a new accumulator with the item processed (defn my-reducing-fn [accumulator item] (conj accumulator item)) ;; conj is smart enough to know how to how to add the item to the ;; accumulator ;; even conj is a reducing-fn ;; How do we use something like conj to implement map and filter ? ;; Via reduce . Reduce takes a reducing fn., an accumulator and a ;; the collection that must be reduced. (reduce (fn [acc item] (conj acc item)) [] [1 2 3 4 5]) ;; We can implement map and filter via reduce (defn map-via-reduce [mapping-fn coll] (reduce (fn [acc item] (conj acc (mapping-fn item))) [] coll)) (defn filter-via-reduce [filter-fn coll] (reduce (fn [acc item] (if (filter-fn item) (conj acc item) acc) [] coll))) ;; There are 3 tight \"couplings\" ;; a) We use conj to add item to the accumulator ;; b) We use an empty vector [] as the collection ;; for reduction ;; c) If we want to compose our map and filter fns, we can pass the output ;; of one to the other. While doing so we are creating a new collection after ;; each map or reduce, which can be very expensive in terms of memory and ;; computation time ;; Ideally we would a composition of map and filter to look like (defn map-fn [item] (inc item)) (defn filter-fn [item] (some? item)) (reduce (fn [acc item] (if (filter-fn item) (conj acc (map-fn item)) acc)) [] [1 2 3 4 5]) I would say that this, perhaps is the core idea behind transducers, behing able to compose our input processing functions in such a way that they are run only once for each item ;; Lets make a couple of small changes to a reducing function ;; by adding an arity-0 and an arity-1 variation to it (defn my-rf ([] []) ([result] result) ([result input] (conj result input))) ;; Our reducing fn can now ;; a. create a new collection, if called with no args ;; b. if not provided an item but only with a collection, pass the collection on ;; c. when it gets a collection and an item knows how to add the item to ;; the collection`. ;; Let us also create a more \"fun\" version of a multi-arity ;; reducing fn. (defn str-rf ([] \"\") ([a-string] a-string) ([a-string a-input] (str a-string a-input))) ;; we now make tweak map and filter to make them a transducer, a.k.a transforming reducer ;; Map and filter accept a fn as usual, but instead of accepting ;; a mapping fn and a collection, ;; we also have a version where (defn my-map ([f] (fn [rf] (fn ([] (rf)) ([result] result) ([result input] (rf result (f input)))))) ;; The traditional map version ;; There are more arities that accept 2,3 and n colls ;; but I have left them out for the sake of clarity ([f coll] (map f coll))) (defn my-filter [f] (fn [rf] (fn ([] (rf)) ([result] result) ([result input] (if (f input) (rf result input) result))))) ;; Order of applying fns is left -> right (even? is applied first before inc) (transduce (comp (my-filter even?) (my-map inc)) my-rf [10 12 14]) ;; [11 13 15] (transduce (comp (my-filter even?) (my-map inc)) my-rf [10 12 14]) ;; [] ;; What is happening here ? ;; what transduce does internally is ((comp (my-filter even?) (my-map inc)) my-rf) ;; which translates to something like (comment (let [inc-mapped (my-map inc) inc-with-rf (inc-mapped my-rf) even-filter (my-filter even?) even-filter-rf (even-filter inc-with-rf)] even-filter-rf)) ;; What even-filter-rf will do when when it gets an accumulator ;; and an input is something akin to ;; (fn [acc input] (if (even? input) (inc-with-rf acc input) acc)) ;; Notice that inc-with-rf is exactly of the same format. ;; Here, replace the (if (even? input) ..) with (my-rf acc (inc input) ;; lets use our str-rf to see how it works (transduce (comp (my-filter even?) (my-map inc)) str-rf [10 12 14]) ;; We have solved 2 problems so far. ;; 1. Decouple the creation of the output collection by letting the ;; reducing fn take care of that ;; 2. Ensuring that the composition of our filter and map is run only once ;; for each item in our collection ;; There is one more problem: how do we iterate over the input collection? ;; Enter protocols to the rescue ;; Collections implement clojure.lang.IReduceInit ;; or implement clojure.core.protocols/coll-reduce ;; All collections that implement IReduceInit know how to take ;; a. An accumulator ;; b. A reducing fn ;; And reduce themselves using the reducing fn and the accumulator ;; The same goes for coll-reduce ;; We thus solved the problem of iterating (folding) over the collection by letting the ;; collection do it for us. ;; There is also an interesting property of the built-in reduce. ;; A value can be marked reduced , in which case, reduce will simply ;; return the reduced value as the result of the reduce (fold) on the collection (reduce (fn [acc v] (if (= v 5) (reduced 5) (conj acc v))) [] [1 2 3 4]) (reduce (fn [acc v] (if (= v 5) (reduced 5) (conj acc v))) [] [1 2 3 4 5]) ;; You can use reduced to indicate that you no longer want to process a collection further ;; and terminate the fold with the reduced value. ;; This is useful if you want to for example, process the collection until you find the ;; item x, or process the first n items in a collection. ;; take-while takes a fn f and processes the collection, until (f item) returns false ;; and returns the folded value so far. ;; Let us implement our take-while (defn my-take-while [f] (fn [rf] (fn ([] (rf)) ([result] result) ([result input] (if (f input) (rf result input) (reduced result)))))) (transduce (comp (map inc) (my-take-while (fn [n] (< n 50)))) conj [10 44 56 63 2]) ;; => [11 45] ;; There are also transducers that can do stateful transformations. ;; One such transformer is take (defn take [n] (fn [rf] ;; clojure.core/take uses a volatile! which is out of scope for this ;; article (let [counter (atom n)] (fn ([] (rf)) ([result] result) ([result input] (let [v @counter nn (swap! counter dec)] (if (pos? v) (rf result input) (reduced result)))))))) (transduce (comp (map inc) (take 5)) conj (range 1 1000))","title":"Transducers - A Walkthrough"}]}