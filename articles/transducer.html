<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   Made with Remarkable!
  </title>
  <link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <style type="text/css">
   body,table tr{background-color:#fff}table tr td,table tr th{border:1px solid #ccc;text-align:left;padding:6px 13px;margin:0}pre code,table,table tr{padding:0}hr,pre code{background:0 0}body{font:16px Helvetica,Arial,sans-serif;line-height:1.4;color:#333;word-wrap:break-word;padding:10px 15px}strong,table tr th{font-weight:700}h1{font-size:2em;margin:.67em 0;text-align:center}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h1,h2,h3,h4,h5,h6{font-weight:700;position:relative;margin-top:15px;margin-bottom:15px;line-height:1.1}h1,h2{border-bottom:1px solid #eee}hr{height:0;margin:15px 0;overflow:hidden;border:0;border-bottom:1px solid #ddd}a{color:#4183C4}a.absent{color:#c00}ol,ul{padding-left:15px;margin-left:5px}ol{list-style-type:lower-roman}table tr{border-top:1px solid #ccc;margin:0}table tr:nth-child(2n){background-color:#aaa}table tr td :first-child,table tr th :first-child{margin-top:0}table tr td:last-child,table tr th :last-child{margin-bottom:0}img{max-width:100%}blockquote{padding:0 15px;border-left:4px solid #ccc}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre code{margin:0;white-space:pre;border:none}.highlight pre,pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}
  </style>
 </head>
 <body>
  <h1 id="transducers-a-walkthrough">
   Transducers - A Walkthrough
  </h1>
  <p>
   The idea of the article is to provide a walkthrough guide of sorts for understandig
   <br/>
   a
   <code>
    transducer
   </code>
   in Clojure.
  </p>
  <p>
   You can play with the code mentioned below by downloading this
   <a href="https://gist.github.com/GoWind/24256bd633392bd9e70dcb30af62de10">
    file
   </a>
   and executing the code in the REPL.
  </p>
  <pre><code>(ns transducertutorial.core)
</code></pre>
  <p>
   ;; A Reducing function is one that takes
   <br/>
   ;; an accumulator and an item
   <br/>
   ;; and returns a new accumulator with the item processed
  </p>
  <pre><code>(defn my-reducing-fn
  [accumulator item]
  (conj accumulator item))
</code></pre>
  <p>
   ;;
   <code>
    conj
   </code>
   is smart enough to know how to how to add the item to the
   <br/>
   ;; accumulator
   <br/>
   ;; even conj is a reducing-fn
  </p>
  <p>
   ;; How do we use something like conj to implement map and filter ?
   <br/>
   ;; Via
   <code>
    reduce
   </code>
   . Reduce takes a reducing fn., an accumulator and a
   <br/>
   ;; the collection that must be reduced.
  </p>
  <pre><code>(reduce (fn [acc item] (conj acc item)) [] [1 2 3 4 5])
</code></pre>
  <p>
   ;; We can implement map and filter via reduce
  </p>
  <pre><code>(defn map-via-reduce
  [mapping-fn coll]
  (reduce (fn [acc item] (conj acc (mapping-fn item))) [] coll))
</code></pre>
  <pre><code>(defn filter-via-reduce
  [filter-fn coll]
  (reduce (fn [acc item] (if (filter-fn item) (conj acc item) acc) [] coll)))
</code></pre>
  <p>
   ;; There are 3 tight
   <strong>
    “couplings”
   </strong>
   <br/>
   ;; a) We use conj to add item to the accumulator
   <br/>
   ;; b) We use an empty vector [] as the collection
   <br/>
   ;;      for reduction
   <br/>
   ;; c) If we want to compose our map and filter fns, we can pass the output
   <br/>
   ;;     of one to the other. While doing so we are creating a new collection after
   <br/>
   ;;     each map or reduce, which can be very expensive in terms of memory and
   <br/>
   ;;     computation time
  </p>
  <p>
   ;; Ideally we would a composition of map and filter to look like
  </p>
  <pre><code>(defn map-fn [item] (inc item))
(defn filter-fn [item] (some? item))
(reduce (fn [acc item] (if (filter-fn item) (conj acc (map-fn item)) acc)) [] [1 2 3 4 5])
</code></pre>
  <p>
   <strong>
    I would say that this, perhaps is the core idea behind transducers,
    <br/>
    behing able to compose our input processing functions in such a way
    <br/>
    that they are run only once for each item
   </strong>
  </p>
  <p>
   ;; Lets make a couple of small changes to a reducing function
   <br/>
   ;; by adding an arity-0 and an arity-1 variation to it
  </p>
  <pre><code>(defn my-rf
  ([] [])
  ([result] result)
  ([result input] (conj result input)))
</code></pre>
  <p>
   ;; Our reducing fn can now
   <br/>
   ;; a. create a new
   <code>
    collection, if called with no args
;; b. if not provided an
   </code>
   item
   <code>
    but only with a collection, pass the collection on
;; c. when it gets a
   </code>
   collection
   <code>
    and an
   </code>
   item
   <code>
    knows how to add the
   </code>
   item
   <code>
    to
;; the
   </code>
   collection`.
  </p>
  <p>
   ;; Let us also create a more “fun” version of a multi-arity
   <br/>
   ;; reducing fn.
  </p>
  <pre><code>(defn str-rf
  ([] "")
  ([a-string] a-string)
  ([a-string a-input] (str a-string a-input)))
</code></pre>
  <p>
   ;; we now make tweak map and filter to make them a transducer, a.k.a transforming reducer
   <br/>
   ;; Map and filter accept a fn as usual, but instead of accepting
   <br/>
   ;; a mapping fn and a collection,
   <br/>
   ;; we also have a version where
  </p>
  <pre><code>(defn my-map
  ([f]
   (fn [rf]
     (fn
       ([] (rf))
       ([result] result)
       ([result input] (rf result (f input))))))
  ;; The traditional map version
  ;; There are more arities that accept 2,3 and n colls
  ;; but I have left them out for the sake of clarity
  ([f coll]
   (map f coll)))
</code></pre>
  <pre><code>(defn my-filter
  [f]
  (fn [rf]
    (fn
      ([] (rf))
      ([result] result)
      ([result input] (if (f input)
                        (rf result input)
                        result)))))
</code></pre>
  <p>
   ;; Order of applying fns is left -&gt; right (even? is applied first before inc)
  </p>
  <pre><code>(transduce (comp (my-filter even?) (my-map inc)) my-rf [10 12 14]) ;; [11 13 15]
</code></pre>
  <pre><code>(transduce (comp (my-filter even?) (my-map inc)) my-rf [10 12 14]) ;; []
</code></pre>
  <p>
   ;; What is happening here ?
   <br/>
   ;; what transduce does internally is ((comp (my-filter even?) (my-map inc)) my-rf)
   <br/>
   ;; which translates to something like
  </p>
  <pre><code>(comment
  (let [inc-mapped     (my-map inc)
        inc-with-rf    (inc-mapped my-rf)
        even-filter    (my-filter even?)
        even-filter-rf (even-filter inc-with-rf)]
    even-filter-rf))
</code></pre>
  <p>
   ;; What even-filter-rf will do when when it gets an accumulator
   <br/>
   ;; and an input is something akin to
   <br/>
   ;;
   <code>
    (fn [acc input] (if (even? input) (inc-with-rf acc input) acc))
   </code>
   <br/>
   ;; Notice that inc-with-rf is exactly of the same format.
   <br/>
   ;; Here, replace the
   <code>
    (if (even? input) ..)
   </code>
   with
   <code>
    (my-rf acc (inc input)
   </code>
  </p>
  <p>
   ;; lets use our str-rf to see how it works
  </p>
  <pre><code>(transduce (comp (my-filter even?) (my-map inc)) str-rf [10 12 14])
</code></pre>
  <p>
   ;; We have solved 2 problems so far.
   <br/>
   ;; 1. Decouple the creation of the output collection by letting the
   <br/>
   ;;    reducing fn take care of that
   <br/>
   ;; 2. Ensuring that the composition of our filter and map is run only once
   <br/>
   ;;    for each item in our collection
  </p>
  <p>
   ;; There is one more problem: how do we iterate over the input collection?
   <br/>
   ;; Enter protocols to the rescue
   <br/>
   ;; Collections implement clojure.lang.IReduceInit
   <br/>
   ;; or          implement clojure.core.protocols/coll-reduce
   <br/>
   ;; All collections that implement IReduceInit know how to take
   <br/>
   ;; a. An accumulator
   <br/>
   ;; b. A reducing fn
   <br/>
   ;; And reduce themselves using the reducing fn and the accumulator
   <br/>
   ;; The same goes for coll-reduce
   <br/>
   ;; We thus solved the problem of iterating (folding) over the collection by letting the
   <br/>
   ;; collection do it for us.
  </p>
  <p>
   ;; There is also an interesting property of the built-in reduce.
   <br/>
   ;; A value can be marked
   <code>
    reduced
   </code>
   , in which case, reduce will simply
   <br/>
   ;; return the reduced value as the result of the reduce (fold) on the collection
  </p>
  <pre><code>(reduce (fn [acc v] (if (= v 5) (reduced 5) (conj acc v))) []  [1 2 3 4])
(reduce (fn [acc v] (if (= v 5) (reduced 5) (conj acc v))) []  [1 2 3 4 5])
</code></pre>
  <p>
   ;; You can use
   <code>
    reduced
   </code>
   to indicate that you no longer want to process a collection further
   <br/>
   ;; and terminate the fold with the
   <code>
    reduced
   </code>
   value.
  </p>
  <p>
   ;; This is useful if you want to for example, process the collection until you find the
   <br/>
   ;; item x, or process the first n items in a collection.
  </p>
  <p>
   ;;
   <code>
    take-while
   </code>
   takes a fn f and processes the collection, until (f item) returns false
   <br/>
   ;; and returns the folded value so far.
   <br/>
   ;; Let us implement our
   <code>
    take-while
   </code>
  </p>
  <pre><code>(defn my-take-while
  [f]
  (fn [rf]
    (fn
      ([] (rf))
      ([result] result)
      ([result input] (if (f input)
                        (rf result input)
                        (reduced result))))))
</code></pre>
  <pre><code>(transduce (comp (map inc) (my-take-while (fn [n] (&lt; n 50)))) conj [10 44 56 63 2])
;; =&gt; [11 45]
</code></pre>
  <p>
   ;; There are also transducers that can do stateful transformations.
   <br/>
   ;; One such transformer is
   <code>
    take
   </code>
  </p>
  <pre><code>(defn take
  [n]
  (fn [rf]
    ;; clojure.core/take uses a volatile! which is out of scope for this
    ;; article
    (let [counter (atom n)]
      (fn
        ([] (rf))
        ([result] result)
        ([result input]
         (let [v @counter
               nn (swap! counter dec)]
           (if (pos? v)
             (rf result input)
             (reduced result))))))))
</code></pre>
  <pre><code>(transduce (comp (map inc) (take 5)) conj (range 1 1000))
</code></pre>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
 </body>
</html>