<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
  <title>From 500 secs to 3.5 - The 1brc Challenge</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="basic.css">
</head>
<body>

<header>
  <a href="https://gowind.github.io/">Home</a>
</header>
<header>
<h1 class="title">From 500 secs to 3.5 - The 1brc Challenge</h1>
</header>

<p>All measurements run on an M2Pro Macbook 16” with 32GB RAM.</p>
<p>For those of you that aren’t aware of the <a href="">1brc</a>
challenge, the goal is to parse 1 billion rows in a plain text file,
each row mapping a city to the temperature observed on a particular day
and computing the min,max,average and total temperatures of each city.
The output has to be alphabetically sorted based on the name of the
city.</p>
<p>The title is a little clickbait-y, because I knew that my initial
solution was going to be slow, but yet I still ran it for the sake of
it.</p>
<h2 id="if-it-works-it-aint-stupid">If it works, it ain’t stupid</h2>
<p>My first solution was to write a dumb shell script. Too lazy, I asked
chatGPT to generate an <code>awk</code> script for me to do it and then
I ran it on my local machine.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat average.sh</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Input file path</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="va">input_file</span><span class="op">=</span><span class="st">&quot;measurements.txt&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if the file exists</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">!</span> <span class="ot">-f</span> <span class="st">&quot;</span><span class="va">$input_file</span><span class="st">&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;Error: File not found: </span><span class="va">$input_file</span><span class="st">&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">exit</span> 1</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Use awk to calculate average temperature per city</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="fu">awk</span> <span class="at">-F</span><span class="st">&#39;;&#39;</span> <span class="st">&#39;{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="st">    city = $1</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="st">    temperature = $2</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="st">    sum[city] += temperature</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="st">    count[city]++</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="st">END {</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="st">    for (city in sum) {</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="st">        average = sum[city] / count[city]</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="st">        printf &quot;City: %s, Average Temperature: %.2f\n&quot;, city, average</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="st">}&#39;</span> <span class="st">&quot;</span><span class="va">$input_file</span><span class="st">&quot;</span></span></code></pre></div>
<p>The result ? 487 secs for a single run.</p>
<p>That shell scripts are slow is a known thing. What next ? I didn’t
want to spend too much time on it, so I wrote a similar script in
Javascript with a single thread (I lost the code for it, but it isn’t
too hard to write). The script didn’t do much faster, running at about
460ish seconds (even V8 can only do so much I guess).</p>
<h2 id="going-brrr">Going brrr</h2>
<p>How do I make this faster ? This problem is trivially parallelizable.
Since each line is a separate entry, we can split the giant file to be
worked on by different <code>worker</code> threads and then merge the
results of all the <code>worker</code> threads together in the main
thread. The tricky bit is how do we split the file ?</p>
<p>We can use the <a href="https://linux.die.net/man/2/stat">stat</a>
api to find the size of a file without having to read the entire file.
Once we know the size of the file, we can split it into chunks , where
chunk size = <code>sizeof(file)/num_threads</code>. Each thread will
read the lines present between bytes : [
<code>thread_index * chunk_size</code> …
<code>(thread_index + 1) * chunk_size</code>] and in a thread local
HashMap, map each city =&gt; number of times we saw an entry for the
city , the min , max temperatures and the total sum of all the
temperatures we have seen. Once the threads sum up their chunk of the
file, we then merge the results of these local HashMap into a global
HashMap to calculate each city’s min, max and avg. temperatures.</p>
<p>The file is made of lines like
<code>Vienna;19.1\nPhoenix;16.1\n</code>. The <code>\n</code> at the end
and the <code>V</code> at the beginning might not align exactly for all
the chunks of our threads. What do we do in that case ?</p>
<p>Before a thread begins to process a chunk, we need to adjust its
start and end offsets such that the start offset starts at a character
right after a <code>\n</code> (thus a new entry) and adjust the end
character so that it aligns with a <code>\n</code> .</p>
<p>Here is how I did it in my code</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(startOffset <span class="op">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> buf <span class="op">=</span> <span class="cf">await</span> <span class="fu">readHundred</span>(handle<span class="op">,</span> startOffset<span class="op">-</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span>(buf[<span class="dv">0</span>] <span class="op">==</span> <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>) {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a> } <span class="cf">else</span> {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> nextPos <span class="op">=</span> <span class="fu">nextNewLine</span>(buf<span class="op">,</span> <span class="st">&quot;start&quot;</span>)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    startOffset <span class="op">=</span> nextPos <span class="op">+</span> startOffset<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">readHundred</span>(handle<span class="op">,</span> pos) {</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> b <span class="op">=</span> <span class="bu">Buffer</span><span class="op">.</span><span class="fu">alloc</span>(<span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> results <span class="op">=</span> <span class="cf">await</span> handle<span class="op">.</span><span class="fu">read</span>(b<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> pos)<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> results<span class="op">.</span><span class="at">buffer</span><span class="op">.</span><span class="fu">slice</span>(<span class="dv">0</span><span class="op">,</span> results<span class="op">.</span><span class="at">bytesRead</span><span class="op">-</span><span class="dv">1</span>)<span class="op">.</span><span class="fu">toString</span>()<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>I took the liberty that each line is less than a 100 chars long, so
that we can always find the <code>\n</code> by just reading 100 chars
past the start offset.</p>
<p>Similarly for the end offset</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(endOffset <span class="op">&lt;</span> totalSize) {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> buf <span class="op">=</span> <span class="cf">await</span> <span class="fu">readHundred</span>(handle<span class="op">,</span> endOffset)<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(buf[<span class="dv">0</span>] <span class="op">==</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">||</span> buf[<span class="dv">0</span>] <span class="op">==</span> <span class="st">&quot;</span><span class="sc">\x00</span><span class="st">&quot;</span>) {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> nn <span class="op">=</span> <span class="fu">nextNewLine</span>(buf<span class="op">,</span> <span class="st">&quot;end&quot;</span>)<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    endOffset <span class="op">=</span> nn <span class="op">+</span> endOffset<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">nextNewLine</span>(buffer<span class="op">,</span> ev) {</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> j <span class="op">=</span> buffer<span class="op">.</span><span class="fu">toString</span>()<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(x <span class="op">&lt;</span> j<span class="op">.</span><span class="at">length</span>) {</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(j[x] <span class="op">==</span> <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>) {</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    x <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Once the thread finds the start and the end offsets for each chunk,it
creates a stream between the 2 offsets and iterates through them line by
line :</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> readStream <span class="op">=</span> <span class="cf">await</span> handle<span class="op">.</span><span class="fu">createReadStream</span>({<span class="dt">start</span><span class="op">:</span> startOffset<span class="op">,</span> <span class="dt">end</span><span class="op">:</span> endOffset})<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> rl <span class="op">=</span> readline<span class="op">.</span><span class="fu">createInterface</span>({</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span><span class="op">:</span> readStream<span class="op">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">crlfDelay</span><span class="op">:</span> <span class="kw">Infinity</span> <span class="co">// To handle Windows line endings</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>rl<span class="op">.</span><span class="fu">on</span>(<span class="st">&#39;line&#39;</span><span class="op">,</span> (row) <span class="kw">=&gt;</span> {</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">processRow</span>(row)<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>rl<span class="op">.</span><span class="fu">on</span>(<span class="st">&#39;close&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a> <span class="fu">wrapUp</span>()<span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>You can find this version of code in <a
href="https://github.com/GoWind/1brc/commit/7a64018720365608c5ba8fcb080c63f61cb54f2e">this</a>
commit. Running this code with 12 threads (8 E cores and 4 P cores on my
M2 Pro machine), I got it run at about 48 secs on avg.</p>
<p>Readline is a rather slow way to iterate over a chunk of data because
it reads a chunk of text line by line. When looping over a ReadStream,
we can loop over Text Chunks rather than lines and this might be faster
(you can find this version of my solution in <a
href="https://github.com/GoWind/1brc/commit/3d3be7fd1c51d9304b3cce34bde4d29818db565b">this</a>commit)</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="st">-const rl = readline.createInterface({</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="st">-    input: readStream,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="st">-    crlfDelay: Infinity // To handle Windows line endings</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="st">-  });</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="st">-rl.on(&#39;line&#39;, (row) =&gt; {</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="st">-  processRow(row);</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="st">-});</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="va">+for await (const chunk of readStream) {</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="va">+    let res = await handler(chunk);</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="va">+    if(res == false) {</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="va">+      break;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="va">+    }</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="va">+}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="st">-rl.on(&#39;close&#39;, () =&gt; {</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="st">- wrapUp();</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="st">-});</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="va">+async function handler(chunk) {</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="va">+  let updatedChunk = globalBuffer.concat(chunk);</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="va">+  let rows = updatedChunk.split(&quot;\n&quot;);</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="va">+  if(rows.length) {</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="va">+     if(rows[rows.length-1] == &quot;&quot;) {</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="va">+        globalBuffer = &quot;&quot;;</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="va">+        processRows(rows.slice(0, -1));</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="va">+     } else {</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="va">+       globalBuffer = rows[rows.length-1];</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="va">+       processRows(rows.slice(0, -1));</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="va">+     }</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="va">+  }</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="va">+}</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="va">+wrapUp();</span></span></code></pre></div>
<p>Using chunking as opposed to ReadLine improved the solution by
roughly 20%. I was able to get the solution to run on an avg. of
40secs.</p>
<h3 id="faster">Faster ?</h3>
<p>I was running out of ideas to improve the speed in JS, so time to
bring out the BFG 9000: Zig. As a statically-typed, compiled language,
we should be able to (hopefully) run much faster in Zig. I used the same
approach to build a multi-threaded Zig program, using the same offset
calculation with threads swapping the JS for Zig.</p>
<h4 id="timing">Timing ?</h4>
<p>6.7 secs !</p>
<p>I initially got a shock, because I was doing a Debug build and the
Debug build ran with an average of 56secs. For a few moments, I was
questioning my life decisions and existence in a world where JS was
faster than Zig. Running <code>zig build</code> with the
<code>Doptimize=ReleaseFast</code> flag turned on optimizations that
literally 8xed the speed of my <a
href="https://github.com/GoWind/1brc/commit/7760c6dda6930ff4464cc2cc049bf35988960441">solution</a></p>
<p>I was happy, but by this point, the Java peeps had made the Java
solution complete in under 6 secs. Can I beat that ?</p>
<h3 id="moaaar-power">Moaaar power</h3>
<p>I wanted to do a couple of tweaks before calling it quits. These
tweaks were stuff I found in Danny Van Kooten’s <a
href="https://github.com/dannyvankooten/1brc/blob/main/analyze.c">solution</a>
in C.</p>
<ol type="1">
<li>Use <code>mmap</code> to map the file into the virtual memory,
instead of trying to read chunks of the file in each thread to find the
start and the end offsets</li>
<li>A faster hashMap implementation</li>
<li>not trying to parse the temperatures as floats</li>
</ol>
<p><a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>
takes the contents of a file and maps it into the virtual memory of a
process. This makes reading the file as simple as updating a pointer ,
while the Filesystem + OS takes care of swapping in and out the parts of
the files currently being read. We are not updating the mapping/file,
only reading it , so <code>mmap</code>ing the file turned out to be a
simple choice</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="st">-    const file = try std.fs.openFileAbsoluteZ(filepath, .{});</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="st">-    defer file.close();</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="st">-    const stat = try file.stat();</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="st">-    std.debug.print(&quot;file size is {}\n&quot;, .{stat.size});</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="va">+    const fd = try std.os.open(filepath, std.os.O.RDONLY, 0);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="va">+    defer std.os.close(fd);</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="va">+    const stat = try std.os.fstat(fd);</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="va">+    const mapping = try std.os.mmap(null, @as(u64, @intCast(stat.size)), std.os.PROT.READ, std.os.MAP.PRIVATE, fd, 0);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="va">+    defer std.os.munmap(mapping);</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">@@ -43,146 +44,60 @@ fn calculate(</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>     idx: usize,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>     workerSize: u64,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>     allocator: std.mem.Allocator,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="st">-    filepath: [*:0]u8,</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="va">+    file: []u8,</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a> ) !void {</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="st">-    var buffer = [_]u8{&#39;a&#39;} ** 80000;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="st">-    const waterMarkSize: usize = 80000;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="st">-    const slice = buffer[0..100];</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="st">-    const View = struct { slice: []u8, len: usize };</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="st">-    const file = try std.fs.openFileAbsoluteZ(filepath, .{});</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="st">-    const stat = try file.stat();</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="st">-    defer file.close();</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="va">+    const finalEndOffset = file.len - 1;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>     var startOffset = idx * workerSize;</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>     var endOffset = (idx + 1) * workerSize - 1;</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>     if (startOffset &gt; 0) {</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>         const prev = startOffset - 1;</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="st">-        try file.seekTo(prev);</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="st">-        const read = try file.readAll(slice);</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="st">-        if (read == 0) {</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="st">-            @panic(&quot;failed to read from starting offset&quot;);</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="st">-        }</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="st">-        if (buffer[0] != &#39;\n&#39;) {</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="st">-            var i: usize = 1;</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="st">-            while (i &lt; read) : (i += 1) {</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="st">-                if (buffer[i] == &#39;\n&#39;) {</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="st">-                    startOffset += i;</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="st">-                    break;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a><span class="st">-                }</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="va">+        if (file[prev] != &#39;\n&#39;) {</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="va">+            while (file[startOffset] != &#39;\n&#39;) {</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a><span class="va">+                startOffset += 1;</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>             }</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="st">-        }</span></span></code></pre></div>
<p>I didn’t record the timings for [this] change alone, but my
measurements varied anywhere from ~5.5-9secs (probably depending on
filesystem caches in memory being cold/warm)</p>
<p>The next trick I attempted to use was to parse each temperature as an
<code>i32</code> and not as a <code>f32</code>. Float parsing is tricky,
and slower than parsing integers. Since each temperature entry in the
challenge has only one digit after the decimal point, we can parse
<code>16.1</code> as <code>161</code> and divide the final result only
by <code>10</code>, thus saving a lot of time spent parsing</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="st">-pub const Record = struct { min: f32 = 0, max: f32 = 0, total: f32 = 0, count: u32 = 0 };</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="va">+const SliceList = std.ArrayList([]const u8);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="va">+const writer = std.io.getStdOut().writer();</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="va">+pub const Record = struct { min: i32 = 0, max: i32 = 0, total: i32 = 0, count: u32 = 0 };</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="st">-            const temp = try std.fmt.parseFloat(f32, num);</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="va">+            const temp = parsei32(num);</span></span></code></pre></div>
<p>(Again, I did not record the timings for this change <a
href="https://github.com/GoWind/1brc/commit/23fafbfebbb82bafcd9433e1230f89a6c6cdf52a">this</a>
change alone)</p>
<p>The last trick I wanted to try was using a custom Hash function /
HashMap for tracking city -&gt; temperature stats. From profiling my
application with flamegraphs, it was clear that most of the time was
spent in looking up a city’s existing entry in the threadlocal HashMap.
Since our keys are strings, we can use a simple hash function to hash
the city names. A simple function that is easy to compute is <a
href="https://t.co/C2ZfSSiYSW">djb2</a>. I decided to use this as my
hash fn</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>fn <span class="fu">hashSlice</span>(data<span class="op">:</span> []u8<span class="op">,</span> totalSize<span class="op">:</span> usize) usize {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> k<span class="op">:</span> usize <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> hash<span class="op">:</span> usize <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (k <span class="op">&lt;</span> data<span class="op">.</span><span class="at">len</span>) <span class="op">:</span> (k <span class="op">+=</span> <span class="dv">1</span>) {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        hash <span class="op">=</span> (hash <span class="op">*</span> <span class="dv">31</span> <span class="op">+</span> data[k]) <span class="op">&amp;</span> (totalSize <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hash<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>As for a HashMap, is there a faster way ? We know that there aren’t a
lot of cities in the entry, so we probably can get away with replacing
the thread local HashMap with an array instead (actually 2 arrays) 1. We
create a threadlocal array with 2^16 entries and fill each of them with
a <code>0</code>. 2. We create another array: <code>entries</code>, with
index <code>i</code> starting at 0. Each new string is provided a new
index in this array. The values of entries are all set to a sentinel
value. 3. We hash each string and then perform a module of that hash
with (2^16-1) thus getting a number N between [0, 2^16-1]. 4. We then
start at array[N] and proceed with N = (N+ 1) % 2^16-1 , till array[N]
== Sentinel Value or array[N] == N. 5. if entries[N] is a Sentinel
Value, it means we have not encountered string S yet. We create a Record
for this city at <code>entries[N]</code> and set Array[N] = N 6. Else,
it means we already have a valid entry for the city S. We then simply
update the count and the min,max and average of the City at
entries[N]</p>
<p>It is probably much simpler to understand the code:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="va">+    var hashList = try NumList.initCapacity(allocator, maxSize);</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="va">+    var indexList = try NumList.initCapacity(allocator, maxSize);</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="va">+    hashList.appendNTimesAssumeCapacity(0, maxSize);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="va">+    indexList.appendNTimesAssumeCapacity(1 &lt;&lt; 16, maxSize);</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>// 1 &lt;&lt; 16 is the sentinel value</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="st">-</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="st">-            const maybeEntry = threadMap[idx].getEntry(city);</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="st">-            if (maybeEntry) |entry| {</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="st">-                entry.value_ptr.*.count += 1;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="st">-                entry.value_ptr.*.total += temp;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="st">-                entry.value_ptr.*.max = @max(entry.value_ptr.*.max, temp);</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="st">-                entry.value_ptr.*.min = @min(entry.value_ptr.*.min, temp);</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="va">+            var hashVal = hashSlice(city, maxSize);</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="va">+            while (hashList.items[hashVal] != hashVal and hashList.items[hashVal] != 0) {</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="va">+                hashVal = (hashVal + 1) &amp; (maxSize - 1);</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="va">+            }</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="va">+            const entryIdx = indexList.items[hashVal];</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="va">+            if (entryIdx == 1 &lt;&lt; 16) {</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="va">+                const cityNameForRec = try allocator.alloc(u8, city.len);</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="va">+                @memcpy(cityNameForRec, city);</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="va">+                const rec = Record{ .city = cityNameForRec, .count = 1, .min = temp, .max = tem</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>p, .total = temp };</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a><span class="va">+                try threadMap[idx].append(rec);</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="va">+                indexList.items[hashVal] = threadMap[idx].items.len - 1;</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="va">+                hashList.items[hashVal] = hashVal;</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>             } else {</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a><span class="st">-                const rec = Record{ .count = 1, .min = temp, .max = temp, .total = temp };</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="st">-                const k = try allocator.alloc(u8, city.len);</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a><span class="st">-                @memcpy(k, city);</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a><span class="st">-                try threadMap[idx].put(k, rec);</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a><span class="va">+                threadMap[idx].items[entryIdx].count += 1;</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a><span class="va">+                threadMap[idx].items[entryIdx].total += temp;</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a><span class="va">+                threadMap[idx].items[entryIdx].max = @max(threadMap[idx].items[entryIdx].max, t</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>emp);</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a><span class="va">+                threadMap[idx].items[entryIdx].min = @min(threadMap[idx].items[entryIdx].min, t</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>emp);</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>             }</span></code></pre></div>
<p>We replaced the zig HashMap with our custom one. So how did the end
result go ?</p>
<h4 id="answer-faaast">Answer: Faaast !</h4>
<p>The <a
href="https://github.com/GoWind/1brc/commit/dfc37a92b5fcb835dc994e48ef54eab060fd03bb?diff=unified&amp;w=1">updated</a>solution
hit ~3.5 secs on the average. This was almost 2x faster than our
previous solution ! I was elated that such simple optimizations could
make such a big difference.</p>
<p>I wanted to proceed with more optimizations to make the solution go
even faster, but unfortunately I no longer had the time to pursue the
project , and having hit the deadline I set for myself, was happy to
have come so far. Also given that my daily driver is a Mac, it was very
hard to generate flamegraphs for Zig programs and trying to optimize
programs without them is like trying to navigate a race course blind. In
the end, I decided to wrap up the experiments and call it a day</p>
<h2 id="takeaways">Takeaways</h2>
<p>Zig is faaaast ! More than that, it makes doing things that could be
done by C (mmap, allocations) etc so much simpler. The only language
wart that I still hate is that I never know when it copies a data
structure vs when it doesn’t , so I ended up spending a lot of time
debugging subtle bugs.</p>
<p>For example, take this update in a fn that runs in a worker
thread</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode ts"><code class="sourceCode typescript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> TempMap <span class="op">=</span> std<span class="op">.</span><span class="fu">StringHashMap</span>(Record)<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> threadMap<span class="op">:</span> [numWorkers]RecordList <span class="op">=</span> <span class="kw">undefined</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> threads<span class="op">:</span> [numWorkers]std<span class="op">.</span><span class="at">Thread</span> <span class="op">=</span> <span class="kw">undefined</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> NumList <span class="op">=</span> std<span class="op">.</span><span class="fu">ArrayList</span>(usize)<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> maxSize<span class="op">:</span> usize <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">14</span><span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>pub fn <span class="fu">main</span>() <span class="op">!</span><span class="kw">void</span> {</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>fn <span class="fu">calculate</span>(<span class="op">...</span>) {</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>                threadMap[idx]<span class="op">.</span><span class="at">items</span>[entryIdx]<span class="op">.</span><span class="at">count</span> <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>                threadMap[idx]<span class="op">.</span><span class="at">items</span>[entryIdx]<span class="op">.</span><span class="at">total</span> <span class="op">+=</span> temp<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>                threadMap[idx]<span class="op">.</span><span class="at">items</span>[entryIdx]<span class="op">.</span><span class="at">max</span> <span class="op">=</span> @<span class="fu">max</span>(threadMap[idx]<span class="op">.</span><span class="at">items</span>[entryIdx]<span class="op">.</span><span class="at">max</span><span class="op">,</span> temp)<span class="op">;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>                threadMap[idx]<span class="op">.</span><span class="at">items</span>[entryIdx]<span class="op">.</span><span class="at">min</span> <span class="op">=</span> @<span class="fu">min</span>(threadMap[idx]<span class="op">.</span><span class="at">items</span>[entryIdx]<span class="op">.</span><span class="at">min</span><span class="op">,</span> temp)<span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In fn <code>calculate</code>, I had done</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode ts"><code class="sourceCode typescript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">var</span> t <span class="op">=</span> threadMap[idx]<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>        t<span class="op">.</span><span class="at">items</span>[entryIdx]<span class="op">.</span><span class="at">count</span> <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        t<span class="op">.</span><span class="at">items</span>[entryIdx]<span class="op">.</span><span class="at">total</span> <span class="op">+=</span> temp<span class="op">;</span></span></code></pre></div>
<p>What happened was, this created a new copy of
<code>threadMap[idx]</code> for each thread in the fn calculate and the
updates were going into this copy <code>t</code> , rather than at
<code>threadMap[idx]</code>. As a result, after my threads finished
running, when attempting to merge all the entries from each thread’s
threadMap, I was running into empty maps, because none of the entries
added to <code>t</code> were actually added to
<code>threadMap[idx]</code>. The fix was simple, but the lack of docs or
syntax about move semantics or copy constructors makes it sometimes a
frustrating experience.</p>
<p>In the end though, the ability of Zig to provide the speed of C with
a far better syntax and APIs make these frustrations vanish. Happy
Hacking !</p>


</body>
</html>
