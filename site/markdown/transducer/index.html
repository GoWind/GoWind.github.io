<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Transducers - A Walkthrough - Gowind's notes</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Gowind's notes</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../../about/" class="nav-link">About</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#transducers-a-walkthrough" class="nav-link">Transducers - A Walkthrough</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="transducers-a-walkthrough">Transducers - A Walkthrough</h1>
<p>The idea of the article is to provide a walkthrough guide of sorts for understandig
a <code>transducer</code>  in Clojure. </p>
<p>You can play with the code mentioned below by downloading this <a href="https://gist.github.com/GoWind/24256bd633392bd9e70dcb30af62de10">file</a> and executing the code in the REPL.</p>
<pre><code>(ns transducertutorial.core)
</code></pre>
<p>;; A Reducing function is one that takes
;; an accumulator and an item
;; and returns a new accumulator with the item processed</p>
<pre><code>(defn my-reducing-fn
  [accumulator item]
  (conj accumulator item))
</code></pre>
<p>;; <code>conj</code> is smart enough to know how to how to add the item to the
;; accumulator
;; even conj is a reducing-fn</p>
<p>;; How do we use something like conj to implement map and filter ?
;; Via <code>reduce</code>. Reduce takes a reducing fn., an accumulator and a
;; the collection that must be reduced.</p>
<pre><code>(reduce (fn [acc item] (conj acc item)) [] [1 2 3 4 5])
</code></pre>
<p>;; We can implement map and filter via reduce</p>
<pre><code>(defn map-via-reduce
  [mapping-fn coll]
  (reduce (fn [acc item] (conj acc (mapping-fn item))) [] coll))
</code></pre>
<pre><code>(defn filter-via-reduce
  [filter-fn coll]
  (reduce (fn [acc item] (if (filter-fn item) (conj acc item) acc) [] coll)))
</code></pre>
<p>;; There are 3 tight <strong>"couplings"</strong>
;; a) We use conj to add item to the accumulator
;; b) We use an empty vector [] as the collection
;;      for reduction
;; c) If we want to compose our map and filter fns, we can pass the output
;;     of one to the other. While doing so we are creating a new collection after
;;     each map or reduce, which can be very expensive in terms of memory and
;;     computation time</p>
<p>;; Ideally we would a composition of map and filter to look like </p>
<pre><code>(defn map-fn [item] (inc item))
(defn filter-fn [item] (some? item))
(reduce (fn [acc item] (if (filter-fn item) (conj acc (map-fn item)) acc)) [] [1 2 3 4 5])
</code></pre>
<p><strong>I would say that this, perhaps is the core idea behind transducers,
behing able to compose our input processing functions in such a way
that they are run only once for each item</strong></p>
<p>;; Lets make a couple of small changes to a reducing function
;; by adding an arity-0 and an arity-1 variation to it</p>
<pre><code>(defn my-rf
  ([] [])
  ([result] result)
  ([result input] (conj result input)))
</code></pre>
<p>;; Our reducing fn can now
;; a. create a new <code>collection, if called with no args
;; b. if not provided an</code>item<code>but only with a collection, pass the collection on
;; c. when it gets a</code>collection<code>and an</code>item<code>knows how to add the</code>item<code>to
;; the</code>collection`.</p>
<p>;; Let us also create a more "fun" version of a multi-arity
;; reducing fn.</p>
<pre><code>(defn str-rf
  ([] &quot;&quot;)
  ([a-string] a-string)
  ([a-string a-input] (str a-string a-input)))
</code></pre>
<p>;; we now make tweak map and filter to make them a transducer, a.k.a transforming reducer
;; Map and filter accept a fn as usual, but instead of accepting
;; a mapping fn and a collection,
;; we also have a version where</p>
<pre><code>(defn my-map
  ([f]
   (fn [rf]
     (fn
       ([] (rf))
       ([result] result)
       ([result input] (rf result (f input))))))
  ;; The traditional map version
  ;; There are more arities that accept 2,3 and n colls
  ;; but I have left them out for the sake of clarity
  ([f coll]
   (map f coll)))
</code></pre>
<pre><code>(defn my-filter
  [f]
  (fn [rf]
    (fn
      ([] (rf))
      ([result] result)
      ([result input] (if (f input)
                        (rf result input)
                        result)))))
</code></pre>
<p>;; Order of applying fns is left -&gt; right (even? is applied first before inc)</p>
<pre><code>(transduce (comp (my-filter even?) (my-map inc)) my-rf [10 12 14]) ;; [11 13 15]
</code></pre>
<pre><code>(transduce (comp (my-filter even?) (my-map inc)) my-rf [10 12 14]) ;; []
</code></pre>
<p>;; What is happening here ?
;; what transduce does internally is ((comp (my-filter even?) (my-map inc)) my-rf)
;; which translates to something like</p>
<pre><code>(comment
  (let [inc-mapped     (my-map inc)
        inc-with-rf    (inc-mapped my-rf)
        even-filter    (my-filter even?)
        even-filter-rf (even-filter inc-with-rf)]
    even-filter-rf))
</code></pre>
<p>;; What even-filter-rf will do when when it gets an accumulator
;; and an input is something akin to
;; <code>(fn [acc input] (if (even? input) (inc-with-rf acc input) acc))</code>
;; Notice that inc-with-rf is exactly of the same format.
;; Here, replace the <code>(if (even? input) ..)</code> with <code>(my-rf acc (inc input)</code></p>
<p>;; lets use our str-rf to see how it works</p>
<pre><code>(transduce (comp (my-filter even?) (my-map inc)) str-rf [10 12 14])
</code></pre>
<p>;; We have solved 2 problems so far.
;; 1. Decouple the creation of the output collection by letting the
;;    reducing fn take care of that
;; 2. Ensuring that the composition of our filter and map is run only once
;;    for each item in our collection</p>
<p>;; There is one more problem: how do we iterate over the input collection?
;; Enter protocols to the rescue
;; Collections implement clojure.lang.IReduceInit
;; or          implement clojure.core.protocols/coll-reduce
;; All collections that implement IReduceInit know how to take
;; a. An accumulator
;; b. A reducing fn
;; And reduce themselves using the reducing fn and the accumulator
;; The same goes for coll-reduce
;; We thus solved the problem of iterating (folding) over the collection by letting the
;; collection do it for us.</p>
<p>;; There is also an interesting property of the built-in reduce.
;; A value can be marked <code>reduced</code>, in which case, reduce will simply
;; return the reduced value as the result of the reduce (fold) on the collection</p>
<pre><code>(reduce (fn [acc v] (if (= v 5) (reduced 5) (conj acc v))) []  [1 2 3 4])
(reduce (fn [acc v] (if (= v 5) (reduced 5) (conj acc v))) []  [1 2 3 4 5])
</code></pre>
<p>;; You can use <code>reduced</code> to indicate that you no longer want to process a collection further
;; and terminate the fold with the <code>reduced</code> value.</p>
<p>;; This is useful if you want to for example, process the collection until you find the
;; item x, or process the first n items in a collection.</p>
<p>;; <code>take-while</code> takes a fn f and processes the collection, until (f item) returns false
;; and returns the folded value so far.
;; Let us implement our <code>take-while</code></p>
<pre><code>(defn my-take-while
  [f]
  (fn [rf]
    (fn
      ([] (rf))
      ([result] result)
      ([result input] (if (f input)
                        (rf result input)
                        (reduced result))))))
</code></pre>
<pre><code>(transduce (comp (map inc) (my-take-while (fn [n] (&lt; n 50)))) conj [10 44 56 63 2])
;; =&gt; [11 45]
</code></pre>
<p>;; There are also transducers that can do stateful transformations.
;; One such transformer is <code>take</code></p>
<pre><code>(defn take
  [n]
  (fn [rf]
    ;; clojure.core/take uses a volatile! which is out of scope for this
    ;; article
    (let [counter (atom n)]
      (fn
        ([] (rf))
        ([result] result)
        ([result input]
         (let [v @counter
               nn (swap! counter dec)]
           (if (pos? v)
             (rf result input)
             (reduced result))))))))
</code></pre>
<pre><code>(transduce (comp (map inc) (take 5)) conj (range 1 1000))
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
